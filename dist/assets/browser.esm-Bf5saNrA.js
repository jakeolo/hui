import{p as di,g as Ie}from"./index-NjRccmIO.js";const Ms=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];function ii(o,t){if(!t||t==10)return BigInt(o);if(t==16)return o.slice(0,2)=="0x"?BigInt(o):BigInt("0x"+o)}const an=ii;function zs(o,t){let n=BigInt(0);t=BigInt(t);for(let a=0;a<o.length;a++)n=n*t+BigInt(o[a]);return n}function Ma(o){const t=o.toString(16);return(t.length-1)*4+Ms[parseInt(t[0],16)]}function Ao(o){return BigInt(o)<BigInt(0)}function yo(o){return!o}function Za(o,t){return BigInt(o)<<BigInt(t)}function sa(o,t){return BigInt(o)>>BigInt(t)}const qs=Za,Qs=sa;function ee(o){return(BigInt(o)&BigInt(1))==BigInt(1)}function Rs(o){let t=BigInt(o);const n=[];for(;t;){if(t&BigInt(1)){const a=2-Number(t%BigInt(4));n.push(a),t=t-BigInt(a)}else n.push(0);t=t>>BigInt(1)}return n}function Co(o){let t=BigInt(o);const n=[];for(;t;)t&BigInt(1)?n.push(1):n.push(0),t=t>>BigInt(1);return n}function Io(o){if(o>BigInt(Number.MAX_SAFE_INTEGER))throw new Error("Number too big");return Number(o)}function ks(o,t){const n=[];let a=BigInt(o);for(t=BigInt(t);a;)n.unshift(Number(a%t)),a=a/t;return n}function oe(o,t){return BigInt(o)+BigInt(t)}function Tn(o,t){return BigInt(o)-BigInt(t)}function Eo(o){return-BigInt(o)}function Fo(o,t){return BigInt(o)*BigInt(t)}function $s(o){return BigInt(o)*BigInt(o)}function za(o,t){return BigInt(o)**BigInt(t)}function Ns(o,t){return BigInt(o)**BigInt(t)}function Ds(o){return BigInt(o)>=0?BigInt(o):-BigInt(o)}function ra(o,t){return BigInt(o)/BigInt(t)}function Fn(o,t){return BigInt(o)%BigInt(t)}function Gn(o,t){return BigInt(o)==BigInt(t)}function Vs(o,t){return BigInt(o)!=BigInt(t)}function Hs(o,t){return BigInt(o)<BigInt(t)}function Mi(o,t){return BigInt(o)>BigInt(t)}function Ks(o,t){return BigInt(o)<=BigInt(t)}function Bo(o,t){return BigInt(o)>=BigInt(t)}function se(o,t){return BigInt(o)&BigInt(t)}function js(o,t){return BigInt(o)|BigInt(t)}function Zs(o,t){return BigInt(o)^BigInt(t)}function Ws(o,t){return BigInt(o)&&BigInt(t)}function Ys(o,t){return BigInt(o)||BigInt(t)}function Xs(o){return!BigInt(o)}function Oa(o,t,n,a){const i="0000000"+n.toString(16),e=new Uint32Array(o.buffer,o.byteOffset+t,a/4),l=((i.length-7)*4-1>>5)+1;for(let s=0;s<l;s++)e[s]=parseInt(i.substring(i.length-8*s-8,i.length-8*s),16);for(let s=l;s<e.length;s++)e[s]=0;for(let s=e.length*4;s<a;s++)o[s]=Io(se(sa(n,s*8),255))}function So(o,t,n,a){const i="0000000"+n.toString(16),e=new DataView(o.buffer,o.byteOffset+t,a),l=((i.length-7)*4-1>>5)+1;for(let s=0;s<l;s++)e.setUint32(a-s*4-4,parseInt(i.substring(i.length-8*s-8,i.length-8*s),16),!1);for(let s=0;s<a/4-l;s++)e[s]=0}function Ua(o,t,n){n=n||o.byteLength,t=t||0;const a=new Uint32Array(o.buffer,o.byteOffset+t,n/4),i=new Array(n/4);return a.forEach((e,l)=>i[i.length-l-1]=e.toString(16).padStart(8,"0")),ii(i.join(""),16)}function xo(o,t,n){n=n||o.byteLength,t=t||0;const a=new DataView(o.buffer,o.byteOffset+t,n),i=new Array(n/4);for(let e=0;e<n/4;e++)i[e]=a.getUint32(e*4,!1).toString(16).padStart(8,"0");return ii(i.join(""),16)}function ce(o,t){return o.toString(t)}function da(o){const t=new Uint8Array(Math.floor((Ma(o)-1)/8)+1);return Oa(t,0,o,t.byteLength),t}const vo=an(0),jn=an(1);var Js=Object.freeze({__proto__:null,abs:Ds,add:oe,band:se,bitLength:Ma,bits:Co,bor:js,bxor:Zs,div:ra,e:an,eq:Gn,exp:Ns,fromArray:zs,fromRprBE:xo,fromRprLE:Ua,fromString:ii,geq:Bo,gt:Mi,isNegative:Ao,isOdd:ee,isZero:yo,land:Ws,leq:Ks,lnot:Xs,lor:Ys,lt:Hs,mod:Fn,mul:Fo,naf:Rs,neg:Eo,neq:Vs,one:jn,pow:za,shiftLeft:Za,shiftRight:sa,shl:qs,shr:Qs,square:$s,sub:Tn,toArray:ks,toLEBuff:da,toNumber:Io,toRprBE:So,toRprLE:Oa,toString:ce,zero:vo});function Ee(o,t,n){if(yo(n))return o.one;const a=Co(n);if(a.length==0)return o.one;let i=t;for(let e=a.length-2;e>=0;e--)i=o.square(i),a[e]&&(i=o.mul(i,t));return i}function tc(o){if(o.m%2==1)if(Gn(Fn(o.p,4),1))if(Gn(Fn(o.p,8),1))if(Gn(Fn(o.p,16),1))nc(o);else if(Gn(Fn(o.p,16),9))ac(o);else throw new Error("Field withot sqrt");else if(Gn(Fn(o.p,8),5))ic(o);else throw new Error("Field withot sqrt");else Gn(Fn(o.p,4),3)&&ec(o);else{const t=Fn(za(o.p,o.m/2),4);t==1?oc(o):t==3?sc(o):cc(o)}}function nc(o){for(o.sqrt_q=za(o.p,o.m),o.sqrt_s=0,o.sqrt_t=Tn(o.sqrt_q,1);!ee(o.sqrt_t);)o.sqrt_s=o.sqrt_s+1,o.sqrt_t=ra(o.sqrt_t,2);let t=o.one;for(;o.eq(t,o.one);){const n=o.random();o.sqrt_z=o.pow(n,o.sqrt_t),t=o.pow(o.sqrt_z,2**(o.sqrt_s-1))}o.sqrt_tm1d2=ra(Tn(o.sqrt_t,1),2),o.sqrt=function(n){const a=this;if(a.isZero(n))return a.zero;let i=a.pow(n,a.sqrt_tm1d2);const e=a.pow(a.mul(a.square(i),n),2**(a.sqrt_s-1));if(a.eq(e,a.negone))return null;let l=a.sqrt_s,s=a.mul(n,i),h=a.mul(s,i),d=a.sqrt_z;for(;!a.eq(h,a.one);){let c=a.square(h),f=1;for(;!a.eq(c,a.one);)c=a.square(c),f++;i=d;for(let y=0;y<l-f-1;y++)i=a.square(i);d=a.square(i),h=a.mul(h,d),s=a.mul(s,i),l=f}return a.geq(s,a.zero)?s:a.neg(s)}}function ac(o){o.sqrt=function(){throw new Error("Sqrt alg 4 not implemented")}}function ic(o){o.sqrt=function(){throw new Error("Sqrt alg 3 not implemented")}}function ec(o){o.sqrt_q=za(o.p,o.m),o.sqrt_e1=ra(Tn(o.sqrt_q,3),4),o.sqrt=function(t){if(this.isZero(t))return this.zero;const n=this.pow(t,this.sqrt_e1),a=this.mul(this.square(n),t);if(this.eq(a,this.negone))return null;const i=this.mul(n,t);return o.geq(i,o.zero)?i:o.neg(i)}}function oc(o){o.sqrt=function(){throw new Error("Sqrt alg 10 not implemented")}}function sc(o){o.sqrt_q=za(o.p,o.m/2),o.sqrt_e34=ra(Tn(o.sqrt_q,3),4),o.sqrt_e12=ra(Tn(o.sqrt_q,1),2),o.frobenius=function(t,n){return t%2==1?o.conjugate(n):n},o.sqrt=function(t){const n=this,a=n.pow(t,n.sqrt_e34),i=n.mul(n.square(a),t),e=n.mul(n.frobenius(1,i),i);if(n.eq(e,n.negone))return null;const l=n.mul(a,t);let s;if(n.eq(i,n.negone))s=n.mul(l,[n.F.zero,n.F.one]);else{const h=n.pow(n.add(n.one,i),n.sqrt_e12);s=n.mul(h,l)}return n.geq(s,n.zero)?s:n.neg(s)}}function cc(o){o.sqrt=function(){throw new Error("Sqrt alg 8 not implemented")}}function Qn(o,t,n,a,i){o[t]=o[t]+o[n]>>>0,o[i]=(o[i]^o[t])>>>0,o[i]=(o[i]<<16|o[i]>>>16&65535)>>>0,o[a]=o[a]+o[i]>>>0,o[n]=(o[n]^o[a])>>>0,o[n]=(o[n]<<12|o[n]>>>20&4095)>>>0,o[t]=o[t]+o[n]>>>0,o[i]=(o[i]^o[t])>>>0,o[i]=(o[i]<<8|o[i]>>>24&255)>>>0,o[a]=o[a]+o[i]>>>0,o[n]=(o[n]^o[a])>>>0,o[n]=(o[n]<<7|o[n]>>>25&127)>>>0}function lc(o){Qn(o,0,4,8,12),Qn(o,1,5,9,13),Qn(o,2,6,10,14),Qn(o,3,7,11,15),Qn(o,0,5,10,15),Qn(o,1,6,11,12),Qn(o,2,7,8,13),Qn(o,3,4,9,14)}class Jn{constructor(t){t=t||[0,0,0,0,0,0,0,0],this.state=[1634760805,857760878,2036477234,1797285236,t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],0,0,0,0],this.idx=16,this.buff=new Array(16)}nextU32(){return this.idx==16&&this.update(),this.buff[this.idx++]}nextU64(){return oe(Fo(this.nextU32(),4294967296),this.nextU32())}nextBool(){return(this.nextU32()&1)==1}update(){for(let t=0;t<16;t++)this.buff[t]=this.state[t];for(let t=0;t<10;t++)lc(this.buff);for(let t=0;t<16;t++)this.buff[t]=this.buff[t]+this.state[t]>>>0;this.idx=0,this.state[12]=this.state[12]+1>>>0,this.state[12]==0&&(this.state[13]=this.state[13]+1>>>0,this.state[13]==0&&(this.state[14]=this.state[14]+1>>>0,this.state[14]==0&&(this.state[15]=this.state[15]+1>>>0)))}}function Go(o){let t=new Uint8Array(o);if(typeof globalThis.crypto<"u")globalThis.crypto.getRandomValues(t);else for(let n=0;n<o;n++)t[n]=Math.random()*4294967296>>>0;return t}function rc(){const o=Go(32),t=new Uint32Array(o.buffer),n=[];for(let a=0;a<8;a++)n.push(t[a]);return n}let Na=null;function le(){return Na||(Na=new Jn(rc()),Na)}class dc{constructor(t,n,a){this.F=n,this.G=t,this.opMulGF=a;let i=n.sqrt_t||n.t,e=n.sqrt_s||n.s,l=n.one;for(;n.eq(n.pow(l,n.half),n.one);)l=n.add(l,n.one);this.w=new Array(e+1),this.wi=new Array(e+1),this.w[e]=this.F.pow(l,i),this.wi[e]=this.F.inv(this.w[e]);let s=e-1;for(;s>=0;)this.w[s]=this.F.square(this.w[s+1]),this.wi[s]=this.F.square(this.wi[s+1]),s--;this.roots=[],this._setRoots(Math.min(e,15))}_setRoots(t){for(let n=t;n>=0&&!this.roots[n];n--){let a=this.F.one;const i=1<<n,e=new Array(i);for(let l=0;l<i;l++)e[l]=a,a=this.F.mul(a,this.w[n]);this.roots[n]=e}}fft(t){if(t.length<=1)return t;const n=Fe(t.length-1)+1;this._setRoots(n);const a=1<<n;if(t.length!=a)throw new Error("Size must be multiple of 2");return Wa(this,t,n,0,1)}ifft(t){if(t.length<=1)return t;const n=Fe(t.length-1)+1;this._setRoots(n);const a=1<<n;if(t.length!=a)throw new Error("Size must be multiple of 2");const i=Wa(this,t,n,0,1),e=this.F.inv(this.F.mulScalar(this.F.one,a)),l=new Array(a);for(let s=0;s<a;s++)l[s]=this.opMulGF(i[(a-s)%a],e);return l}}function Fe(o){return((o&4294901760)!==0?(o&=4294901760,16):0)|((o&4278255360)!==0?(o&=4278255360,8):0)|((o&4042322160)!==0?(o&=4042322160,4):0)|((o&3435973836)!==0?(o&=3435973836,2):0)|(o&2863311530)!==0}function Wa(o,t,n,a,i){const e=1<<n;if(e==1)return[t[a]];if(e==2)return[o.G.add(t[a],t[a+i]),o.G.sub(t[a],t[a+i])];const l=e>>1,s=Wa(o,t,n-1,a,i*2),h=Wa(o,t,n-1,a+i,i*2),d=new Array(e);for(let c=0;c<l;c++)d[c]=o.G.add(s[c],o.opMulGF(h[c],o.roots[n][c])),d[c+l]=o.G.sub(s[c],o.opMulGF(h[c],o.roots[n][c]));return d}class re{constructor(t){this.type="F1",this.one=BigInt(1),this.zero=BigInt(0),this.p=BigInt(t),this.m=1,this.negone=this.p-this.one,this.two=BigInt(2),this.half=this.p>>this.one,this.bitLength=Ma(this.p),this.mask=(this.one<<BigInt(this.bitLength))-this.one,this.n64=Math.floor((this.bitLength-1)/64)+1,this.n32=this.n64*2,this.n8=this.n64*8,this.R=this.e(this.one<<BigInt(this.n64*64)),this.Ri=this.inv(this.R);const n=this.negone>>this.one;this.nqr=this.two;let a=this.pow(this.nqr,n);for(;!this.eq(a,this.negone);)this.nqr=this.nqr+this.one,a=this.pow(this.nqr,n);for(this.s=0,this.t=this.negone;(this.t&this.one)==this.zero;)this.s=this.s+1,this.t=this.t>>this.one;this.nqr_to_t=this.pow(this.nqr,this.t),tc(this),this.FFT=new dc(this,this,this.mul.bind(this)),this.fft=this.FFT.fft.bind(this.FFT),this.ifft=this.FFT.ifft.bind(this.FFT),this.w=this.FFT.w,this.wi=this.FFT.wi,this.shift=this.square(this.nqr),this.k=this.exp(this.nqr,2**this.s)}e(t,n){let a;if(n?n==16&&(a=BigInt("0x"+t)):a=BigInt(t),a<0){let i=-a;return i>=this.p&&(i=i%this.p),this.p-i}else return a>=this.p?a%this.p:a}add(t,n){const a=t+n;return a>=this.p?a-this.p:a}sub(t,n){return t>=n?t-n:this.p-n+t}neg(t){return t&&this.p-t}mul(t,n){return t*n%this.p}mulScalar(t,n){return t*this.e(n)%this.p}square(t){return t*t%this.p}eq(t,n){return t==n}neq(t,n){return t!=n}lt(t,n){const a=t>this.half?t-this.p:t,i=n>this.half?n-this.p:n;return a<i}gt(t,n){const a=t>this.half?t-this.p:t,i=n>this.half?n-this.p:n;return a>i}leq(t,n){const a=t>this.half?t-this.p:t,i=n>this.half?n-this.p:n;return a<=i}geq(t,n){const a=t>this.half?t-this.p:t,i=n>this.half?n-this.p:n;return a>=i}div(t,n){return this.mul(t,this.inv(n))}idiv(t,n){if(!n)throw new Error("Division by zero");return t/n}inv(t){if(!t)throw new Error("Division by zero");let n=this.zero,a=this.p,i=this.one,e=t%this.p;for(;e;){let l=a/e;[n,i]=[i,n-l*i],[a,e]=[e,a-l*e]}return n<this.zero&&(n+=this.p),n}mod(t,n){return t%n}pow(t,n){return Ee(this,t,n)}exp(t,n){return Ee(this,t,n)}band(t,n){const a=t&n&this.mask;return a>=this.p?a-this.p:a}bor(t,n){const a=(t|n)&this.mask;return a>=this.p?a-this.p:a}bxor(t,n){const a=(t^n)&this.mask;return a>=this.p?a-this.p:a}bnot(t){const n=t^this.mask;return n>=this.p?n-this.p:n}shl(t,n){if(Number(n)<this.bitLength){const a=t<<n&this.mask;return a>=this.p?a-this.p:a}else{const a=this.p-n;return Number(a)<this.bitLength?t>>a:this.zero}}shr(t,n){if(Number(n)<this.bitLength)return t>>n;{const a=this.p-n;if(Number(a)<this.bitLength){const i=t<<a&this.mask;return i>=this.p?i-this.p:i}else return 0}}land(t,n){return t&&n?this.one:this.zero}lor(t,n){return t||n?this.one:this.zero}lnot(t){return t?this.zero:this.one}sqrt_old(t){if(t==this.zero)return this.zero;if(this.pow(t,this.negone>>this.one)!=this.one)return null;let a=this.s,i=this.nqr_to_t,e=this.pow(t,this.t),l=this.pow(t,this.add(this.t,this.one)>>this.one);for(;e!=this.one;){let s=this.square(e),h=1;for(;s!=this.one;)h++,s=this.square(s);let d=i;for(let c=0;c<a-h-1;c++)d=this.square(d);a=h,i=this.square(d),e=this.mul(e,i),l=this.mul(l,d)}return l>this.p>>this.one&&(l=this.neg(l)),l}normalize(t,n){if(t=BigInt(t,n),t<0){let a=-t;return a>=this.p&&(a=a%this.p),this.p-a}else return t>=this.p?t%this.p:t}random(){const t=this.bitLength*2/8;let n=this.zero;for(let a=0;a<t;a++)n=(n<<BigInt(8))+BigInt(Go(1)[0]);return n%this.p}toString(t,n){n=n||10;let a;return t>this.half&&n==10?a="-"+(this.p-t).toString(n):a=t.toString(n),a}isZero(t){return t==this.zero}fromRng(t){let n;do{n=this.zero;for(let a=0;a<this.n64;a++)n+=t.nextU64()<<BigInt(64*a);n&=this.mask}while(n>=this.p);return n=n*this.Ri%this.p,n}fft(t){return this.FFT.fft(t)}ifft(t){return this.FFT.ifft(t)}toRprLE(t,n,a){Oa(t,n,a,this.n64*8)}toRprBE(t,n,a){So(t,n,a,this.n64*8)}toRprBEM(t,n,a){return this.toRprBE(t,n,this.mul(this.R,a))}toRprLEM(t,n,a){return this.toRprLE(t,n,this.mul(this.R,a))}fromRprLE(t,n){return Ua(t,n,this.n8)}fromRprBE(t,n){return xo(t,n,this.n8)}fromRprLEM(t,n){return this.mul(this.fromRprLE(t,n),this.Ri)}fromRprBEM(t,n){return this.mul(this.fromRprBE(t,n),this.Ri)}toObject(t){return t}}var Nn={};Nn.bigInt2BytesLE=function(t,n){const a=Array(n);let i=BigInt(t);for(let e=0;e<n;e++)a[e]=Number(i&0xFFn),i=i>>8n;return a};Nn.bigInt2U32LE=function(t,n){const a=Array(n);let i=BigInt(t);for(let e=0;e<n;e++)a[e]=Number(i&0xFFFFFFFFn),i=i>>32n;return a};Nn.isOcamNum=function(o){return!(!Array.isArray(o)||o.length!=3||typeof o[0]!="number"||typeof o[1]!="number"||!Array.isArray(o[2]))};var uc=function(t,n,a){const i=a||"int";if(t.modules[i])return i;t.modules[i]={};const e=n*2,l=n*8;function s(){const I=t.addFunction(i+"_copy");I.addParam("px","i32"),I.addParam("pr","i32");const _=I.getCodeBuilder();for(let b=0;b<n;b++)I.addCode(_.i64_store(_.getLocal("pr"),b*8,_.i64_load(_.getLocal("px"),b*8)))}function h(){const I=t.addFunction(i+"_zero");I.addParam("pr","i32");const _=I.getCodeBuilder();for(let b=0;b<n;b++)I.addCode(_.i64_store(_.getLocal("pr"),b*8,_.i64_const(0)))}function d(){const I=t.addFunction(i+"_one");I.addParam("pr","i32");const _=I.getCodeBuilder();I.addCode(_.i64_store(_.getLocal("pr"),0,_.i64_const(1)));for(let b=1;b<n;b++)I.addCode(_.i64_store(_.getLocal("pr"),b*8,_.i64_const(0)))}function c(){const I=t.addFunction(i+"_isZero");I.addParam("px","i32"),I.setReturnType("i32");const _=I.getCodeBuilder();function b($){return $==0?_.ret(_.i64_eqz(_.i64_load(_.getLocal("px")))):_.if(_.i64_eqz(_.i64_load(_.getLocal("px"),$*8)),b($-1),_.ret(_.i32_const(0)))}I.addCode(b(n-1)),I.addCode(_.ret(_.i32_const(0)))}function f(){const I=t.addFunction(i+"_eq");I.addParam("px","i32"),I.addParam("py","i32"),I.setReturnType("i32");const _=I.getCodeBuilder();function b($){return $==0?_.ret(_.i64_eq(_.i64_load(_.getLocal("px")),_.i64_load(_.getLocal("py")))):_.if(_.i64_eq(_.i64_load(_.getLocal("px"),$*8),_.i64_load(_.getLocal("py"),$*8)),b($-1),_.ret(_.i32_const(0)))}I.addCode(b(n-1)),I.addCode(_.ret(_.i32_const(0)))}function y(){const I=t.addFunction(i+"_gte");I.addParam("px","i32"),I.addParam("py","i32"),I.setReturnType("i32");const _=I.getCodeBuilder();function b($){return $==0?_.ret(_.i64_ge_u(_.i64_load(_.getLocal("px")),_.i64_load(_.getLocal("py")))):_.if(_.i64_lt_u(_.i64_load(_.getLocal("px"),$*8),_.i64_load(_.getLocal("py"),$*8)),_.ret(_.i32_const(0)),_.if(_.i64_gt_u(_.i64_load(_.getLocal("px"),$*8),_.i64_load(_.getLocal("py"),$*8)),_.ret(_.i32_const(1)),b($-1)))}I.addCode(b(n-1)),I.addCode(_.ret(_.i32_const(0)))}function L(){const I=t.addFunction(i+"_add");I.addParam("x","i32"),I.addParam("y","i32"),I.addParam("r","i32"),I.setReturnType("i32"),I.addLocal("c","i64");const _=I.getCodeBuilder();I.addCode(_.setLocal("c",_.i64_add(_.i64_load32_u(_.getLocal("x")),_.i64_load32_u(_.getLocal("y"))))),I.addCode(_.i64_store32(_.getLocal("r"),_.getLocal("c")));for(let b=1;b<e;b++)I.addCode(_.setLocal("c",_.i64_add(_.i64_add(_.i64_load32_u(_.getLocal("x"),4*b),_.i64_load32_u(_.getLocal("y"),4*b)),_.i64_shr_u(_.getLocal("c"),_.i64_const(32))))),I.addCode(_.i64_store32(_.getLocal("r"),b*4,_.getLocal("c")));I.addCode(_.i32_wrap_i64(_.i64_shr_u(_.getLocal("c"),_.i64_const(32))))}function v(){const I=t.addFunction(i+"_sub");I.addParam("x","i32"),I.addParam("y","i32"),I.addParam("r","i32"),I.setReturnType("i32"),I.addLocal("c","i64");const _=I.getCodeBuilder();I.addCode(_.setLocal("c",_.i64_sub(_.i64_load32_u(_.getLocal("x")),_.i64_load32_u(_.getLocal("y"))))),I.addCode(_.i64_store32(_.getLocal("r"),_.i64_and(_.getLocal("c"),_.i64_const("0xFFFFFFFF"))));for(let b=1;b<e;b++)I.addCode(_.setLocal("c",_.i64_add(_.i64_sub(_.i64_load32_u(_.getLocal("x"),4*b),_.i64_load32_u(_.getLocal("y"),4*b)),_.i64_shr_s(_.getLocal("c"),_.i64_const(32))))),I.addCode(_.i64_store32(_.getLocal("r"),b*4,_.i64_and(_.getLocal("c"),_.i64_const("0xFFFFFFFF"))));I.addCode(_.i32_wrap_i64(_.i64_shr_s(_.getLocal("c"),_.i64_const(32))))}function T(){const I=t.addFunction(i+"_mul");I.addParam("x","i32"),I.addParam("y","i32"),I.addParam("r","i32"),I.addLocal("c0","i64"),I.addLocal("c1","i64");for(let S=0;S<e;S++)I.addLocal("x"+S,"i64"),I.addLocal("y"+S,"i64");const _=I.getCodeBuilder(),b=[],$=[];function K(S,z){let q,Z;return b[S]?q=_.getLocal("x"+S):(q=_.teeLocal("x"+S,_.i64_load32_u(_.getLocal("x"),S*4)),b[S]=!0),$[z]?Z=_.getLocal("y"+z):(Z=_.teeLocal("y"+z,_.i64_load32_u(_.getLocal("y"),z*4)),$[z]=!0),_.i64_mul(q,Z)}let j="c0",M="c1";for(let S=0;S<e*2-1;S++){for(let z=Math.max(0,S-e+1);z<=S&&z<e;z++){const q=S-z;I.addCode(_.setLocal(j,_.i64_add(_.i64_and(_.getLocal(j),_.i64_const(4294967295)),K(z,q)))),I.addCode(_.setLocal(M,_.i64_add(_.getLocal(M),_.i64_shr_u(_.getLocal(j),_.i64_const(32)))))}I.addCode(_.i64_store32(_.getLocal("r"),S*4,_.getLocal(j))),[j,M]=[M,j],I.addCode(_.setLocal(M,_.i64_shr_u(_.getLocal(j),_.i64_const(32))))}I.addCode(_.i64_store32(_.getLocal("r"),e*4*2-4,_.getLocal(j)))}function B(){const I=t.addFunction(i+"_square");I.addParam("x","i32"),I.addParam("r","i32"),I.addLocal("c0","i64"),I.addLocal("c1","i64"),I.addLocal("c0_old","i64"),I.addLocal("c1_old","i64");for(let z=0;z<e;z++)I.addLocal("x"+z,"i64");const _=I.getCodeBuilder(),b=[];function $(z,q){let Z,Y;return b[z]?Z=_.getLocal("x"+z):(Z=_.teeLocal("x"+z,_.i64_load32_u(_.getLocal("x"),z*4)),b[z]=!0),b[q]?Y=_.getLocal("x"+q):(Y=_.teeLocal("x"+q,_.i64_load32_u(_.getLocal("x"),q*4)),b[q]=!0),_.i64_mul(Z,Y)}let K="c0",j="c1",M="c0_old",S="c1_old";for(let z=0;z<e*2-1;z++){I.addCode(_.setLocal(K,_.i64_const(0)),_.setLocal(j,_.i64_const(0)));for(let q=Math.max(0,z-e+1);q<z+1>>1&&q<e;q++){const Z=z-q;I.addCode(_.setLocal(K,_.i64_add(_.i64_and(_.getLocal(K),_.i64_const(4294967295)),$(q,Z)))),I.addCode(_.setLocal(j,_.i64_add(_.getLocal(j),_.i64_shr_u(_.getLocal(K),_.i64_const(32)))))}I.addCode(_.setLocal(K,_.i64_shl(_.i64_and(_.getLocal(K),_.i64_const(4294967295)),_.i64_const(1)))),I.addCode(_.setLocal(j,_.i64_add(_.i64_shl(_.getLocal(j),_.i64_const(1)),_.i64_shr_u(_.getLocal(K),_.i64_const(32))))),z%2==0&&(I.addCode(_.setLocal(K,_.i64_add(_.i64_and(_.getLocal(K),_.i64_const(4294967295)),$(z>>1,z>>1)))),I.addCode(_.setLocal(j,_.i64_add(_.getLocal(j),_.i64_shr_u(_.getLocal(K),_.i64_const(32)))))),z>0&&(I.addCode(_.setLocal(K,_.i64_add(_.i64_and(_.getLocal(K),_.i64_const(4294967295)),_.i64_and(_.getLocal(M),_.i64_const(4294967295))))),I.addCode(_.setLocal(j,_.i64_add(_.i64_add(_.getLocal(j),_.i64_shr_u(_.getLocal(K),_.i64_const(32))),_.getLocal(S))))),I.addCode(_.i64_store32(_.getLocal("r"),z*4,_.getLocal(K))),I.addCode(_.setLocal(M,_.getLocal(j)),_.setLocal(S,_.i64_shr_u(_.getLocal(M),_.i64_const(32))))}I.addCode(_.i64_store32(_.getLocal("r"),e*4*2-4,_.getLocal(M)))}function E(){const I=t.addFunction(i+"_squareOld");I.addParam("x","i32"),I.addParam("r","i32");const _=I.getCodeBuilder();I.addCode(_.call(i+"_mul",_.getLocal("x"),_.getLocal("x"),_.getLocal("r")))}function A(){const I=t.addFunction(i+"__mul1");I.addParam("px","i32"),I.addParam("y","i64"),I.addParam("pr","i32"),I.addLocal("c","i64");const _=I.getCodeBuilder();I.addCode(_.setLocal("c",_.i64_mul(_.i64_load32_u(_.getLocal("px"),0,0),_.getLocal("y")))),I.addCode(_.i64_store32(_.getLocal("pr"),0,0,_.getLocal("c")));for(let b=1;b<e;b++)I.addCode(_.setLocal("c",_.i64_add(_.i64_mul(_.i64_load32_u(_.getLocal("px"),4*b,0),_.getLocal("y")),_.i64_shr_u(_.getLocal("c"),_.i64_const(32))))),I.addCode(_.i64_store32(_.getLocal("pr"),b*4,0,_.getLocal("c")))}function G(){const I=t.addFunction(i+"__add1");I.addParam("x","i32"),I.addParam("y","i64"),I.addLocal("c","i64"),I.addLocal("px","i32");const _=I.getCodeBuilder();I.addCode(_.setLocal("px",_.getLocal("x"))),I.addCode(_.setLocal("c",_.i64_add(_.i64_load32_u(_.getLocal("px"),0,0),_.getLocal("y")))),I.addCode(_.i64_store32(_.getLocal("px"),0,0,_.getLocal("c"))),I.addCode(_.setLocal("c",_.i64_shr_u(_.getLocal("c"),_.i64_const(32)))),I.addCode(_.block(_.loop(_.br_if(1,_.i64_eqz(_.getLocal("c"))),_.setLocal("px",_.i32_add(_.getLocal("px"),_.i32_const(4))),_.setLocal("c",_.i64_add(_.i64_load32_u(_.getLocal("px"),0,0),_.getLocal("c"))),_.i64_store32(_.getLocal("px"),0,0,_.getLocal("c")),_.setLocal("c",_.i64_shr_u(_.getLocal("c"),_.i64_const(32))),_.br(0))))}function P(){A(),G();const I=t.addFunction(i+"_div");I.addParam("x","i32"),I.addParam("y","i32"),I.addParam("c","i32"),I.addParam("r","i32"),I.addLocal("rr","i32"),I.addLocal("cc","i32"),I.addLocal("eX","i32"),I.addLocal("eY","i32"),I.addLocal("sy","i64"),I.addLocal("sx","i64"),I.addLocal("ec","i32");const _=I.getCodeBuilder(),b=_.i32_const(t.alloc(l)),$=_.i32_const(t.alloc(l)),K=_.i32_const(t.alloc(l)),j=_.getLocal("cc"),M=_.getLocal("rr"),S=t.alloc(l*2),z=_.i32_const(S),q=_.i32_const(S+l);I.addCode(_.if(_.getLocal("c"),_.setLocal("cc",_.getLocal("c")),_.setLocal("cc",$))),I.addCode(_.if(_.getLocal("r"),_.setLocal("rr",_.getLocal("r")),_.setLocal("rr",K))),I.addCode(_.call(i+"_copy",_.getLocal("x"),M)),I.addCode(_.call(i+"_copy",_.getLocal("y"),b)),I.addCode(_.call(i+"_zero",j)),I.addCode(_.call(i+"_zero",z)),I.addCode(_.setLocal("eX",_.i32_const(l-1))),I.addCode(_.setLocal("eY",_.i32_const(l-1))),I.addCode(_.block(_.loop(_.br_if(1,_.i32_or(_.i32_load8_u(_.i32_add(b,_.getLocal("eY")),0,0),_.i32_eq(_.getLocal("eY"),_.i32_const(3)))),_.setLocal("eY",_.i32_sub(_.getLocal("eY"),_.i32_const(1))),_.br(0)))),I.addCode(_.setLocal("sy",_.i64_add(_.i64_load32_u(_.i32_sub(_.i32_add(b,_.getLocal("eY")),_.i32_const(3)),0,0),_.i64_const(1)))),I.addCode(_.if(_.i64_eq(_.getLocal("sy"),_.i64_const(1)),_.drop(_.i64_div_u(_.i64_const(0),_.i64_const(0))))),I.addCode(_.block(_.loop(_.block(_.loop(_.br_if(1,_.i32_or(_.i32_load8_u(_.i32_add(M,_.getLocal("eX")),0,0),_.i32_eq(_.getLocal("eX"),_.i32_const(7)))),_.setLocal("eX",_.i32_sub(_.getLocal("eX"),_.i32_const(1))),_.br(0))),_.setLocal("sx",_.i64_load(_.i32_sub(_.i32_add(M,_.getLocal("eX")),_.i32_const(7)),0,0)),_.setLocal("sx",_.i64_div_u(_.getLocal("sx"),_.getLocal("sy"))),_.setLocal("ec",_.i32_sub(_.i32_sub(_.getLocal("eX"),_.getLocal("eY")),_.i32_const(4))),_.block(_.loop(_.br_if(1,_.i32_and(_.i64_eqz(_.i64_and(_.getLocal("sx"),_.i64_const("0xFFFFFFFF00000000"))),_.i32_ge_s(_.getLocal("ec"),_.i32_const(0)))),_.setLocal("sx",_.i64_shr_u(_.getLocal("sx"),_.i64_const(8))),_.setLocal("ec",_.i32_add(_.getLocal("ec"),_.i32_const(1))),_.br(0))),_.if(_.i64_eqz(_.getLocal("sx")),[..._.br_if(2,_.i32_eqz(_.call(i+"_gte",M,b))),..._.setLocal("sx",_.i64_const(1)),..._.setLocal("ec",_.i32_const(0))]),_.call(i+"__mul1",b,_.getLocal("sx"),q),_.drop(_.call(i+"_sub",M,_.i32_sub(q,_.getLocal("ec")),M)),_.call(i+"__add1",_.i32_add(j,_.getLocal("ec")),_.getLocal("sx")),_.br(0))))}function U(){const I=t.addFunction(i+"_inverseMod");I.addParam("px","i32"),I.addParam("pm","i32"),I.addParam("pr","i32"),I.addLocal("t","i32"),I.addLocal("newt","i32"),I.addLocal("r","i32"),I.addLocal("qq","i32"),I.addLocal("qr","i32"),I.addLocal("newr","i32"),I.addLocal("swp","i32"),I.addLocal("x","i32"),I.addLocal("signt","i32"),I.addLocal("signnewt","i32"),I.addLocal("signx","i32");const _=I.getCodeBuilder(),b=_.i32_const(t.alloc(l)),$=_.i32_const(t.alloc(l)),K=_.i32_const(t.alloc(l)),j=_.i32_const(t.alloc(l)),M=_.i32_const(t.alloc(l)),S=_.i32_const(t.alloc(l)),z=_.i32_const(t.alloc(l*2)),q=_.i32_const(t.alloc(l));I.addCode(_.setLocal("t",b),_.call(i+"_zero",b),_.setLocal("signt",_.i32_const(0))),I.addCode(_.setLocal("r",$),_.call(i+"_copy",_.getLocal("pm"),$)),I.addCode(_.setLocal("newt",K),_.call(i+"_one",K),_.setLocal("signnewt",_.i32_const(0))),I.addCode(_.setLocal("newr",j),_.call(i+"_copy",_.getLocal("px"),j)),I.addCode(_.setLocal("qq",M)),I.addCode(_.setLocal("qr",S)),I.addCode(_.setLocal("x",q)),I.addCode(_.block(_.loop(_.br_if(1,_.call(i+"_isZero",_.getLocal("newr"))),_.call(i+"_div",_.getLocal("r"),_.getLocal("newr"),_.getLocal("qq"),_.getLocal("qr")),_.call(i+"_mul",_.getLocal("qq"),_.getLocal("newt"),z),_.if(_.getLocal("signt"),_.if(_.getLocal("signnewt"),_.if(_.call(i+"_gte",z,_.getLocal("t")),[..._.drop(_.call(i+"_sub",z,_.getLocal("t"),_.getLocal("x"))),..._.setLocal("signx",_.i32_const(0))],[..._.drop(_.call(i+"_sub",_.getLocal("t"),z,_.getLocal("x"))),..._.setLocal("signx",_.i32_const(1))]),[..._.drop(_.call(i+"_add",z,_.getLocal("t"),_.getLocal("x"))),..._.setLocal("signx",_.i32_const(1))]),_.if(_.getLocal("signnewt"),[..._.drop(_.call(i+"_add",z,_.getLocal("t"),_.getLocal("x"))),..._.setLocal("signx",_.i32_const(0))],_.if(_.call(i+"_gte",_.getLocal("t"),z),[..._.drop(_.call(i+"_sub",_.getLocal("t"),z,_.getLocal("x"))),..._.setLocal("signx",_.i32_const(0))],[..._.drop(_.call(i+"_sub",z,_.getLocal("t"),_.getLocal("x"))),..._.setLocal("signx",_.i32_const(1))]))),_.setLocal("swp",_.getLocal("t")),_.setLocal("t",_.getLocal("newt")),_.setLocal("newt",_.getLocal("x")),_.setLocal("x",_.getLocal("swp")),_.setLocal("signt",_.getLocal("signnewt")),_.setLocal("signnewt",_.getLocal("signx")),_.setLocal("swp",_.getLocal("r")),_.setLocal("r",_.getLocal("newr")),_.setLocal("newr",_.getLocal("qr")),_.setLocal("qr",_.getLocal("swp")),_.br(0)))),I.addCode(_.if(_.getLocal("signt"),_.drop(_.call(i+"_sub",_.getLocal("pm"),_.getLocal("t"),_.getLocal("pr"))),_.call(i+"_copy",_.getLocal("t"),_.getLocal("pr"))))}return s(),h(),c(),d(),f(),y(),L(),v(),T(),B(),E(),P(),U(),t.exportFunction(i+"_copy"),t.exportFunction(i+"_zero"),t.exportFunction(i+"_one"),t.exportFunction(i+"_isZero"),t.exportFunction(i+"_eq"),t.exportFunction(i+"_gte"),t.exportFunction(i+"_add"),t.exportFunction(i+"_sub"),t.exportFunction(i+"_mul"),t.exportFunction(i+"_square"),t.exportFunction(i+"_squareOld"),t.exportFunction(i+"_div"),t.exportFunction(i+"_inverseMod"),i},de=function(t,n,a,i,e,l,s){const h=t.addFunction(n);h.addParam("base","i32"),h.addParam("scalar","i32"),h.addParam("scalarLength","i32"),h.addParam("r","i32"),h.addLocal("i","i32"),h.addLocal("b","i32");const d=h.getCodeBuilder(),c=d.i32_const(t.alloc(a));h.addCode(d.if(d.i32_eqz(d.getLocal("scalarLength")),[...d.call(s,d.getLocal("r")),...d.ret([])])),h.addCode(d.call(l,d.getLocal("base"),c)),h.addCode(d.call(s,d.getLocal("r"))),h.addCode(d.setLocal("i",d.getLocal("scalarLength"))),h.addCode(d.block(d.loop(d.setLocal("i",d.i32_sub(d.getLocal("i"),d.i32_const(1))),d.setLocal("b",d.i32_load8_u(d.i32_add(d.getLocal("scalar"),d.getLocal("i")))),...f(),d.br_if(1,d.i32_eqz(d.getLocal("i"))),d.br(0))));function f(){const y=[];for(let L=0;L<8;L++)y.push(...d.call(e,d.getLocal("r"),d.getLocal("r")),...d.if(d.i32_ge_u(d.getLocal("b"),d.i32_const(128>>L)),[...d.setLocal("b",d.i32_sub(d.getLocal("b"),d.i32_const(128>>L))),...d.call(i,d.getLocal("r"),c,d.getLocal("r"))]));return y}},ue=fc;function fc(o,t){const n=o.modules[t].n64*8,a=o.addFunction(t+"_batchInverse");a.addParam("pIn","i32"),a.addParam("inStep","i32"),a.addParam("n","i32"),a.addParam("pOut","i32"),a.addParam("outStep","i32"),a.addLocal("itAux","i32"),a.addLocal("itIn","i32"),a.addLocal("itOut","i32"),a.addLocal("i","i32");const i=a.getCodeBuilder(),e=i.i32_const(o.alloc(n));a.addCode(i.setLocal("itAux",i.i32_load(i.i32_const(0))),i.i32_store(i.i32_const(0),i.i32_add(i.getLocal("itAux"),i.i32_mul(i.i32_add(i.getLocal("n"),i.i32_const(1)),i.i32_const(n))))),a.addCode(i.call(t+"_one",i.getLocal("itAux")),i.setLocal("itIn",i.getLocal("pIn")),i.setLocal("itAux",i.i32_add(i.getLocal("itAux"),i.i32_const(n))),i.setLocal("i",i.i32_const(0)),i.block(i.loop(i.br_if(1,i.i32_eq(i.getLocal("i"),i.getLocal("n"))),i.if(i.call(t+"_isZero",i.getLocal("itIn")),i.call(t+"_copy",i.i32_sub(i.getLocal("itAux"),i.i32_const(n)),i.getLocal("itAux")),i.call(t+"_mul",i.getLocal("itIn"),i.i32_sub(i.getLocal("itAux"),i.i32_const(n)),i.getLocal("itAux"))),i.setLocal("itIn",i.i32_add(i.getLocal("itIn"),i.getLocal("inStep"))),i.setLocal("itAux",i.i32_add(i.getLocal("itAux"),i.i32_const(n))),i.setLocal("i",i.i32_add(i.getLocal("i"),i.i32_const(1))),i.br(0))),i.setLocal("itIn",i.i32_sub(i.getLocal("itIn"),i.getLocal("inStep"))),i.setLocal("itAux",i.i32_sub(i.getLocal("itAux"),i.i32_const(n))),i.setLocal("itOut",i.i32_add(i.getLocal("pOut"),i.i32_mul(i.i32_sub(i.getLocal("n"),i.i32_const(1)),i.getLocal("outStep")))),i.call(t+"_inverse",i.getLocal("itAux"),i.getLocal("itAux")),i.block(i.loop(i.br_if(1,i.i32_eqz(i.getLocal("i"))),i.if(i.call(t+"_isZero",i.getLocal("itIn")),[...i.call(t+"_copy",i.getLocal("itAux"),i.i32_sub(i.getLocal("itAux"),i.i32_const(n))),...i.call(t+"_zero",i.getLocal("itOut"))],[...i.call(t+"_copy",i.i32_sub(i.getLocal("itAux"),i.i32_const(n)),e),...i.call(t+"_mul",i.getLocal("itAux"),i.getLocal("itIn"),i.i32_sub(i.getLocal("itAux"),i.i32_const(n))),...i.call(t+"_mul",i.getLocal("itAux"),e,i.getLocal("itOut"))]),i.setLocal("itIn",i.i32_sub(i.getLocal("itIn"),i.getLocal("inStep"))),i.setLocal("itOut",i.i32_sub(i.getLocal("itOut"),i.getLocal("outStep"))),i.setLocal("itAux",i.i32_sub(i.getLocal("itAux"),i.i32_const(n))),i.setLocal("i",i.i32_sub(i.getLocal("i"),i.i32_const(1))),i.br(0)))),a.addCode(i.i32_store(i.i32_const(0),i.getLocal("itAux")))}var Po=hc;function hc(o,t,n,a,i,e){typeof e>"u"&&(a<i?e=!0:e=!1);const l=o.addFunction(t);l.addParam("pIn","i32"),l.addParam("n","i32"),l.addParam("pOut","i32"),l.addLocal("i","i32"),l.addLocal("itIn","i32"),l.addLocal("itOut","i32");const s=l.getCodeBuilder();e?l.addCode(s.setLocal("itIn",s.i32_add(s.getLocal("pIn"),s.i32_mul(s.i32_sub(s.getLocal("n"),s.i32_const(1)),s.i32_const(a)))),s.setLocal("itOut",s.i32_add(s.getLocal("pOut"),s.i32_mul(s.i32_sub(s.getLocal("n"),s.i32_const(1)),s.i32_const(i)))),s.setLocal("i",s.i32_const(0)),s.block(s.loop(s.br_if(1,s.i32_eq(s.getLocal("i"),s.getLocal("n"))),s.call(n,s.getLocal("itIn"),s.getLocal("itOut")),s.setLocal("itIn",s.i32_sub(s.getLocal("itIn"),s.i32_const(a))),s.setLocal("itOut",s.i32_sub(s.getLocal("itOut"),s.i32_const(i))),s.setLocal("i",s.i32_add(s.getLocal("i"),s.i32_const(1))),s.br(0)))):l.addCode(s.setLocal("itIn",s.getLocal("pIn")),s.setLocal("itOut",s.getLocal("pOut")),s.setLocal("i",s.i32_const(0)),s.block(s.loop(s.br_if(1,s.i32_eq(s.getLocal("i"),s.getLocal("n"))),s.call(n,s.getLocal("itIn"),s.getLocal("itOut")),s.setLocal("itIn",s.i32_add(s.getLocal("itIn"),s.i32_const(a))),s.setLocal("itOut",s.i32_add(s.getLocal("itOut"),s.i32_const(i))),s.setLocal("i",s.i32_add(s.getLocal("i"),s.i32_const(1))),s.br(0))))}var _c=gc;function gc(o,t,n,a,i,e){typeof e>"u"&&(a<i?e=!0:e=!1);const l=o.addFunction(t);l.addParam("pIn1","i32"),l.addParam("pIn2","i32"),l.addParam("n","i32"),l.addParam("pOut","i32"),l.addLocal("i","i32"),l.addLocal("itIn1","i32"),l.addLocal("itIn2","i32"),l.addLocal("itOut","i32");const s=l.getCodeBuilder();e?l.addCode(s.setLocal("itIn1",s.i32_add(s.getLocal("pIn1"),s.i32_mul(s.i32_sub(s.getLocal("n"),s.i32_const(1)),s.i32_const(a)))),s.setLocal("itIn2",s.i32_add(s.getLocal("pIn2"),s.i32_mul(s.i32_sub(s.getLocal("n"),s.i32_const(1)),s.i32_const(a)))),s.setLocal("itOut",s.i32_add(s.getLocal("pOut"),s.i32_mul(s.i32_sub(s.getLocal("n"),s.i32_const(1)),s.i32_const(i)))),s.setLocal("i",s.i32_const(0)),s.block(s.loop(s.br_if(1,s.i32_eq(s.getLocal("i"),s.getLocal("n"))),s.call(n,s.getLocal("itIn1"),s.getLocal("itIn2"),s.getLocal("itOut")),s.setLocal("itIn1",s.i32_sub(s.getLocal("itIn1"),s.i32_const(a))),s.setLocal("itIn2",s.i32_sub(s.getLocal("itIn2"),s.i32_const(a))),s.setLocal("itOut",s.i32_sub(s.getLocal("itOut"),s.i32_const(i))),s.setLocal("i",s.i32_add(s.getLocal("i"),s.i32_const(1))),s.br(0)))):l.addCode(s.setLocal("itIn1",s.getLocal("pIn1")),s.setLocal("itIn2",s.getLocal("pIn2")),s.setLocal("itOut",s.getLocal("pOut")),s.setLocal("i",s.i32_const(0)),s.block(s.loop(s.br_if(1,s.i32_eq(s.getLocal("i"),s.getLocal("n"))),s.call(n,s.getLocal("itIn1"),s.getLocal("itIn2"),s.getLocal("itOut")),s.setLocal("itIn1",s.i32_add(s.getLocal("itIn1"),s.i32_const(a))),s.setLocal("itIn2",s.i32_add(s.getLocal("itIn2"),s.i32_const(a))),s.setLocal("itOut",s.i32_add(s.getLocal("itOut"),s.i32_const(i))),s.setLocal("i",s.i32_add(s.getLocal("i"),s.i32_const(1))),s.br(0))))}var un={};function To(o,t){return o===t?0:o>t?1:-1}function fe(o){return o*o}function Oo(o){return o%2n!==0n}function he(o){return o%2n===0n}function ei(o){return o<0n}function pc(o){return o>0n}function Uo(o){return ei(o)?o.toString(2).length-1:o.toString(2).length}function qa(o){return o<0n?-o:o}function ua(o){return qa(o)===1n}function Mo(o,t){for(var n=0n,a=1n,i=t,e=qa(o),l,s,h;e!==0n;)l=i/e,s=n,h=i,n=a,i=e,a=s-l*a,e=h-l*e;if(!ua(i))throw new Error(o.toString()+" and "+t.toString()+" are not co-prime");return To(n,0n)===-1&&(n=n+t),ei(o)?-n:n}function zo(o,t,n){if(n===0n)throw new Error("Cannot take modPow with modulus 0");var a=1n,i=o%n;for(ei(t)&&(t=t*-1n,i=Mo(i,n));pc(t);){if(i===0n)return 0n;Oo(t)&&(a=a*i%n),t=t/2n,i=fe(i)%n}return a}function wc(o,t){return o=o>=0n?o:-o,t=t>=0n?t:-t,o===t?0:o>t?1:-1}function Be(o,t){return t===0n?!1:ua(t)?!0:wc(t,2n)===0?he(o):o%t===0n}function Lc(o){var t=qa(o);if(ua(t))return!1;if(t===2n||t===3n||t===5n)return!0;if(he(t)||Be(t,3n)||Be(t,5n))return!1;if(t<49n)return!0}function mc(o){return o-1n}function Se(o,t){for(var n=mc(o),a=n,i=0,e,l,s;he(a);)a=a/2n,i++;t:for(l=0;l<t.length;l++)if(!(o<t[l])&&(s=zo(BigInt(t[l]),a,o),!(ua(s)||s===n))){for(e=i-1;e!=0;e--){if(s=fe(s)%o,ua(s))return!1;if(s===n)continue t}return!1}return!0}function bc(o){var t=Lc(o);if(t!==void 0)return t;var n=qa(o),a=Uo(n);if(a<=64)return Se(n,[2,3,5,7,11,13,17,19,23,29,31,37]);for(var i=Math.log(2)*Number(a),e=Math.ceil(i),l=[],s=0;s<e;s++)l.push(BigInt(s+2));return Se(n,l)}un.bitLength=Uo;un.isOdd=Oo;un.isNegative=ei;un.abs=qa;un.isUnit=ua;un.compare=To;un.modInv=Mo;un.modPow=zo;un.isPrime=bc;un.square=fe;const Ac=uc,xn=Nn,yc=de,Cc=ue,ui=Po,fi=_c,{bitLength:Ic,modInv:hi,modPow:xe,isPrime:ve,isOdd:Ec,square:Fc}=un;var _e=function(t,n,a,i){const e=BigInt(n),l=Math.floor((Ic(e-1n)-1)/64)+1,s=l*2,h=l*8,d=a||"f1m";if(t.modules[d])return d;const c=Ac(t,l,i),f=t.alloc(h,xn.bigInt2BytesLE(e,h)),y=t.alloc(xn.bigInt2BytesLE(Fc(1n<<BigInt(l*64))%e,h)),L=t.alloc(xn.bigInt2BytesLE((1n<<BigInt(l*64))%e,h)),v=t.alloc(xn.bigInt2BytesLE(0n,h)),T=e-1n,B=T>>1n,E=t.alloc(h,xn.bigInt2BytesLE(B,h)),A=B+1n,G=t.alloc(h,xn.bigInt2BytesLE(A,h));t.modules[d]={pq:f,pR2:y,n64:l,q:e,pOne:L,pZero:v,pePlusOne:G};function P(){const F=t.addFunction(d+"_one");F.addParam("pr","i32");const p=F.getCodeBuilder();F.addCode(p.call(c+"_copy",p.i32_const(L),p.getLocal("pr")))}function U(){const F=t.addFunction(d+"_add");F.addParam("x","i32"),F.addParam("y","i32"),F.addParam("r","i32");const p=F.getCodeBuilder();F.addCode(p.if(p.call(c+"_add",p.getLocal("x"),p.getLocal("y"),p.getLocal("r")),p.drop(p.call(c+"_sub",p.getLocal("r"),p.i32_const(f),p.getLocal("r"))),p.if(p.call(c+"_gte",p.getLocal("r"),p.i32_const(f)),p.drop(p.call(c+"_sub",p.getLocal("r"),p.i32_const(f),p.getLocal("r"))))))}function I(){const F=t.addFunction(d+"_sub");F.addParam("x","i32"),F.addParam("y","i32"),F.addParam("r","i32");const p=F.getCodeBuilder();F.addCode(p.if(p.call(c+"_sub",p.getLocal("x"),p.getLocal("y"),p.getLocal("r")),p.drop(p.call(c+"_add",p.getLocal("r"),p.i32_const(f),p.getLocal("r")))))}function _(){const F=t.addFunction(d+"_neg");F.addParam("x","i32"),F.addParam("r","i32");const p=F.getCodeBuilder();F.addCode(p.call(d+"_sub",p.i32_const(v),p.getLocal("x"),p.getLocal("r")))}function b(){const F=t.addFunction(d+"_isNegative");F.addParam("x","i32"),F.setReturnType("i32");const p=F.getCodeBuilder(),O=p.i32_const(t.alloc(h));F.addCode(p.call(d+"_fromMontgomery",p.getLocal("x"),O),p.call(c+"_gte",O,p.i32_const(G)))}function $(){const F=t.addFunction(d+"_sign");F.addParam("x","i32"),F.setReturnType("i32");const p=F.getCodeBuilder(),O=p.i32_const(t.alloc(h));F.addCode(p.if(p.call(c+"_isZero",p.getLocal("x")),p.ret(p.i32_const(0))),p.call(d+"_fromMontgomery",p.getLocal("x"),O),p.if(p.call(c+"_gte",O,p.i32_const(G)),p.ret(p.i32_const(-1))),p.ret(p.i32_const(1)))}function K(){const F=t.alloc(s*s*8),p=t.addFunction(d+"_mReduct");p.addParam("t","i32"),p.addParam("r","i32"),p.addLocal("np32","i64"),p.addLocal("c","i64"),p.addLocal("m","i64");const O=p.getCodeBuilder(),R=Number(0x100000000n-hi(e,0x100000000n));p.addCode(O.setLocal("np32",O.i64_const(R)));for(let N=0;N<s;N++){p.addCode(O.setLocal("c",O.i64_const(0))),p.addCode(O.setLocal("m",O.i64_and(O.i64_mul(O.i64_load32_u(O.getLocal("t"),N*4),O.getLocal("np32")),O.i64_const("0xFFFFFFFF"))));for(let H=0;H<s;H++)p.addCode(O.setLocal("c",O.i64_add(O.i64_add(O.i64_load32_u(O.getLocal("t"),(N+H)*4),O.i64_shr_u(O.getLocal("c"),O.i64_const(32))),O.i64_mul(O.i64_load32_u(O.i32_const(f),H*4),O.getLocal("m"))))),p.addCode(O.i64_store32(O.getLocal("t"),(N+H)*4,O.getLocal("c")));p.addCode(O.i64_store32(O.i32_const(F),N*4,O.i64_shr_u(O.getLocal("c"),O.i64_const(32))))}p.addCode(O.call(d+"_add",O.i32_const(F),O.i32_add(O.getLocal("t"),O.i32_const(s*4)),O.getLocal("r")))}function j(){const F=t.addFunction(d+"_mul");F.addParam("x","i32"),F.addParam("y","i32"),F.addParam("r","i32"),F.addLocal("c0","i64"),F.addLocal("c1","i64"),F.addLocal("np32","i64");for(let st=0;st<s;st++)F.addLocal("x"+st,"i64"),F.addLocal("y"+st,"i64"),F.addLocal("m"+st,"i64"),F.addLocal("q"+st,"i64");const p=F.getCodeBuilder(),O=Number(0x100000000n-hi(e,0x100000000n));F.addCode(p.setLocal("np32",p.i64_const(O)));const R=[],N=[],H=[];function lt(st,ct){let Lt,At;return R[st]?Lt=p.getLocal("x"+st):(Lt=p.teeLocal("x"+st,p.i64_load32_u(p.getLocal("x"),st*4)),R[st]=!0),N[ct]?At=p.getLocal("y"+ct):(At=p.teeLocal("y"+ct,p.i64_load32_u(p.getLocal("y"),ct*4)),N[ct]=!0),p.i64_mul(Lt,At)}function ht(st,ct){let Lt,At;return H[st]?Lt=p.getLocal("q"+st):(Lt=p.teeLocal("q"+st,p.i64_load32_u(p.i32_const(0),f+st*4)),H[st]=!0),At=p.getLocal("m"+ct),p.i64_mul(Lt,At)}let pt="c0",ut="c1";for(let st=0;st<s*2-1;st++){for(let ct=Math.max(0,st-s+1);ct<=st&&ct<s;ct++){const Lt=st-ct;F.addCode(p.setLocal(pt,p.i64_add(p.i64_and(p.getLocal(pt),p.i64_const(4294967295)),lt(ct,Lt)))),F.addCode(p.setLocal(ut,p.i64_add(p.getLocal(ut),p.i64_shr_u(p.getLocal(pt),p.i64_const(32)))))}for(let ct=Math.max(1,st-s+1);ct<=st&&ct<s;ct++){const Lt=st-ct;F.addCode(p.setLocal(pt,p.i64_add(p.i64_and(p.getLocal(pt),p.i64_const(4294967295)),ht(ct,Lt)))),F.addCode(p.setLocal(ut,p.i64_add(p.getLocal(ut),p.i64_shr_u(p.getLocal(pt),p.i64_const(32)))))}st<s&&(F.addCode(p.setLocal("m"+st,p.i64_and(p.i64_mul(p.i64_and(p.getLocal(pt),p.i64_const(4294967295)),p.getLocal("np32")),p.i64_const("0xFFFFFFFF")))),F.addCode(p.setLocal(pt,p.i64_add(p.i64_and(p.getLocal(pt),p.i64_const(4294967295)),ht(0,st)))),F.addCode(p.setLocal(ut,p.i64_add(p.getLocal(ut),p.i64_shr_u(p.getLocal(pt),p.i64_const(32)))))),st>=s&&F.addCode(p.i64_store32(p.getLocal("r"),(st-s)*4,p.getLocal(pt))),[pt,ut]=[ut,pt],F.addCode(p.setLocal(ut,p.i64_shr_u(p.getLocal(pt),p.i64_const(32))))}F.addCode(p.i64_store32(p.getLocal("r"),s*4-4,p.getLocal(pt))),F.addCode(p.if(p.i32_wrap_i64(p.getLocal(ut)),p.drop(p.call(c+"_sub",p.getLocal("r"),p.i32_const(f),p.getLocal("r"))),p.if(p.call(c+"_gte",p.getLocal("r"),p.i32_const(f)),p.drop(p.call(c+"_sub",p.getLocal("r"),p.i32_const(f),p.getLocal("r"))))))}function M(){const F=t.addFunction(d+"_square");F.addParam("x","i32"),F.addParam("r","i32"),F.addLocal("c0","i64"),F.addLocal("c1","i64"),F.addLocal("c0_old","i64"),F.addLocal("c1_old","i64"),F.addLocal("np32","i64");for(let ct=0;ct<s;ct++)F.addLocal("x"+ct,"i64"),F.addLocal("m"+ct,"i64"),F.addLocal("q"+ct,"i64");const p=F.getCodeBuilder(),O=Number(0x100000000n-hi(e,0x100000000n));F.addCode(p.setLocal("np32",p.i64_const(O)));const R=[],N=[];function H(ct,Lt){let At,Bt;return R[ct]?At=p.getLocal("x"+ct):(At=p.teeLocal("x"+ct,p.i64_load32_u(p.getLocal("x"),ct*4)),R[ct]=!0),R[Lt]?Bt=p.getLocal("x"+Lt):(Bt=p.teeLocal("x"+Lt,p.i64_load32_u(p.getLocal("x"),Lt*4)),R[Lt]=!0),p.i64_mul(At,Bt)}function lt(ct,Lt){let At,Bt;return N[ct]?At=p.getLocal("q"+ct):(At=p.teeLocal("q"+ct,p.i64_load32_u(p.i32_const(0),f+ct*4)),N[ct]=!0),Bt=p.getLocal("m"+Lt),p.i64_mul(At,Bt)}let ht="c0",pt="c1",ut="c0_old",st="c1_old";for(let ct=0;ct<s*2-1;ct++){F.addCode(p.setLocal(ht,p.i64_const(0)),p.setLocal(pt,p.i64_const(0)));for(let Lt=Math.max(0,ct-s+1);Lt<ct+1>>1&&Lt<s;Lt++){const At=ct-Lt;F.addCode(p.setLocal(ht,p.i64_add(p.i64_and(p.getLocal(ht),p.i64_const(4294967295)),H(Lt,At)))),F.addCode(p.setLocal(pt,p.i64_add(p.getLocal(pt),p.i64_shr_u(p.getLocal(ht),p.i64_const(32)))))}F.addCode(p.setLocal(ht,p.i64_shl(p.i64_and(p.getLocal(ht),p.i64_const(4294967295)),p.i64_const(1)))),F.addCode(p.setLocal(pt,p.i64_add(p.i64_shl(p.getLocal(pt),p.i64_const(1)),p.i64_shr_u(p.getLocal(ht),p.i64_const(32))))),ct%2==0&&(F.addCode(p.setLocal(ht,p.i64_add(p.i64_and(p.getLocal(ht),p.i64_const(4294967295)),H(ct>>1,ct>>1)))),F.addCode(p.setLocal(pt,p.i64_add(p.getLocal(pt),p.i64_shr_u(p.getLocal(ht),p.i64_const(32)))))),ct>0&&(F.addCode(p.setLocal(ht,p.i64_add(p.i64_and(p.getLocal(ht),p.i64_const(4294967295)),p.i64_and(p.getLocal(ut),p.i64_const(4294967295))))),F.addCode(p.setLocal(pt,p.i64_add(p.i64_add(p.getLocal(pt),p.i64_shr_u(p.getLocal(ht),p.i64_const(32))),p.getLocal(st)))));for(let Lt=Math.max(1,ct-s+1);Lt<=ct&&Lt<s;Lt++){const At=ct-Lt;F.addCode(p.setLocal(ht,p.i64_add(p.i64_and(p.getLocal(ht),p.i64_const(4294967295)),lt(Lt,At)))),F.addCode(p.setLocal(pt,p.i64_add(p.getLocal(pt),p.i64_shr_u(p.getLocal(ht),p.i64_const(32)))))}ct<s&&(F.addCode(p.setLocal("m"+ct,p.i64_and(p.i64_mul(p.i64_and(p.getLocal(ht),p.i64_const(4294967295)),p.getLocal("np32")),p.i64_const("0xFFFFFFFF")))),F.addCode(p.setLocal(ht,p.i64_add(p.i64_and(p.getLocal(ht),p.i64_const(4294967295)),lt(0,ct)))),F.addCode(p.setLocal(pt,p.i64_add(p.getLocal(pt),p.i64_shr_u(p.getLocal(ht),p.i64_const(32)))))),ct>=s&&F.addCode(p.i64_store32(p.getLocal("r"),(ct-s)*4,p.getLocal(ht))),F.addCode(p.setLocal(ut,p.getLocal(pt)),p.setLocal(st,p.i64_shr_u(p.getLocal(ut),p.i64_const(32))))}F.addCode(p.i64_store32(p.getLocal("r"),s*4-4,p.getLocal(ut))),F.addCode(p.if(p.i32_wrap_i64(p.getLocal(st)),p.drop(p.call(c+"_sub",p.getLocal("r"),p.i32_const(f),p.getLocal("r"))),p.if(p.call(c+"_gte",p.getLocal("r"),p.i32_const(f)),p.drop(p.call(c+"_sub",p.getLocal("r"),p.i32_const(f),p.getLocal("r"))))))}function S(){const F=t.addFunction(d+"_squareOld");F.addParam("x","i32"),F.addParam("r","i32");const p=F.getCodeBuilder();F.addCode(p.call(d+"_mul",p.getLocal("x"),p.getLocal("x"),p.getLocal("r")))}function z(){const F=t.addFunction(d+"_toMontgomery");F.addParam("x","i32"),F.addParam("r","i32");const p=F.getCodeBuilder();F.addCode(p.call(d+"_mul",p.getLocal("x"),p.i32_const(y),p.getLocal("r")))}function q(){const F=t.alloc(h*2),p=t.addFunction(d+"_fromMontgomery");p.addParam("x","i32"),p.addParam("r","i32");const O=p.getCodeBuilder();p.addCode(O.call(c+"_copy",O.getLocal("x"),O.i32_const(F))),p.addCode(O.call(c+"_zero",O.i32_const(F+h))),p.addCode(O.call(d+"_mReduct",O.i32_const(F),O.getLocal("r")))}function Z(){const F=t.addFunction(d+"_inverse");F.addParam("x","i32"),F.addParam("r","i32");const p=F.getCodeBuilder();F.addCode(p.call(d+"_fromMontgomery",p.getLocal("x"),p.getLocal("r"))),F.addCode(p.call(c+"_inverseMod",p.getLocal("r"),p.i32_const(f),p.getLocal("r"))),F.addCode(p.call(d+"_toMontgomery",p.getLocal("r"),p.getLocal("r")))}let Y=2n;if(ve(e))for(;xe(Y,B,e)!==T;)Y=Y+1n;let V=0,nt=T;for(;!Ec(nt)&&nt!==0n;)V++,nt=nt>>1n;const Q=t.alloc(h,xn.bigInt2BytesLE(nt,h)),it=xe(Y,nt,e),X=t.alloc(xn.bigInt2BytesLE((it<<BigInt(l*64))%e,h)),k=nt+1n>>1n,J=t.alloc(h,xn.bigInt2BytesLE(k,h));function m(){const F=t.addFunction(d+"_sqrt");F.addParam("n","i32"),F.addParam("r","i32"),F.addLocal("m","i32"),F.addLocal("i","i32"),F.addLocal("j","i32");const p=F.getCodeBuilder(),O=p.i32_const(L),R=p.i32_const(t.alloc(h)),N=p.i32_const(t.alloc(h)),H=p.i32_const(t.alloc(h)),lt=p.i32_const(t.alloc(h)),ht=p.i32_const(t.alloc(h));F.addCode(p.if(p.call(d+"_isZero",p.getLocal("n")),p.ret(p.call(d+"_zero",p.getLocal("r")))),p.setLocal("m",p.i32_const(V)),p.call(d+"_copy",p.i32_const(X),R),p.call(d+"_exp",p.getLocal("n"),p.i32_const(Q),p.i32_const(h),N),p.call(d+"_exp",p.getLocal("n"),p.i32_const(J),p.i32_const(h),H),p.block(p.loop(p.br_if(1,p.call(d+"_eq",N,O)),p.call(d+"_square",N,lt),p.setLocal("i",p.i32_const(1)),p.block(p.loop(p.br_if(1,p.call(d+"_eq",lt,O)),p.call(d+"_square",lt,lt),p.setLocal("i",p.i32_add(p.getLocal("i"),p.i32_const(1))),p.br(0))),p.call(d+"_copy",R,ht),p.setLocal("j",p.i32_sub(p.i32_sub(p.getLocal("m"),p.getLocal("i")),p.i32_const(1))),p.block(p.loop(p.br_if(1,p.i32_eqz(p.getLocal("j"))),p.call(d+"_square",ht,ht),p.setLocal("j",p.i32_sub(p.getLocal("j"),p.i32_const(1))),p.br(0))),p.setLocal("m",p.getLocal("i")),p.call(d+"_square",ht,R),p.call(d+"_mul",N,R,N),p.call(d+"_mul",H,ht,H),p.br(0))),p.if(p.call(d+"_isNegative",H),p.call(d+"_neg",H,p.getLocal("r")),p.call(d+"_copy",H,p.getLocal("r"))))}function r(){const F=t.addFunction(d+"_isSquare");F.addParam("n","i32"),F.setReturnType("i32");const p=F.getCodeBuilder(),O=p.i32_const(L),R=p.i32_const(t.alloc(h));F.addCode(p.if(p.call(d+"_isZero",p.getLocal("n")),p.ret(p.i32_const(1))),p.call(d+"_exp",p.getLocal("n"),p.i32_const(E),p.i32_const(h),R),p.call(d+"_eq",R,O))}function C(){const F=t.addFunction(d+"_load");F.addParam("scalar","i32"),F.addParam("scalarLen","i32"),F.addParam("r","i32"),F.addLocal("p","i32"),F.addLocal("l","i32"),F.addLocal("i","i32"),F.addLocal("j","i32");const p=F.getCodeBuilder(),O=p.i32_const(t.alloc(h)),R=t.alloc(h),N=p.i32_const(R);F.addCode(p.call(c+"_zero",p.getLocal("r")),p.setLocal("i",p.i32_const(h)),p.setLocal("p",p.getLocal("scalar")),p.block(p.loop(p.br_if(1,p.i32_gt_u(p.getLocal("i"),p.getLocal("scalarLen"))),p.if(p.i32_eq(p.getLocal("i"),p.i32_const(h)),p.call(d+"_one",O),p.call(d+"_mul",O,p.i32_const(y),O)),p.call(d+"_mul",p.getLocal("p"),O,N),p.call(d+"_add",p.getLocal("r"),N,p.getLocal("r")),p.setLocal("p",p.i32_add(p.getLocal("p"),p.i32_const(h))),p.setLocal("i",p.i32_add(p.getLocal("i"),p.i32_const(h))),p.br(0))),p.setLocal("l",p.i32_rem_u(p.getLocal("scalarLen"),p.i32_const(h))),p.if(p.i32_eqz(p.getLocal("l")),p.ret([])),p.call(c+"_zero",N),p.setLocal("j",p.i32_const(0)),p.block(p.loop(p.br_if(1,p.i32_eq(p.getLocal("j"),p.getLocal("l"))),p.i32_store8(p.getLocal("j"),R,p.i32_load8_u(p.getLocal("p"))),p.setLocal("p",p.i32_add(p.getLocal("p"),p.i32_const(1))),p.setLocal("j",p.i32_add(p.getLocal("j"),p.i32_const(1))),p.br(0))),p.if(p.i32_eq(p.getLocal("i"),p.i32_const(h)),p.call(d+"_one",O),p.call(d+"_mul",O,p.i32_const(y),O)),p.call(d+"_mul",N,O,N),p.call(d+"_add",p.getLocal("r"),N,p.getLocal("r")))}function u(){const F=t.addFunction(d+"_timesScalar");F.addParam("x","i32"),F.addParam("scalar","i32"),F.addParam("scalarLen","i32"),F.addParam("r","i32");const p=F.getCodeBuilder(),O=p.i32_const(t.alloc(h));F.addCode(p.call(d+"_load",p.getLocal("scalar"),p.getLocal("scalarLen"),O),p.call(d+"_toMontgomery",O,O),p.call(d+"_mul",p.getLocal("x"),O,p.getLocal("r")))}function x(){const F=t.addFunction(d+"_isOne");F.addParam("x","i32"),F.setReturnType("i32");const p=F.getCodeBuilder();F.addCode(p.ret(p.call(c+"_eq",p.getLocal("x"),p.i32_const(L))))}return t.exportFunction(c+"_copy",d+"_copy"),t.exportFunction(c+"_zero",d+"_zero"),t.exportFunction(c+"_isZero",d+"_isZero"),t.exportFunction(c+"_eq",d+"_eq"),x(),U(),I(),_(),K(),j(),M(),S(),z(),q(),b(),$(),Z(),P(),C(),u(),Cc(t,d),ui(t,d+"_batchToMontgomery",d+"_toMontgomery",h,h),ui(t,d+"_batchFromMontgomery",d+"_fromMontgomery",h,h),ui(t,d+"_batchNeg",d+"_neg",h,h),fi(t,d+"_batchAdd",d+"_add",h,h),fi(t,d+"_batchSub",d+"_sub",h,h),fi(t,d+"_batchMul",d+"_mul",h,h),t.exportFunction(d+"_add"),t.exportFunction(d+"_sub"),t.exportFunction(d+"_neg"),t.exportFunction(d+"_isNegative"),t.exportFunction(d+"_isOne"),t.exportFunction(d+"_sign"),t.exportFunction(d+"_mReduct"),t.exportFunction(d+"_mul"),t.exportFunction(d+"_square"),t.exportFunction(d+"_squareOld"),t.exportFunction(d+"_fromMontgomery"),t.exportFunction(d+"_toMontgomery"),t.exportFunction(d+"_inverse"),t.exportFunction(d+"_one"),t.exportFunction(d+"_load"),t.exportFunction(d+"_timesScalar"),yc(t,d+"_exp",h,d+"_mul",d+"_square",c+"_copy",d+"_one"),t.exportFunction(d+"_exp"),t.exportFunction(d+"_batchInverse"),ve(e)&&(m(),r(),t.exportFunction(d+"_sqrt"),t.exportFunction(d+"_isSquare")),t.exportFunction(d+"_batchToMontgomery"),t.exportFunction(d+"_batchFromMontgomery"),d};const Bc=_e,{bitLength:Sc}=un;var qo=function(t,n,a,i,e){const l=BigInt(n),s=Math.floor((Sc(l-1n)-1)/64)+1,h=s*8,d=a||"f1";if(t.modules[d])return d;t.modules[d]={n64:s};const c=e||"int",f=Bc(t,l,i,c),y=t.modules[f].pR2,L=t.modules[f].pq,v=t.modules[f].pePlusOne;function T(){const G=t.alloc(h),P=t.addFunction(d+"_mul");P.addParam("x","i32"),P.addParam("y","i32"),P.addParam("r","i32");const U=P.getCodeBuilder();P.addCode(U.call(f+"_mul",U.getLocal("x"),U.getLocal("y"),U.i32_const(G))),P.addCode(U.call(f+"_mul",U.i32_const(G),U.i32_const(y),U.getLocal("r")))}function B(){const G=t.addFunction(d+"_square");G.addParam("x","i32"),G.addParam("r","i32");const P=G.getCodeBuilder();G.addCode(P.call(d+"_mul",P.getLocal("x"),P.getLocal("x"),P.getLocal("r")))}function E(){const G=t.addFunction(d+"_inverse");G.addParam("x","i32"),G.addParam("r","i32");const P=G.getCodeBuilder();G.addCode(P.call(c+"_inverseMod",P.getLocal("x"),P.i32_const(L),P.getLocal("r")))}function A(){const G=t.addFunction(d+"_isNegative");G.addParam("x","i32"),G.setReturnType("i32");const P=G.getCodeBuilder();G.addCode(P.call(c+"_gte",P.getLocal("x"),P.i32_const(v)))}return T(),B(),E(),A(),t.exportFunction(f+"_add",d+"_add"),t.exportFunction(f+"_sub",d+"_sub"),t.exportFunction(f+"_neg",d+"_neg"),t.exportFunction(d+"_mul"),t.exportFunction(d+"_square"),t.exportFunction(d+"_inverse"),t.exportFunction(d+"_isNegative"),t.exportFunction(f+"_copy",d+"_copy"),t.exportFunction(f+"_zero",d+"_zero"),t.exportFunction(f+"_one",d+"_one"),t.exportFunction(f+"_isZero",d+"_isZero"),t.exportFunction(f+"_eq",d+"_eq"),d};const xc=de,vc=ue,_i=Nn;var Qo=function(t,n,a,i){if(t.modules[a])return a;const e=t.modules[i].n64*8,l=t.modules[i].q;t.modules[a]={n64:t.modules[i].n64*2};function s(){const M=t.addFunction(a+"_add");M.addParam("x","i32"),M.addParam("y","i32"),M.addParam("r","i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e)),Z=S.getLocal("y"),Y=S.i32_add(S.getLocal("y"),S.i32_const(e)),V=S.getLocal("r"),nt=S.i32_add(S.getLocal("r"),S.i32_const(e));M.addCode(S.call(i+"_add",z,Z,V),S.call(i+"_add",q,Y,nt))}function h(){const M=t.addFunction(a+"_timesScalar");M.addParam("x","i32"),M.addParam("scalar","i32"),M.addParam("scalarLen","i32"),M.addParam("r","i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e)),Z=S.getLocal("r"),Y=S.i32_add(S.getLocal("r"),S.i32_const(e));M.addCode(S.call(i+"_timesScalar",z,S.getLocal("scalar"),S.getLocal("scalarLen"),Z),S.call(i+"_timesScalar",q,S.getLocal("scalar"),S.getLocal("scalarLen"),Y))}function d(){const M=t.addFunction(a+"_sub");M.addParam("x","i32"),M.addParam("y","i32"),M.addParam("r","i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e)),Z=S.getLocal("y"),Y=S.i32_add(S.getLocal("y"),S.i32_const(e)),V=S.getLocal("r"),nt=S.i32_add(S.getLocal("r"),S.i32_const(e));M.addCode(S.call(i+"_sub",z,Z,V),S.call(i+"_sub",q,Y,nt))}function c(){const M=t.addFunction(a+"_neg");M.addParam("x","i32"),M.addParam("r","i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e)),Z=S.getLocal("r"),Y=S.i32_add(S.getLocal("r"),S.i32_const(e));M.addCode(S.call(i+"_neg",z,Z),S.call(i+"_neg",q,Y))}function f(){const M=t.addFunction(a+"_conjugate");M.addParam("x","i32"),M.addParam("r","i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e)),Z=S.getLocal("r"),Y=S.i32_add(S.getLocal("r"),S.i32_const(e));M.addCode(S.call(i+"_copy",z,Z),S.call(i+"_neg",q,Y))}function y(){const M=t.addFunction(a+"_isNegative");M.addParam("x","i32"),M.setReturnType("i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e));M.addCode(S.if(S.call(i+"_isZero",q),S.ret(S.call(i+"_isNegative",z))),S.ret(S.call(i+"_isNegative",q)))}function L(){const M=t.addFunction(a+"_mul");M.addParam("x","i32"),M.addParam("y","i32"),M.addParam("r","i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e)),Z=S.getLocal("y"),Y=S.i32_add(S.getLocal("y"),S.i32_const(e)),V=S.getLocal("r"),nt=S.i32_add(S.getLocal("r"),S.i32_const(e)),Q=S.i32_const(t.alloc(e)),it=S.i32_const(t.alloc(e)),X=S.i32_const(t.alloc(e)),k=S.i32_const(t.alloc(e));M.addCode(S.call(i+"_mul",z,Z,Q),S.call(i+"_mul",q,Y,it),S.call(i+"_add",z,q,X),S.call(i+"_add",Z,Y,k),S.call(i+"_mul",X,k,X),S.call(n,it,V),S.call(i+"_add",Q,V,V),S.call(i+"_add",Q,it,nt),S.call(i+"_sub",X,nt,nt))}function v(){const M=t.addFunction(a+"_mul1");M.addParam("x","i32"),M.addParam("y","i32"),M.addParam("r","i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e)),Z=S.getLocal("y"),Y=S.getLocal("r"),V=S.i32_add(S.getLocal("r"),S.i32_const(e));M.addCode(S.call(i+"_mul",z,Z,Y),S.call(i+"_mul",q,Z,V))}function T(){const M=t.addFunction(a+"_square");M.addParam("x","i32"),M.addParam("r","i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e)),Z=S.getLocal("r"),Y=S.i32_add(S.getLocal("r"),S.i32_const(e)),V=S.i32_const(t.alloc(e)),nt=S.i32_const(t.alloc(e)),Q=S.i32_const(t.alloc(e)),it=S.i32_const(t.alloc(e));M.addCode(S.call(i+"_mul",z,q,V),S.call(i+"_add",z,q,nt),S.call(n,q,Q),S.call(i+"_add",z,Q,Q),S.call(n,V,it),S.call(i+"_add",it,V,it),S.call(i+"_mul",nt,Q,Z),S.call(i+"_sub",Z,it,Z),S.call(i+"_add",V,V,Y))}function B(){const M=t.addFunction(a+"_toMontgomery");M.addParam("x","i32"),M.addParam("r","i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e)),Z=S.getLocal("r"),Y=S.i32_add(S.getLocal("r"),S.i32_const(e));M.addCode(S.call(i+"_toMontgomery",z,Z),S.call(i+"_toMontgomery",q,Y))}function E(){const M=t.addFunction(a+"_fromMontgomery");M.addParam("x","i32"),M.addParam("r","i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e)),Z=S.getLocal("r"),Y=S.i32_add(S.getLocal("r"),S.i32_const(e));M.addCode(S.call(i+"_fromMontgomery",z,Z),S.call(i+"_fromMontgomery",q,Y))}function A(){const M=t.addFunction(a+"_copy");M.addParam("x","i32"),M.addParam("r","i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e)),Z=S.getLocal("r"),Y=S.i32_add(S.getLocal("r"),S.i32_const(e));M.addCode(S.call(i+"_copy",z,Z),S.call(i+"_copy",q,Y))}function G(){const M=t.addFunction(a+"_zero");M.addParam("x","i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e));M.addCode(S.call(i+"_zero",z),S.call(i+"_zero",q))}function P(){const M=t.addFunction(a+"_one");M.addParam("x","i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e));M.addCode(S.call(i+"_one",z),S.call(i+"_zero",q))}function U(){const M=t.addFunction(a+"_eq");M.addParam("x","i32"),M.addParam("y","i32"),M.setReturnType("i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e)),Z=S.getLocal("y"),Y=S.i32_add(S.getLocal("y"),S.i32_const(e));M.addCode(S.i32_and(S.call(i+"_eq",z,Z),S.call(i+"_eq",q,Y)))}function I(){const M=t.addFunction(a+"_isZero");M.addParam("x","i32"),M.setReturnType("i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e));M.addCode(S.i32_and(S.call(i+"_isZero",z),S.call(i+"_isZero",q)))}function _(){const M=t.addFunction(a+"_inverse");M.addParam("x","i32"),M.addParam("r","i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e)),Z=S.getLocal("r"),Y=S.i32_add(S.getLocal("r"),S.i32_const(e)),V=S.i32_const(t.alloc(e)),nt=S.i32_const(t.alloc(e)),Q=S.i32_const(t.alloc(e)),it=S.i32_const(t.alloc(e));M.addCode(S.call(i+"_square",z,V),S.call(i+"_square",q,nt),S.call(n,nt,Q),S.call(i+"_sub",V,Q,Q),S.call(i+"_inverse",Q,it),S.call(i+"_mul",z,it,Z),S.call(i+"_mul",q,it,Y),S.call(i+"_neg",Y,Y))}function b(){const M=t.addFunction(a+"_sign");M.addParam("x","i32"),M.addLocal("s","i32"),M.setReturnType("i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e));M.addCode(S.setLocal("s",S.call(i+"_sign",q)),S.if(S.getLocal("s"),S.ret(S.getLocal("s"))),S.ret(S.call(i+"_sign",z)))}function $(){const M=t.addFunction(a+"_isOne");M.addParam("x","i32"),M.setReturnType("i32");const S=M.getCodeBuilder(),z=S.getLocal("x"),q=S.i32_add(S.getLocal("x"),S.i32_const(e));M.addCode(S.ret(S.i32_and(S.call(i+"_isOne",z),S.call(i+"_isZero",q))))}function K(){const M=t.addFunction(a+"_sqrt");M.addParam("a","i32"),M.addParam("pr","i32");const S=M.getCodeBuilder(),z=S.i32_const(t.alloc(_i.bigInt2BytesLE((BigInt(l||0)-3n)/4n,e))),q=S.i32_const(t.alloc(_i.bigInt2BytesLE((BigInt(l||0)-1n)/2n,e))),Z=S.getLocal("a"),Y=S.i32_const(t.alloc(e*2)),V=S.i32_const(t.alloc(e*2)),nt=S.i32_const(t.alloc(e*2)),Q=t.alloc(e*2),it=S.i32_const(Q),X=S.i32_const(Q),k=S.i32_const(Q+e),J=S.i32_const(t.alloc(e*2)),m=S.i32_const(t.alloc(e*2));M.addCode(S.call(a+"_one",it),S.call(a+"_neg",it,it),S.call(a+"_exp",Z,z,S.i32_const(e),Y),S.call(a+"_square",Y,V),S.call(a+"_mul",Z,V,V),S.call(a+"_conjugate",V,nt),S.call(a+"_mul",nt,V,nt),S.if(S.call(a+"_eq",nt,it),S.unreachable()),S.call(a+"_mul",Y,Z,J),S.if(S.call(a+"_eq",V,it),[...S.call(i+"_zero",X),...S.call(i+"_one",k),...S.call(a+"_mul",it,J,S.getLocal("pr"))],[...S.call(a+"_one",m),...S.call(a+"_add",m,V,m),...S.call(a+"_exp",m,q,S.i32_const(e),m),...S.call(a+"_mul",m,J,S.getLocal("pr"))]))}function j(){const M=t.addFunction(a+"_isSquare");M.addParam("a","i32"),M.setReturnType("i32");const S=M.getCodeBuilder(),z=S.i32_const(t.alloc(_i.bigInt2BytesLE((BigInt(l||0)-3n)/4n,e))),q=S.getLocal("a"),Z=S.i32_const(t.alloc(e*2)),Y=S.i32_const(t.alloc(e*2)),V=S.i32_const(t.alloc(e*2)),nt=t.alloc(e*2),Q=S.i32_const(nt);M.addCode(S.call(a+"_one",Q),S.call(a+"_neg",Q,Q),S.call(a+"_exp",q,z,S.i32_const(e),Z),S.call(a+"_square",Z,Y),S.call(a+"_mul",q,Y,Y),S.call(a+"_conjugate",Y,V),S.call(a+"_mul",V,Y,V),S.if(S.call(a+"_eq",V,Q),S.ret(S.i32_const(0))),S.ret(S.i32_const(1)))}return I(),$(),G(),P(),A(),L(),v(),T(),s(),d(),c(),f(),B(),E(),U(),_(),h(),b(),y(),t.exportFunction(a+"_isZero"),t.exportFunction(a+"_isOne"),t.exportFunction(a+"_zero"),t.exportFunction(a+"_one"),t.exportFunction(a+"_copy"),t.exportFunction(a+"_mul"),t.exportFunction(a+"_mul1"),t.exportFunction(a+"_square"),t.exportFunction(a+"_add"),t.exportFunction(a+"_sub"),t.exportFunction(a+"_neg"),t.exportFunction(a+"_sign"),t.exportFunction(a+"_conjugate"),t.exportFunction(a+"_fromMontgomery"),t.exportFunction(a+"_toMontgomery"),t.exportFunction(a+"_eq"),t.exportFunction(a+"_inverse"),vc(t,a),xc(t,a+"_exp",e*2,a+"_mul",a+"_square",a+"_copy",a+"_one"),K(),j(),t.exportFunction(a+"_exp"),t.exportFunction(a+"_timesScalar"),t.exportFunction(a+"_batchInverse"),t.exportFunction(a+"_sqrt"),t.exportFunction(a+"_isSquare"),t.exportFunction(a+"_isNegative"),a};const Gc=de,Pc=ue;var Ro=function(t,n,a,i){if(t.modules[a])return a;const e=t.modules[i].n64*8;t.modules[a]={n64:t.modules[i].n64*3};function l(){const _=t.addFunction(a+"_add");_.addParam("x","i32"),_.addParam("y","i32"),_.addParam("r","i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(2*e)),M=b.getLocal("y"),S=b.i32_add(b.getLocal("y"),b.i32_const(e)),z=b.i32_add(b.getLocal("y"),b.i32_const(2*e)),q=b.getLocal("r"),Z=b.i32_add(b.getLocal("r"),b.i32_const(e)),Y=b.i32_add(b.getLocal("r"),b.i32_const(2*e));_.addCode(b.call(i+"_add",$,M,q),b.call(i+"_add",K,S,Z),b.call(i+"_add",j,z,Y))}function s(){const _=t.addFunction(a+"_timesScalar");_.addParam("x","i32"),_.addParam("scalar","i32"),_.addParam("scalarLen","i32"),_.addParam("r","i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(2*e)),M=b.getLocal("r"),S=b.i32_add(b.getLocal("r"),b.i32_const(e)),z=b.i32_add(b.getLocal("r"),b.i32_const(2*e));_.addCode(b.call(i+"_timesScalar",$,b.getLocal("scalar"),b.getLocal("scalarLen"),M),b.call(i+"_timesScalar",K,b.getLocal("scalar"),b.getLocal("scalarLen"),S),b.call(i+"_timesScalar",j,b.getLocal("scalar"),b.getLocal("scalarLen"),z))}function h(){const _=t.addFunction(a+"_sub");_.addParam("x","i32"),_.addParam("y","i32"),_.addParam("r","i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(2*e)),M=b.getLocal("y"),S=b.i32_add(b.getLocal("y"),b.i32_const(e)),z=b.i32_add(b.getLocal("y"),b.i32_const(2*e)),q=b.getLocal("r"),Z=b.i32_add(b.getLocal("r"),b.i32_const(e)),Y=b.i32_add(b.getLocal("r"),b.i32_const(2*e));_.addCode(b.call(i+"_sub",$,M,q),b.call(i+"_sub",K,S,Z),b.call(i+"_sub",j,z,Y))}function d(){const _=t.addFunction(a+"_neg");_.addParam("x","i32"),_.addParam("r","i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(2*e)),M=b.getLocal("r"),S=b.i32_add(b.getLocal("r"),b.i32_const(e)),z=b.i32_add(b.getLocal("r"),b.i32_const(2*e));_.addCode(b.call(i+"_neg",$,M),b.call(i+"_neg",K,S),b.call(i+"_neg",j,z))}function c(){const _=t.addFunction(a+"_isNegative");_.addParam("x","i32"),_.setReturnType("i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(2*e));_.addCode(b.if(b.call(i+"_isZero",j),b.if(b.call(i+"_isZero",K),b.ret(b.call(i+"_isNegative",$)),b.ret(b.call(i+"_isNegative",K)))),b.ret(b.call(i+"_isNegative",j)))}function f(){const _=t.addFunction(a+"_mul");_.addParam("x","i32"),_.addParam("y","i32"),_.addParam("r","i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(2*e)),M=b.getLocal("y"),S=b.i32_add(b.getLocal("y"),b.i32_const(e)),z=b.i32_add(b.getLocal("y"),b.i32_const(2*e)),q=b.getLocal("r"),Z=b.i32_add(b.getLocal("r"),b.i32_const(e)),Y=b.i32_add(b.getLocal("r"),b.i32_const(2*e)),V=b.i32_const(t.alloc(e)),nt=b.i32_const(t.alloc(e)),Q=b.i32_const(t.alloc(e)),it=b.i32_const(t.alloc(e)),X=b.i32_const(t.alloc(e)),k=b.i32_const(t.alloc(e)),J=b.i32_const(t.alloc(e)),m=b.i32_const(t.alloc(e)),r=b.i32_const(t.alloc(e)),C=b.i32_const(t.alloc(e)),u=b.i32_const(t.alloc(e)),x=b.i32_const(t.alloc(e)),F=b.i32_const(t.alloc(e));_.addCode(b.call(i+"_mul",$,M,V),b.call(i+"_mul",K,S,nt),b.call(i+"_mul",j,z,Q),b.call(i+"_add",$,K,it),b.call(i+"_add",M,S,X),b.call(i+"_add",$,j,k),b.call(i+"_add",M,z,J),b.call(i+"_add",K,j,m),b.call(i+"_add",S,z,r),b.call(i+"_add",V,nt,C),b.call(i+"_add",V,Q,u),b.call(i+"_add",nt,Q,x),b.call(i+"_mul",m,r,q),b.call(i+"_sub",q,x,q),b.call(n,q,q),b.call(i+"_add",V,q,q),b.call(i+"_mul",it,X,Z),b.call(i+"_sub",Z,C,Z),b.call(n,Q,F),b.call(i+"_add",Z,F,Z),b.call(i+"_mul",k,J,Y),b.call(i+"_sub",Y,u,Y),b.call(i+"_add",Y,nt,Y))}function y(){const _=t.addFunction(a+"_square");_.addParam("x","i32"),_.addParam("r","i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(2*e)),M=b.getLocal("r"),S=b.i32_add(b.getLocal("r"),b.i32_const(e)),z=b.i32_add(b.getLocal("r"),b.i32_const(2*e)),q=b.i32_const(t.alloc(e)),Z=b.i32_const(t.alloc(e)),Y=b.i32_const(t.alloc(e)),V=b.i32_const(t.alloc(e)),nt=b.i32_const(t.alloc(e)),Q=b.i32_const(t.alloc(e)),it=b.i32_const(t.alloc(e));_.addCode(b.call(i+"_square",$,q),b.call(i+"_mul",$,K,Z),b.call(i+"_add",Z,Z,Y),b.call(i+"_sub",$,K,V),b.call(i+"_add",V,j,V),b.call(i+"_square",V,V),b.call(i+"_mul",K,j,nt),b.call(i+"_add",nt,nt,Q),b.call(i+"_square",j,it),b.call(n,Q,M),b.call(i+"_add",q,M,M),b.call(n,it,S),b.call(i+"_add",Y,S,S),b.call(i+"_add",q,it,z),b.call(i+"_sub",Q,z,z),b.call(i+"_add",V,z,z),b.call(i+"_add",Y,z,z))}function L(){const _=t.addFunction(a+"_toMontgomery");_.addParam("x","i32"),_.addParam("r","i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(2*e)),M=b.getLocal("r"),S=b.i32_add(b.getLocal("r"),b.i32_const(e)),z=b.i32_add(b.getLocal("r"),b.i32_const(2*e));_.addCode(b.call(i+"_toMontgomery",$,M),b.call(i+"_toMontgomery",K,S),b.call(i+"_toMontgomery",j,z))}function v(){const _=t.addFunction(a+"_fromMontgomery");_.addParam("x","i32"),_.addParam("r","i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(2*e)),M=b.getLocal("r"),S=b.i32_add(b.getLocal("r"),b.i32_const(e)),z=b.i32_add(b.getLocal("r"),b.i32_const(2*e));_.addCode(b.call(i+"_fromMontgomery",$,M),b.call(i+"_fromMontgomery",K,S),b.call(i+"_fromMontgomery",j,z))}function T(){const _=t.addFunction(a+"_copy");_.addParam("x","i32"),_.addParam("r","i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(2*e)),M=b.getLocal("r"),S=b.i32_add(b.getLocal("r"),b.i32_const(e)),z=b.i32_add(b.getLocal("r"),b.i32_const(2*e));_.addCode(b.call(i+"_copy",$,M),b.call(i+"_copy",K,S),b.call(i+"_copy",j,z))}function B(){const _=t.addFunction(a+"_zero");_.addParam("x","i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(2*e));_.addCode(b.call(i+"_zero",$),b.call(i+"_zero",K),b.call(i+"_zero",j))}function E(){const _=t.addFunction(a+"_one");_.addParam("x","i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(2*e));_.addCode(b.call(i+"_one",$),b.call(i+"_zero",K),b.call(i+"_zero",j))}function A(){const _=t.addFunction(a+"_eq");_.addParam("x","i32"),_.addParam("y","i32"),_.setReturnType("i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(2*e)),M=b.getLocal("y"),S=b.i32_add(b.getLocal("y"),b.i32_const(e)),z=b.i32_add(b.getLocal("y"),b.i32_const(2*e));_.addCode(b.i32_and(b.i32_and(b.call(i+"_eq",$,M),b.call(i+"_eq",K,S)),b.call(i+"_eq",j,z)))}function G(){const _=t.addFunction(a+"_isZero");_.addParam("x","i32"),_.setReturnType("i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(2*e));_.addCode(b.i32_and(b.i32_and(b.call(i+"_isZero",$),b.call(i+"_isZero",K)),b.call(i+"_isZero",j)))}function P(){const _=t.addFunction(a+"_inverse");_.addParam("x","i32"),_.addParam("r","i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(2*e)),M=b.getLocal("r"),S=b.i32_add(b.getLocal("r"),b.i32_const(e)),z=b.i32_add(b.getLocal("r"),b.i32_const(2*e)),q=b.i32_const(t.alloc(e)),Z=b.i32_const(t.alloc(e)),Y=b.i32_const(t.alloc(e)),V=b.i32_const(t.alloc(e)),nt=b.i32_const(t.alloc(e)),Q=b.i32_const(t.alloc(e)),it=b.i32_const(t.alloc(e)),X=b.i32_const(t.alloc(e)),k=b.i32_const(t.alloc(e)),J=b.i32_const(t.alloc(e)),m=b.i32_const(t.alloc(e));_.addCode(b.call(i+"_square",$,q),b.call(i+"_square",K,Z),b.call(i+"_square",j,Y),b.call(i+"_mul",$,K,V),b.call(i+"_mul",$,j,nt),b.call(i+"_mul",K,j,Q),b.call(n,Q,it),b.call(i+"_sub",q,it,it),b.call(n,Y,X),b.call(i+"_sub",X,V,X),b.call(i+"_sub",Z,nt,k),b.call(i+"_mul",j,X,J),b.call(i+"_mul",K,k,m),b.call(i+"_add",J,m,J),b.call(n,J,J),b.call(i+"_mul",$,it,m),b.call(i+"_add",m,J,J),b.call(i+"_inverse",J,J),b.call(i+"_mul",J,it,M),b.call(i+"_mul",J,X,S),b.call(i+"_mul",J,k,z))}function U(){const _=t.addFunction(a+"_sign");_.addParam("x","i32"),_.addLocal("s","i32"),_.setReturnType("i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(2*e));_.addCode(b.setLocal("s",b.call(i+"_sign",j)),b.if(b.getLocal("s"),b.ret(b.getLocal("s"))),b.setLocal("s",b.call(i+"_sign",K)),b.if(b.getLocal("s"),b.ret(b.getLocal("s"))),b.ret(b.call(i+"_sign",$)))}function I(){const _=t.addFunction(a+"_isOne");_.addParam("x","i32"),_.setReturnType("i32");const b=_.getCodeBuilder(),$=b.getLocal("x"),K=b.i32_add(b.getLocal("x"),b.i32_const(e)),j=b.i32_add(b.getLocal("x"),b.i32_const(e*2));_.addCode(b.ret(b.i32_and(b.i32_and(b.call(i+"_isOne",$),b.call(i+"_isZero",K)),b.call(i+"_isZero",j))))}return G(),I(),B(),E(),T(),f(),y(),l(),h(),d(),U(),L(),v(),A(),P(),s(),c(),t.exportFunction(a+"_isZero"),t.exportFunction(a+"_isOne"),t.exportFunction(a+"_zero"),t.exportFunction(a+"_one"),t.exportFunction(a+"_copy"),t.exportFunction(a+"_mul"),t.exportFunction(a+"_square"),t.exportFunction(a+"_add"),t.exportFunction(a+"_sub"),t.exportFunction(a+"_neg"),t.exportFunction(a+"_sign"),t.exportFunction(a+"_fromMontgomery"),t.exportFunction(a+"_toMontgomery"),t.exportFunction(a+"_eq"),t.exportFunction(a+"_inverse"),Pc(t,a),Gc(t,a+"_exp",e*3,a+"_mul",a+"_square",a+"_copy",a+"_one"),t.exportFunction(a+"_exp"),t.exportFunction(a+"_timesScalar"),t.exportFunction(a+"_batchInverse"),t.exportFunction(a+"_isNegative"),a},Tc=function(t,n,a,i,e,l,s,h){const d=t.addFunction(n);d.addParam("base","i32"),d.addParam("scalar","i32"),d.addParam("scalarLength","i32"),d.addParam("r","i32"),d.addLocal("old0","i32"),d.addLocal("nbits","i32"),d.addLocal("i","i32"),d.addLocal("last","i32"),d.addLocal("cur","i32"),d.addLocal("carry","i32"),d.addLocal("p","i32");const c=d.getCodeBuilder(),f=c.i32_const(t.alloc(a));function y(v){return c.i32_and(c.i32_shr_u(c.i32_load(c.i32_add(c.getLocal("scalar"),c.i32_and(c.i32_shr_u(v,c.i32_const(3)),c.i32_const(4294967292)))),c.i32_and(v,c.i32_const(31))),c.i32_const(1))}function L(v){return[...c.i32_store8(c.getLocal("p"),c.i32_const(v)),...c.setLocal("p",c.i32_add(c.getLocal("p"),c.i32_const(1)))]}d.addCode(c.if(c.i32_eqz(c.getLocal("scalarLength")),[...c.call(h,c.getLocal("r")),...c.ret([])]),c.setLocal("nbits",c.i32_shl(c.getLocal("scalarLength"),c.i32_const(3))),c.setLocal("old0",c.i32_load(c.i32_const(0))),c.setLocal("p",c.getLocal("old0")),c.i32_store(c.i32_const(0),c.i32_and(c.i32_add(c.i32_add(c.getLocal("old0"),c.i32_const(32)),c.getLocal("nbits")),c.i32_const(4294967288))),c.setLocal("i",c.i32_const(1)),c.setLocal("last",y(c.i32_const(0))),c.setLocal("carry",c.i32_const(0)),c.block(c.loop(c.br_if(1,c.i32_eq(c.getLocal("i"),c.getLocal("nbits"))),c.setLocal("cur",y(c.getLocal("i"))),c.if(c.getLocal("last"),c.if(c.getLocal("cur"),c.if(c.getLocal("carry"),[...c.setLocal("last",c.i32_const(0)),...c.setLocal("carry",c.i32_const(1)),...L(1)],[...c.setLocal("last",c.i32_const(0)),...c.setLocal("carry",c.i32_const(1)),...L(255)]),c.if(c.getLocal("carry"),[...c.setLocal("last",c.i32_const(0)),...c.setLocal("carry",c.i32_const(1)),...L(255)],[...c.setLocal("last",c.i32_const(0)),...c.setLocal("carry",c.i32_const(0)),...L(1)])),c.if(c.getLocal("cur"),c.if(c.getLocal("carry"),[...c.setLocal("last",c.i32_const(0)),...c.setLocal("carry",c.i32_const(1)),...L(0)],[...c.setLocal("last",c.i32_const(1)),...c.setLocal("carry",c.i32_const(0)),...L(0)]),c.if(c.getLocal("carry"),[...c.setLocal("last",c.i32_const(1)),...c.setLocal("carry",c.i32_const(0)),...L(0)],[...c.setLocal("last",c.i32_const(0)),...c.setLocal("carry",c.i32_const(0)),...L(0)]))),c.setLocal("i",c.i32_add(c.getLocal("i"),c.i32_const(1))),c.br(0))),c.if(c.getLocal("last"),c.if(c.getLocal("carry"),[...L(255),...L(0),...L(1)],[...L(1)]),c.if(c.getLocal("carry"),[...L(0),...L(1)])),c.setLocal("p",c.i32_sub(c.getLocal("p"),c.i32_const(1))),c.call(s,c.getLocal("base"),f),c.call(h,c.getLocal("r")),c.block(c.loop(c.call(e,c.getLocal("r"),c.getLocal("r")),c.setLocal("cur",c.i32_load8_u(c.getLocal("p"))),c.if(c.getLocal("cur"),c.if(c.i32_eq(c.getLocal("cur"),c.i32_const(1)),c.call(i,c.getLocal("r"),f,c.getLocal("r")),c.call(l,c.getLocal("r"),f,c.getLocal("r")))),c.br_if(1,c.i32_eq(c.getLocal("old0"),c.getLocal("p"))),c.setLocal("p",c.i32_sub(c.getLocal("p"),c.i32_const(1))),c.br(0))),c.i32_store(c.i32_const(0),c.getLocal("old0")))},Oc=function(t,n,a,i,e){const s=t.modules[n].n64*8;function h(){const y=t.addFunction(a+"_getChunk");y.addParam("pScalar","i32"),y.addParam("scalarSize","i32"),y.addParam("startBit","i32"),y.addParam("chunkSize","i32"),y.addLocal("bitsToEnd","i32"),y.addLocal("mask","i32"),y.setReturnType("i32");const L=y.getCodeBuilder();y.addCode(L.setLocal("bitsToEnd",L.i32_sub(L.i32_mul(L.getLocal("scalarSize"),L.i32_const(8)),L.getLocal("startBit"))),L.if(L.i32_gt_s(L.getLocal("chunkSize"),L.getLocal("bitsToEnd")),L.setLocal("mask",L.i32_sub(L.i32_shl(L.i32_const(1),L.getLocal("bitsToEnd")),L.i32_const(1))),L.setLocal("mask",L.i32_sub(L.i32_shl(L.i32_const(1),L.getLocal("chunkSize")),L.i32_const(1)))),L.i32_and(L.i32_shr_u(L.i32_load(L.i32_add(L.getLocal("pScalar"),L.i32_shr_u(L.getLocal("startBit"),L.i32_const(3))),0,0),L.i32_and(L.getLocal("startBit"),L.i32_const(7))),L.getLocal("mask")))}function d(){const y=t.addFunction(a+"_chunk");y.addParam("pBases","i32"),y.addParam("pScalars","i32"),y.addParam("scalarSize","i32"),y.addParam("n","i32"),y.addParam("startBit","i32"),y.addParam("chunkSize","i32"),y.addParam("pr","i32"),y.addLocal("nChunks","i32"),y.addLocal("itScalar","i32"),y.addLocal("endScalar","i32"),y.addLocal("itBase","i32"),y.addLocal("i","i32"),y.addLocal("j","i32"),y.addLocal("nTable","i32"),y.addLocal("pTable","i32"),y.addLocal("idx","i32"),y.addLocal("pIdxTable","i32");const L=y.getCodeBuilder();y.addCode(L.if(L.i32_eqz(L.getLocal("n")),[...L.call(n+"_zero",L.getLocal("pr")),...L.ret([])]),L.setLocal("nTable",L.i32_shl(L.i32_const(1),L.getLocal("chunkSize"))),L.setLocal("pTable",L.i32_load(L.i32_const(0))),L.i32_store(L.i32_const(0),L.i32_add(L.getLocal("pTable"),L.i32_mul(L.getLocal("nTable"),L.i32_const(s)))),L.setLocal("j",L.i32_const(0)),L.block(L.loop(L.br_if(1,L.i32_eq(L.getLocal("j"),L.getLocal("nTable"))),L.call(n+"_zero",L.i32_add(L.getLocal("pTable"),L.i32_mul(L.getLocal("j"),L.i32_const(s)))),L.setLocal("j",L.i32_add(L.getLocal("j"),L.i32_const(1))),L.br(0))),L.setLocal("itBase",L.getLocal("pBases")),L.setLocal("itScalar",L.getLocal("pScalars")),L.setLocal("endScalar",L.i32_add(L.getLocal("pScalars"),L.i32_mul(L.getLocal("n"),L.getLocal("scalarSize")))),L.block(L.loop(L.br_if(1,L.i32_eq(L.getLocal("itScalar"),L.getLocal("endScalar"))),L.setLocal("idx",L.call(a+"_getChunk",L.getLocal("itScalar"),L.getLocal("scalarSize"),L.getLocal("startBit"),L.getLocal("chunkSize"))),L.if(L.getLocal("idx"),[...L.setLocal("pIdxTable",L.i32_add(L.getLocal("pTable"),L.i32_mul(L.i32_sub(L.getLocal("idx"),L.i32_const(1)),L.i32_const(s)))),...L.call(i,L.getLocal("pIdxTable"),L.getLocal("itBase"),L.getLocal("pIdxTable"))]),L.setLocal("itScalar",L.i32_add(L.getLocal("itScalar"),L.getLocal("scalarSize"))),L.setLocal("itBase",L.i32_add(L.getLocal("itBase"),L.i32_const(e))),L.br(0))),L.call(a+"_reduceTable",L.getLocal("pTable"),L.getLocal("chunkSize")),L.call(n+"_copy",L.getLocal("pTable"),L.getLocal("pr")),L.i32_store(L.i32_const(0),L.getLocal("pTable")))}function c(){const y=t.addFunction(a);y.addParam("pBases","i32"),y.addParam("pScalars","i32"),y.addParam("scalarSize","i32"),y.addParam("n","i32"),y.addParam("pr","i32"),y.addLocal("chunkSize","i32"),y.addLocal("nChunks","i32"),y.addLocal("itScalar","i32"),y.addLocal("endScalar","i32"),y.addLocal("itBase","i32"),y.addLocal("itBit","i32"),y.addLocal("i","i32"),y.addLocal("j","i32"),y.addLocal("nTable","i32"),y.addLocal("pTable","i32"),y.addLocal("idx","i32"),y.addLocal("pIdxTable","i32");const L=y.getCodeBuilder(),v=L.i32_const(t.alloc(s)),T=t.alloc([17,17,17,17,17,17,17,17,17,17,16,16,15,14,13,13,12,11,10,9,8,7,7,6,5,4,3,2,1,1,1,1]);y.addCode(L.call(n+"_zero",L.getLocal("pr")),L.if(L.i32_eqz(L.getLocal("n")),L.ret([])),L.setLocal("chunkSize",L.i32_load8_u(L.i32_clz(L.getLocal("n")),T)),L.setLocal("nChunks",L.i32_add(L.i32_div_u(L.i32_sub(L.i32_shl(L.getLocal("scalarSize"),L.i32_const(3)),L.i32_const(1)),L.getLocal("chunkSize")),L.i32_const(1))),L.setLocal("itBit",L.i32_mul(L.i32_sub(L.getLocal("nChunks"),L.i32_const(1)),L.getLocal("chunkSize"))),L.block(L.loop(L.br_if(1,L.i32_lt_s(L.getLocal("itBit"),L.i32_const(0))),L.if(L.i32_eqz(L.call(n+"_isZero",L.getLocal("pr"))),[...L.setLocal("j",L.i32_const(0)),...L.block(L.loop(L.br_if(1,L.i32_eq(L.getLocal("j"),L.getLocal("chunkSize"))),L.call(n+"_double",L.getLocal("pr"),L.getLocal("pr")),L.setLocal("j",L.i32_add(L.getLocal("j"),L.i32_const(1))),L.br(0)))]),L.call(a+"_chunk",L.getLocal("pBases"),L.getLocal("pScalars"),L.getLocal("scalarSize"),L.getLocal("n"),L.getLocal("itBit"),L.getLocal("chunkSize"),v),L.call(n+"_add",L.getLocal("pr"),v,L.getLocal("pr")),L.setLocal("itBit",L.i32_sub(L.getLocal("itBit"),L.getLocal("chunkSize"))),L.br(0))))}function f(){const y=t.addFunction(a+"_reduceTable");y.addParam("pTable","i32"),y.addParam("p","i32"),y.addLocal("half","i32"),y.addLocal("it1","i32"),y.addLocal("it2","i32"),y.addLocal("pAcc","i32");const L=y.getCodeBuilder();y.addCode(L.if(L.i32_eq(L.getLocal("p"),L.i32_const(1)),L.ret([])),L.setLocal("half",L.i32_shl(L.i32_const(1),L.i32_sub(L.getLocal("p"),L.i32_const(1)))),L.setLocal("it1",L.getLocal("pTable")),L.setLocal("it2",L.i32_add(L.getLocal("pTable"),L.i32_mul(L.getLocal("half"),L.i32_const(s)))),L.setLocal("pAcc",L.i32_sub(L.getLocal("it2"),L.i32_const(s))),L.block(L.loop(L.br_if(1,L.i32_eq(L.getLocal("it1"),L.getLocal("pAcc"))),L.call(n+"_add",L.getLocal("it1"),L.getLocal("it2"),L.getLocal("it1")),L.call(n+"_add",L.getLocal("pAcc"),L.getLocal("it2"),L.getLocal("pAcc")),L.setLocal("it1",L.i32_add(L.getLocal("it1"),L.i32_const(s))),L.setLocal("it2",L.i32_add(L.getLocal("it2"),L.i32_const(s))),L.br(0))),L.call(a+"_reduceTable",L.getLocal("pTable"),L.i32_sub(L.getLocal("p"),L.i32_const(1))),L.setLocal("p",L.i32_sub(L.getLocal("p"),L.i32_const(1))),L.block(L.loop(L.br_if(1,L.i32_eqz(L.getLocal("p"))),L.call(n+"_double",L.getLocal("pAcc"),L.getLocal("pAcc")),L.setLocal("p",L.i32_sub(L.getLocal("p"),L.i32_const(1))),L.br(0))),L.call(n+"_add",L.getLocal("pTable"),L.getLocal("pAcc"),L.getLocal("pTable")))}h(),f(),d(),c(),t.exportFunction(a),t.exportFunction(a+"_chunk")};const Ge=Tc,La=Po,Pe=Oc;var ko=function(t,n,a,i){const e=t.modules[a].n64,l=e*8;if(t.modules[n])return n;t.modules[n]={n64:e*3};function s(){const m=t.addFunction(n+"_isZero");m.addParam("p1","i32"),m.setReturnType("i32");const r=m.getCodeBuilder();m.addCode(r.call(a+"_isZero",r.i32_add(r.getLocal("p1"),r.i32_const(l*2))))}function h(){const m=t.addFunction(n+"_isZeroAffine");m.addParam("p1","i32"),m.setReturnType("i32");const r=m.getCodeBuilder();m.addCode(r.i32_and(r.call(a+"_isZero",r.getLocal("p1")),r.call(a+"_isZero",r.i32_add(r.getLocal("p1"),r.i32_const(l)))))}function d(){const m=t.addFunction(n+"_copy");m.addParam("ps","i32"),m.addParam("pd","i32");const r=m.getCodeBuilder();for(let C=0;C<e*3;C++)m.addCode(r.i64_store(r.getLocal("pd"),C*8,r.i64_load(r.getLocal("ps"),C*8)))}function c(){const m=t.addFunction(n+"_copyAffine");m.addParam("ps","i32"),m.addParam("pd","i32");const r=m.getCodeBuilder();for(let C=0;C<e*2;C++)m.addCode(r.i64_store(r.getLocal("pd"),C*8,r.i64_load(r.getLocal("ps"),C*8)))}function f(){const m=t.addFunction(n+"_zero");m.addParam("pr","i32");const r=m.getCodeBuilder();m.addCode(r.call(a+"_zero",r.getLocal("pr"))),m.addCode(r.call(a+"_one",r.i32_add(r.getLocal("pr"),r.i32_const(l)))),m.addCode(r.call(a+"_zero",r.i32_add(r.getLocal("pr"),r.i32_const(l*2))))}function y(){const m=t.addFunction(n+"_zeroAffine");m.addParam("pr","i32");const r=m.getCodeBuilder();m.addCode(r.call(a+"_zero",r.getLocal("pr"))),m.addCode(r.call(a+"_zero",r.i32_add(r.getLocal("pr"),r.i32_const(l))))}function L(){const m=t.addFunction(n+"_eq");m.addParam("p1","i32"),m.addParam("p2","i32"),m.setReturnType("i32"),m.addLocal("z1","i32"),m.addLocal("z2","i32");const r=m.getCodeBuilder(),C=r.getLocal("p1"),u=r.i32_add(r.getLocal("p1"),r.i32_const(l));m.addCode(r.setLocal("z1",r.i32_add(r.getLocal("p1"),r.i32_const(l*2))));const x=r.getLocal("z1"),F=r.getLocal("p2"),p=r.i32_add(r.getLocal("p2"),r.i32_const(l));m.addCode(r.setLocal("z2",r.i32_add(r.getLocal("p2"),r.i32_const(l*2))));const O=r.getLocal("z2"),R=r.i32_const(t.alloc(l)),N=r.i32_const(t.alloc(l)),H=r.i32_const(t.alloc(l)),lt=r.i32_const(t.alloc(l)),ht=r.i32_const(t.alloc(l)),pt=r.i32_const(t.alloc(l)),ut=r.i32_const(t.alloc(l)),st=r.i32_const(t.alloc(l));m.addCode(r.if(r.call(n+"_isZero",r.getLocal("p1")),r.ret(r.call(n+"_isZero",r.getLocal("p2")))),r.if(r.call(n+"_isZero",r.getLocal("p2")),r.ret(r.i32_const(0))),r.if(r.call(a+"_isOne",x),r.ret(r.call(n+"_eqMixed",r.getLocal("p2"),r.getLocal("p1")))),r.if(r.call(a+"_isOne",O),r.ret(r.call(n+"_eqMixed",r.getLocal("p1"),r.getLocal("p2")))),r.call(a+"_square",x,R),r.call(a+"_square",O,N),r.call(a+"_mul",C,N,H),r.call(a+"_mul",F,R,lt),r.call(a+"_mul",x,R,ht),r.call(a+"_mul",O,N,pt),r.call(a+"_mul",u,pt,ut),r.call(a+"_mul",p,ht,st),r.if(r.call(a+"_eq",H,lt),r.if(r.call(a+"_eq",ut,st),r.ret(r.i32_const(1)))),r.ret(r.i32_const(0)))}function v(){const m=t.addFunction(n+"_eqMixed");m.addParam("p1","i32"),m.addParam("p2","i32"),m.setReturnType("i32"),m.addLocal("z1","i32");const r=m.getCodeBuilder(),C=r.getLocal("p1"),u=r.i32_add(r.getLocal("p1"),r.i32_const(l));m.addCode(r.setLocal("z1",r.i32_add(r.getLocal("p1"),r.i32_const(l*2))));const x=r.getLocal("z1"),F=r.getLocal("p2"),p=r.i32_add(r.getLocal("p2"),r.i32_const(l)),O=r.i32_const(t.alloc(l)),R=r.i32_const(t.alloc(l)),N=r.i32_const(t.alloc(l)),H=r.i32_const(t.alloc(l));m.addCode(r.if(r.call(n+"_isZero",r.getLocal("p1")),r.ret(r.call(n+"_isZeroAffine",r.getLocal("p2")))),r.if(r.call(n+"_isZeroAffine",r.getLocal("p2")),r.ret(r.i32_const(0))),r.if(r.call(a+"_isOne",x),r.ret(r.call(n+"_eqAffine",r.getLocal("p1"),r.getLocal("p2")))),r.call(a+"_square",x,O),r.call(a+"_mul",F,O,R),r.call(a+"_mul",x,O,N),r.call(a+"_mul",p,N,H),r.if(r.call(a+"_eq",C,R),r.if(r.call(a+"_eq",u,H),r.ret(r.i32_const(1)))),r.ret(r.i32_const(0)))}function T(){const m=t.addFunction(n+"_double");m.addParam("p1","i32"),m.addParam("pr","i32");const r=m.getCodeBuilder(),C=r.getLocal("p1"),u=r.i32_add(r.getLocal("p1"),r.i32_const(l)),x=r.i32_add(r.getLocal("p1"),r.i32_const(l*2)),F=r.getLocal("pr"),p=r.i32_add(r.getLocal("pr"),r.i32_const(l)),O=r.i32_add(r.getLocal("pr"),r.i32_const(l*2)),R=r.i32_const(t.alloc(l)),N=r.i32_const(t.alloc(l)),H=r.i32_const(t.alloc(l)),lt=r.i32_const(t.alloc(l)),ht=r.i32_const(t.alloc(l)),pt=r.i32_const(t.alloc(l)),ut=r.i32_const(t.alloc(l)),st=r.i32_const(t.alloc(l));m.addCode(r.if(r.call(n+"_isZero",r.getLocal("p1")),[...r.call(n+"_copy",r.getLocal("p1"),r.getLocal("pr")),...r.ret([])]),r.if(r.call(a+"_isOne",x),[...r.ret(r.call(n+"_doubleAffine",r.getLocal("p1"),r.getLocal("pr"))),...r.ret([])]),r.call(a+"_square",C,R),r.call(a+"_square",u,N),r.call(a+"_square",N,H),r.call(a+"_add",C,N,lt),r.call(a+"_square",lt,lt),r.call(a+"_sub",lt,R,lt),r.call(a+"_sub",lt,H,lt),r.call(a+"_add",lt,lt,lt),r.call(a+"_add",R,R,ht),r.call(a+"_add",ht,R,ht),r.call(a+"_square",ht,pt),r.call(a+"_mul",u,x,ut),r.call(a+"_add",lt,lt,F),r.call(a+"_sub",pt,F,F),r.call(a+"_add",H,H,st),r.call(a+"_add",st,st,st),r.call(a+"_add",st,st,st),r.call(a+"_sub",lt,F,p),r.call(a+"_mul",p,ht,p),r.call(a+"_sub",p,st,p),r.call(a+"_add",ut,ut,O))}function B(){const m=t.addFunction(n+"_doubleAffine");m.addParam("p1","i32"),m.addParam("pr","i32");const r=m.getCodeBuilder(),C=r.getLocal("p1"),u=r.i32_add(r.getLocal("p1"),r.i32_const(l)),x=r.getLocal("pr"),F=r.i32_add(r.getLocal("pr"),r.i32_const(l)),p=r.i32_add(r.getLocal("pr"),r.i32_const(l*2)),O=r.i32_const(t.alloc(l)),R=r.i32_const(t.alloc(l)),N=r.i32_const(t.alloc(l)),H=r.i32_const(t.alloc(l)),lt=r.i32_const(t.alloc(l)),ht=r.i32_const(t.alloc(l));m.addCode(r.if(r.call(n+"_isZeroAffine",r.getLocal("p1")),[...r.call(n+"_toJacobian",r.getLocal("p1"),r.getLocal("pr")),...r.ret([])]),r.call(a+"_square",C,O),r.call(a+"_square",u,R),r.call(a+"_square",R,N),r.call(a+"_add",C,R,H),r.call(a+"_square",H,H),r.call(a+"_sub",H,O,H),r.call(a+"_sub",H,N,H),r.call(a+"_add",H,H,H),r.call(a+"_add",O,O,lt),r.call(a+"_add",lt,O,lt),r.call(a+"_add",u,u,p),r.call(a+"_square",lt,x),r.call(a+"_sub",x,H,x),r.call(a+"_sub",x,H,x),r.call(a+"_add",N,N,ht),r.call(a+"_add",ht,ht,ht),r.call(a+"_add",ht,ht,ht),r.call(a+"_sub",H,x,F),r.call(a+"_mul",F,lt,F),r.call(a+"_sub",F,ht,F))}function E(){const m=t.addFunction(n+"_eqAffine");m.addParam("p1","i32"),m.addParam("p2","i32"),m.setReturnType("i32"),m.addLocal("z1","i32");const r=m.getCodeBuilder();m.addCode(r.ret(r.i32_and(r.call(a+"_eq",r.getLocal("p1"),r.getLocal("p2")),r.call(a+"_eq",r.i32_add(r.getLocal("p1"),r.i32_const(l)),r.i32_add(r.getLocal("p2"),r.i32_const(l))))))}function A(){const m=t.addFunction(n+"_toMontgomery");m.addParam("p1","i32"),m.addParam("pr","i32");const r=m.getCodeBuilder();m.addCode(r.call(a+"_toMontgomery",r.getLocal("p1"),r.getLocal("pr")));for(let C=1;C<3;C++)m.addCode(r.call(a+"_toMontgomery",r.i32_add(r.getLocal("p1"),r.i32_const(C*l)),r.i32_add(r.getLocal("pr"),r.i32_const(C*l))))}function G(){const m=t.addFunction(n+"_toMontgomeryAffine");m.addParam("p1","i32"),m.addParam("pr","i32");const r=m.getCodeBuilder();m.addCode(r.call(a+"_toMontgomery",r.getLocal("p1"),r.getLocal("pr")));for(let C=1;C<2;C++)m.addCode(r.call(a+"_toMontgomery",r.i32_add(r.getLocal("p1"),r.i32_const(C*l)),r.i32_add(r.getLocal("pr"),r.i32_const(C*l))))}function P(){const m=t.addFunction(n+"_fromMontgomery");m.addParam("p1","i32"),m.addParam("pr","i32");const r=m.getCodeBuilder();m.addCode(r.call(a+"_fromMontgomery",r.getLocal("p1"),r.getLocal("pr")));for(let C=1;C<3;C++)m.addCode(r.call(a+"_fromMontgomery",r.i32_add(r.getLocal("p1"),r.i32_const(C*l)),r.i32_add(r.getLocal("pr"),r.i32_const(C*l))))}function U(){const m=t.addFunction(n+"_fromMontgomeryAffine");m.addParam("p1","i32"),m.addParam("pr","i32");const r=m.getCodeBuilder();m.addCode(r.call(a+"_fromMontgomery",r.getLocal("p1"),r.getLocal("pr")));for(let C=1;C<2;C++)m.addCode(r.call(a+"_fromMontgomery",r.i32_add(r.getLocal("p1"),r.i32_const(C*l)),r.i32_add(r.getLocal("pr"),r.i32_const(C*l))))}function I(){const m=t.addFunction(n+"_add");m.addParam("p1","i32"),m.addParam("p2","i32"),m.addParam("pr","i32"),m.addLocal("z1","i32"),m.addLocal("z2","i32");const r=m.getCodeBuilder(),C=r.getLocal("p1"),u=r.i32_add(r.getLocal("p1"),r.i32_const(l));m.addCode(r.setLocal("z1",r.i32_add(r.getLocal("p1"),r.i32_const(l*2))));const x=r.getLocal("z1"),F=r.getLocal("p2"),p=r.i32_add(r.getLocal("p2"),r.i32_const(l));m.addCode(r.setLocal("z2",r.i32_add(r.getLocal("p2"),r.i32_const(l*2))));const O=r.getLocal("z2"),R=r.getLocal("pr"),N=r.i32_add(r.getLocal("pr"),r.i32_const(l)),H=r.i32_add(r.getLocal("pr"),r.i32_const(l*2)),lt=r.i32_const(t.alloc(l)),ht=r.i32_const(t.alloc(l)),pt=r.i32_const(t.alloc(l)),ut=r.i32_const(t.alloc(l)),st=r.i32_const(t.alloc(l)),ct=r.i32_const(t.alloc(l)),Lt=r.i32_const(t.alloc(l)),At=r.i32_const(t.alloc(l)),Bt=r.i32_const(t.alloc(l)),Mt=r.i32_const(t.alloc(l)),$t=r.i32_const(t.alloc(l)),Dt=r.i32_const(t.alloc(l)),vt=r.i32_const(t.alloc(l)),bt=r.i32_const(t.alloc(l)),qt=r.i32_const(t.alloc(l)),Yt=r.i32_const(t.alloc(l)),Ht=r.i32_const(t.alloc(l));m.addCode(r.if(r.call(n+"_isZero",r.getLocal("p1")),[...r.call(n+"_copy",r.getLocal("p2"),r.getLocal("pr")),...r.ret([])]),r.if(r.call(n+"_isZero",r.getLocal("p2")),[...r.call(n+"_copy",r.getLocal("p1"),r.getLocal("pr")),...r.ret([])]),r.if(r.call(a+"_isOne",x),[...r.call(n+"_addMixed",F,C,R),...r.ret([])]),r.if(r.call(a+"_isOne",O),[...r.call(n+"_addMixed",C,F,R),...r.ret([])]),r.call(a+"_square",x,lt),r.call(a+"_square",O,ht),r.call(a+"_mul",C,ht,pt),r.call(a+"_mul",F,lt,ut),r.call(a+"_mul",x,lt,st),r.call(a+"_mul",O,ht,ct),r.call(a+"_mul",u,ct,Lt),r.call(a+"_mul",p,st,At),r.if(r.call(a+"_eq",pt,ut),r.if(r.call(a+"_eq",Lt,At),[...r.call(n+"_double",r.getLocal("p1"),r.getLocal("pr")),...r.ret([])])),r.call(a+"_sub",ut,pt,Bt),r.call(a+"_sub",At,Lt,Mt),r.call(a+"_add",Bt,Bt,$t),r.call(a+"_square",$t,$t),r.call(a+"_mul",Bt,$t,Dt),r.call(a+"_add",Mt,Mt,vt),r.call(a+"_mul",pt,$t,qt),r.call(a+"_square",vt,bt),r.call(a+"_add",qt,qt,Yt),r.call(a+"_sub",bt,Dt,R),r.call(a+"_sub",R,Yt,R),r.call(a+"_mul",Lt,Dt,Ht),r.call(a+"_add",Ht,Ht,Ht),r.call(a+"_sub",qt,R,N),r.call(a+"_mul",N,vt,N),r.call(a+"_sub",N,Ht,N),r.call(a+"_add",x,O,H),r.call(a+"_square",H,H),r.call(a+"_sub",H,lt,H),r.call(a+"_sub",H,ht,H),r.call(a+"_mul",H,Bt,H))}function _(){const m=t.addFunction(n+"_addMixed");m.addParam("p1","i32"),m.addParam("p2","i32"),m.addParam("pr","i32"),m.addLocal("z1","i32");const r=m.getCodeBuilder(),C=r.getLocal("p1"),u=r.i32_add(r.getLocal("p1"),r.i32_const(l));m.addCode(r.setLocal("z1",r.i32_add(r.getLocal("p1"),r.i32_const(l*2))));const x=r.getLocal("z1"),F=r.getLocal("p2"),p=r.i32_add(r.getLocal("p2"),r.i32_const(l)),O=r.getLocal("pr"),R=r.i32_add(r.getLocal("pr"),r.i32_const(l)),N=r.i32_add(r.getLocal("pr"),r.i32_const(l*2)),H=r.i32_const(t.alloc(l)),lt=r.i32_const(t.alloc(l)),ht=r.i32_const(t.alloc(l)),pt=r.i32_const(t.alloc(l)),ut=r.i32_const(t.alloc(l)),st=r.i32_const(t.alloc(l)),ct=r.i32_const(t.alloc(l)),Lt=r.i32_const(t.alloc(l)),At=r.i32_const(t.alloc(l)),Bt=r.i32_const(t.alloc(l)),Mt=r.i32_const(t.alloc(l)),$t=r.i32_const(t.alloc(l)),Dt=r.i32_const(t.alloc(l)),vt=r.i32_const(t.alloc(l));m.addCode(r.if(r.call(n+"_isZero",r.getLocal("p1")),[...r.call(n+"_copyAffine",r.getLocal("p2"),r.getLocal("pr")),...r.call(a+"_one",r.i32_add(r.getLocal("pr"),r.i32_const(l*2))),...r.ret([])]),r.if(r.call(n+"_isZeroAffine",r.getLocal("p2")),[...r.call(n+"_copy",r.getLocal("p1"),r.getLocal("pr")),...r.ret([])]),r.if(r.call(a+"_isOne",x),[...r.call(n+"_addAffine",C,F,O),...r.ret([])]),r.call(a+"_square",x,H),r.call(a+"_mul",F,H,lt),r.call(a+"_mul",x,H,ht),r.call(a+"_mul",p,ht,pt),r.if(r.call(a+"_eq",C,lt),r.if(r.call(a+"_eq",u,pt),[...r.call(n+"_doubleAffine",r.getLocal("p2"),r.getLocal("pr")),...r.ret([])])),r.call(a+"_sub",lt,C,ut),r.call(a+"_sub",pt,u,ct),r.call(a+"_square",ut,st),r.call(a+"_add",st,st,Lt),r.call(a+"_add",Lt,Lt,Lt),r.call(a+"_mul",ut,Lt,At),r.call(a+"_add",ct,ct,Bt),r.call(a+"_mul",C,Lt,$t),r.call(a+"_square",Bt,Mt),r.call(a+"_add",$t,$t,Dt),r.call(a+"_sub",Mt,At,O),r.call(a+"_sub",O,Dt,O),r.call(a+"_mul",u,At,vt),r.call(a+"_add",vt,vt,vt),r.call(a+"_sub",$t,O,R),r.call(a+"_mul",R,Bt,R),r.call(a+"_sub",R,vt,R),r.call(a+"_add",x,ut,N),r.call(a+"_square",N,N),r.call(a+"_sub",N,H,N),r.call(a+"_sub",N,st,N))}function b(){const m=t.addFunction(n+"_addAffine");m.addParam("p1","i32"),m.addParam("p2","i32"),m.addParam("pr","i32"),m.addLocal("z1","i32");const r=m.getCodeBuilder(),C=r.getLocal("p1"),u=r.i32_add(r.getLocal("p1"),r.i32_const(l));m.addCode(r.setLocal("z1",r.i32_add(r.getLocal("p1"),r.i32_const(l*2))));const x=r.getLocal("p2"),F=r.i32_add(r.getLocal("p2"),r.i32_const(l)),p=r.getLocal("pr"),O=r.i32_add(r.getLocal("pr"),r.i32_const(l)),R=r.i32_add(r.getLocal("pr"),r.i32_const(l*2)),N=r.i32_const(t.alloc(l)),H=r.i32_const(t.alloc(l)),lt=r.i32_const(t.alloc(l)),ht=r.i32_const(t.alloc(l)),pt=r.i32_const(t.alloc(l)),ut=r.i32_const(t.alloc(l)),st=r.i32_const(t.alloc(l)),ct=r.i32_const(t.alloc(l)),Lt=r.i32_const(t.alloc(l)),At=r.i32_const(t.alloc(l));m.addCode(r.if(r.call(n+"_isZeroAffine",r.getLocal("p1")),[...r.call(n+"_copyAffine",r.getLocal("p2"),r.getLocal("pr")),...r.call(a+"_one",r.i32_add(r.getLocal("pr"),r.i32_const(l*2))),...r.ret([])]),r.if(r.call(n+"_isZeroAffine",r.getLocal("p2")),[...r.call(n+"_copyAffine",r.getLocal("p1"),r.getLocal("pr")),...r.call(a+"_one",r.i32_add(r.getLocal("pr"),r.i32_const(l*2))),...r.ret([])]),r.if(r.call(a+"_eq",C,x),r.if(r.call(a+"_eq",u,F),[...r.call(n+"_doubleAffine",r.getLocal("p2"),r.getLocal("pr")),...r.ret([])])),r.call(a+"_sub",x,C,N),r.call(a+"_sub",F,u,lt),r.call(a+"_square",N,H),r.call(a+"_add",H,H,ht),r.call(a+"_add",ht,ht,ht),r.call(a+"_mul",N,ht,pt),r.call(a+"_add",lt,lt,ut),r.call(a+"_mul",C,ht,ct),r.call(a+"_square",ut,st),r.call(a+"_add",ct,ct,Lt),r.call(a+"_sub",st,pt,p),r.call(a+"_sub",p,Lt,p),r.call(a+"_mul",u,pt,At),r.call(a+"_add",At,At,At),r.call(a+"_sub",ct,p,O),r.call(a+"_mul",O,ut,O),r.call(a+"_sub",O,At,O),r.call(a+"_add",N,N,R))}function $(){const m=t.addFunction(n+"_neg");m.addParam("p1","i32"),m.addParam("pr","i32");const r=m.getCodeBuilder(),C=r.getLocal("p1"),u=r.i32_add(r.getLocal("p1"),r.i32_const(l)),x=r.i32_add(r.getLocal("p1"),r.i32_const(l*2)),F=r.getLocal("pr"),p=r.i32_add(r.getLocal("pr"),r.i32_const(l)),O=r.i32_add(r.getLocal("pr"),r.i32_const(l*2));m.addCode(r.call(a+"_copy",C,F),r.call(a+"_neg",u,p),r.call(a+"_copy",x,O))}function K(){const m=t.addFunction(n+"_negAffine");m.addParam("p1","i32"),m.addParam("pr","i32");const r=m.getCodeBuilder(),C=r.getLocal("p1"),u=r.i32_add(r.getLocal("p1"),r.i32_const(l)),x=r.getLocal("pr"),F=r.i32_add(r.getLocal("pr"),r.i32_const(l));m.addCode(r.call(a+"_copy",C,x),r.call(a+"_neg",u,F))}function j(){const m=t.addFunction(n+"_sub");m.addParam("p1","i32"),m.addParam("p2","i32"),m.addParam("pr","i32");const r=m.getCodeBuilder(),C=r.i32_const(t.alloc(l*3));m.addCode(r.call(n+"_neg",r.getLocal("p2"),C),r.call(n+"_add",r.getLocal("p1"),C,r.getLocal("pr")))}function M(){const m=t.addFunction(n+"_subMixed");m.addParam("p1","i32"),m.addParam("p2","i32"),m.addParam("pr","i32");const r=m.getCodeBuilder(),C=r.i32_const(t.alloc(l*3));m.addCode(r.call(n+"_negAffine",r.getLocal("p2"),C),r.call(n+"_addMixed",r.getLocal("p1"),C,r.getLocal("pr")))}function S(){const m=t.addFunction(n+"_subAffine");m.addParam("p1","i32"),m.addParam("p2","i32"),m.addParam("pr","i32");const r=m.getCodeBuilder(),C=r.i32_const(t.alloc(l*3));m.addCode(r.call(n+"_negAffine",r.getLocal("p2"),C),r.call(n+"_addAffine",r.getLocal("p1"),C,r.getLocal("pr")))}function z(){const m=t.addFunction(n+"_normalize");m.addParam("p1","i32"),m.addParam("pr","i32");const r=m.getCodeBuilder(),C=r.getLocal("p1"),u=r.i32_add(r.getLocal("p1"),r.i32_const(l)),x=r.i32_add(r.getLocal("p1"),r.i32_const(l*2)),F=r.getLocal("pr"),p=r.i32_add(r.getLocal("pr"),r.i32_const(l)),O=r.i32_add(r.getLocal("pr"),r.i32_const(l*2)),R=r.i32_const(t.alloc(l)),N=r.i32_const(t.alloc(l)),H=r.i32_const(t.alloc(l));m.addCode(r.if(r.call(n+"_isZero",r.getLocal("p1")),r.call(n+"_zero",r.getLocal("pr")),[...r.call(a+"_inverse",x,R),...r.call(a+"_square",R,N),...r.call(a+"_mul",R,N,H),...r.call(a+"_mul",C,N,F),...r.call(a+"_mul",u,H,p),...r.call(a+"_one",O)]))}function q(){const m=t.addFunction(n+"_toAffine");m.addParam("p1","i32"),m.addParam("pr","i32");const r=m.getCodeBuilder(),C=r.getLocal("p1"),u=r.i32_add(r.getLocal("p1"),r.i32_const(l)),x=r.i32_add(r.getLocal("p1"),r.i32_const(l*2)),F=r.getLocal("pr"),p=r.i32_add(r.getLocal("pr"),r.i32_const(l)),O=r.i32_const(t.alloc(l)),R=r.i32_const(t.alloc(l)),N=r.i32_const(t.alloc(l));m.addCode(r.if(r.call(n+"_isZero",r.getLocal("p1")),[...r.call(a+"_zero",F),...r.call(a+"_zero",p)],[...r.call(a+"_inverse",x,O),...r.call(a+"_square",O,R),...r.call(a+"_mul",O,R,N),...r.call(a+"_mul",C,R,F),...r.call(a+"_mul",u,N,p)]))}function Z(){const m=t.addFunction(n+"_toJacobian");m.addParam("p1","i32"),m.addParam("pr","i32");const r=m.getCodeBuilder(),C=r.getLocal("p1"),u=r.i32_add(r.getLocal("p1"),r.i32_const(l)),x=r.getLocal("pr"),F=r.i32_add(r.getLocal("pr"),r.i32_const(l)),p=r.i32_add(r.getLocal("pr"),r.i32_const(l*2));m.addCode(r.if(r.call(n+"_isZeroAffine",r.getLocal("p1")),r.call(n+"_zero",r.getLocal("pr")),[...r.call(a+"_one",p),...r.call(a+"_copy",u,F),...r.call(a+"_copy",C,x)]))}function Y(){const m=t.addFunction(n+"_batchToAffine");m.addParam("pIn","i32"),m.addParam("n","i32"),m.addParam("pOut","i32"),m.addLocal("pAux","i32"),m.addLocal("itIn","i32"),m.addLocal("itAux","i32"),m.addLocal("itOut","i32"),m.addLocal("i","i32");const r=m.getCodeBuilder(),C=r.i32_const(t.alloc(l));m.addCode(r.setLocal("pAux",r.i32_load(r.i32_const(0))),r.i32_store(r.i32_const(0),r.i32_add(r.getLocal("pAux"),r.i32_mul(r.getLocal("n"),r.i32_const(l)))),r.call(a+"_batchInverse",r.i32_add(r.getLocal("pIn"),r.i32_const(l*2)),r.i32_const(l*3),r.getLocal("n"),r.getLocal("pAux"),r.i32_const(l)),r.setLocal("itIn",r.getLocal("pIn")),r.setLocal("itAux",r.getLocal("pAux")),r.setLocal("itOut",r.getLocal("pOut")),r.setLocal("i",r.i32_const(0)),r.block(r.loop(r.br_if(1,r.i32_eq(r.getLocal("i"),r.getLocal("n"))),r.if(r.call(a+"_isZero",r.getLocal("itAux")),[...r.call(a+"_zero",r.getLocal("itOut")),...r.call(a+"_zero",r.i32_add(r.getLocal("itOut"),r.i32_const(l)))],[...r.call(a+"_mul",r.getLocal("itAux"),r.i32_add(r.getLocal("itIn"),r.i32_const(l)),C),...r.call(a+"_square",r.getLocal("itAux"),r.getLocal("itAux")),...r.call(a+"_mul",r.getLocal("itAux"),r.getLocal("itIn"),r.getLocal("itOut")),...r.call(a+"_mul",r.getLocal("itAux"),C,r.i32_add(r.getLocal("itOut"),r.i32_const(l)))]),r.setLocal("itIn",r.i32_add(r.getLocal("itIn"),r.i32_const(l*3))),r.setLocal("itOut",r.i32_add(r.getLocal("itOut"),r.i32_const(l*2))),r.setLocal("itAux",r.i32_add(r.getLocal("itAux"),r.i32_const(l))),r.setLocal("i",r.i32_add(r.getLocal("i"),r.i32_const(1))),r.br(0))),r.i32_store(r.i32_const(0),r.getLocal("pAux")))}function V(){const m=t.addFunction(n+"__reverseBytes");m.addParam("pIn","i32"),m.addParam("n","i32"),m.addParam("pOut","i32"),m.addLocal("itOut","i32"),m.addLocal("itIn","i32");const r=m.getCodeBuilder();m.addCode(r.setLocal("itOut",r.i32_sub(r.i32_add(r.getLocal("pOut"),r.getLocal("n")),r.i32_const(1))),r.setLocal("itIn",r.getLocal("pIn")),r.block(r.loop(r.br_if(1,r.i32_lt_s(r.getLocal("itOut"),r.getLocal("pOut"))),r.i32_store8(r.getLocal("itOut"),r.i32_load8_u(r.getLocal("itIn"))),r.setLocal("itOut",r.i32_sub(r.getLocal("itOut"),r.i32_const(1))),r.setLocal("itIn",r.i32_add(r.getLocal("itIn"),r.i32_const(1))),r.br(0))))}function nt(){const m=t.addFunction(n+"_LEMtoC");m.addParam("pIn","i32"),m.addParam("pOut","i32");const r=m.getCodeBuilder(),C=r.i32_const(t.alloc(l));m.addCode(r.if(r.call(n+"_isZeroAffine",r.getLocal("pIn")),[...r.call(a+"_zero",r.getLocal("pOut")),...r.i32_store8(r.getLocal("pOut"),r.i32_const(64)),...r.ret([])]),r.call(a+"_fromMontgomery",r.getLocal("pIn"),C),r.call(n+"__reverseBytes",C,r.i32_const(l),r.getLocal("pOut")),r.if(r.i32_eq(r.call(a+"_sign",r.i32_add(r.getLocal("pIn"),r.i32_const(l))),r.i32_const(-1)),r.i32_store8(r.getLocal("pOut"),r.i32_or(r.i32_load8_u(r.getLocal("pOut")),r.i32_const(128)))))}function Q(){const m=t.addFunction(n+"_LEMtoU");m.addParam("pIn","i32"),m.addParam("pOut","i32");const r=m.getCodeBuilder(),C=t.alloc(l*2),u=r.i32_const(C),x=r.i32_const(C),F=r.i32_const(C+l);m.addCode(r.if(r.call(n+"_isZeroAffine",r.getLocal("pIn")),[...r.call(n+"_zeroAffine",r.getLocal("pOut")),...r.ret([])]),r.call(n+"_fromMontgomeryAffine",r.getLocal("pIn"),u),r.call(n+"__reverseBytes",x,r.i32_const(l),r.getLocal("pOut")),r.call(n+"__reverseBytes",F,r.i32_const(l),r.i32_add(r.getLocal("pOut"),r.i32_const(l))))}function it(){const m=t.addFunction(n+"_UtoLEM");m.addParam("pIn","i32"),m.addParam("pOut","i32");const r=m.getCodeBuilder(),C=t.alloc(l*2),u=r.i32_const(C),x=r.i32_const(C),F=r.i32_const(C+l);m.addCode(r.if(r.i32_and(r.i32_load8_u(r.getLocal("pIn")),r.i32_const(64)),[...r.call(n+"_zeroAffine",r.getLocal("pOut")),...r.ret([])]),r.call(n+"__reverseBytes",r.getLocal("pIn"),r.i32_const(l),x),r.call(n+"__reverseBytes",r.i32_add(r.getLocal("pIn"),r.i32_const(l)),r.i32_const(l),F),r.call(n+"_toMontgomeryAffine",u,r.getLocal("pOut")))}function X(){const m=t.addFunction(n+"_CtoLEM");m.addParam("pIn","i32"),m.addParam("pOut","i32"),m.addLocal("firstByte","i32"),m.addLocal("greatest","i32");const r=m.getCodeBuilder(),C=t.alloc(l*2),u=r.i32_const(C),x=r.i32_const(C+l);m.addCode(r.setLocal("firstByte",r.i32_load8_u(r.getLocal("pIn"))),r.if(r.i32_and(r.getLocal("firstByte"),r.i32_const(64)),[...r.call(n+"_zeroAffine",r.getLocal("pOut")),...r.ret([])]),r.setLocal("greatest",r.i32_and(r.getLocal("firstByte"),r.i32_const(128))),r.call(a+"_copy",r.getLocal("pIn"),x),r.i32_store8(x,r.i32_and(r.getLocal("firstByte"),r.i32_const(63))),r.call(n+"__reverseBytes",x,r.i32_const(l),u),r.call(a+"_toMontgomery",u,r.getLocal("pOut")),r.call(a+"_square",r.getLocal("pOut"),x),r.call(a+"_mul",r.getLocal("pOut"),x,x),r.call(a+"_add",x,r.i32_const(i),x),r.call(a+"_sqrt",x,x),r.call(a+"_neg",x,u),r.if(r.i32_eq(r.call(a+"_sign",x),r.i32_const(-1)),r.if(r.getLocal("greatest"),r.call(a+"_copy",x,r.i32_add(r.getLocal("pOut"),r.i32_const(l))),r.call(a+"_neg",x,r.i32_add(r.getLocal("pOut"),r.i32_const(l)))),r.if(r.getLocal("greatest"),r.call(a+"_neg",x,r.i32_add(r.getLocal("pOut"),r.i32_const(l))),r.call(a+"_copy",x,r.i32_add(r.getLocal("pOut"),r.i32_const(l))))))}function k(){const m=t.addFunction(n+"_inCurveAffine");m.addParam("pIn","i32"),m.setReturnType("i32");const r=m.getCodeBuilder(),C=r.getLocal("pIn"),u=r.i32_add(r.getLocal("pIn"),r.i32_const(l)),x=r.i32_const(t.alloc(l)),F=r.i32_const(t.alloc(l));m.addCode(r.call(a+"_square",u,x),r.call(a+"_square",C,F),r.call(a+"_mul",C,F,F),r.call(a+"_add",F,r.i32_const(i),F),r.ret(r.call(a+"_eq",x,F)))}function J(){const m=t.addFunction(n+"_inCurve");m.addParam("pIn","i32"),m.setReturnType("i32");const r=m.getCodeBuilder(),C=r.i32_const(t.alloc(l*2));m.addCode(r.call(n+"_toAffine",r.getLocal("pIn"),C),r.ret(r.call(n+"_inCurveAffine",C)))}return h(),s(),y(),f(),c(),d(),Z(),E(),v(),L(),B(),T(),b(),_(),I(),K(),$(),S(),M(),j(),U(),P(),G(),A(),q(),k(),J(),Y(),z(),V(),Q(),nt(),it(),X(),La(t,n+"_batchLEMtoU",n+"_LEMtoU",l*2,l*2),La(t,n+"_batchLEMtoC",n+"_LEMtoC",l*2,l),La(t,n+"_batchUtoLEM",n+"_UtoLEM",l*2,l*2),La(t,n+"_batchCtoLEM",n+"_CtoLEM",l,l*2,!0),La(t,n+"_batchToJacobian",n+"_toJacobian",l*2,l*3,!0),Pe(t,n,n+"_multiexp",n+"_add",l*3),Pe(t,n,n+"_multiexpAffine",n+"_addMixed",l*2),Ge(t,n+"_timesScalar",l*3,n+"_add",n+"_double",n+"_sub",n+"_copy",n+"_zero"),Ge(t,n+"_timesScalarAffine",l*2,n+"_addMixed",n+"_double",n+"_subMixed",n+"_copyAffine",n+"_zero"),t.exportFunction(n+"_isZero"),t.exportFunction(n+"_isZeroAffine"),t.exportFunction(n+"_eq"),t.exportFunction(n+"_eqMixed"),t.exportFunction(n+"_eqAffine"),t.exportFunction(n+"_copy"),t.exportFunction(n+"_copyAffine"),t.exportFunction(n+"_zero"),t.exportFunction(n+"_zeroAffine"),t.exportFunction(n+"_double"),t.exportFunction(n+"_doubleAffine"),t.exportFunction(n+"_add"),t.exportFunction(n+"_addMixed"),t.exportFunction(n+"_addAffine"),t.exportFunction(n+"_neg"),t.exportFunction(n+"_negAffine"),t.exportFunction(n+"_sub"),t.exportFunction(n+"_subMixed"),t.exportFunction(n+"_subAffine"),t.exportFunction(n+"_fromMontgomery"),t.exportFunction(n+"_fromMontgomeryAffine"),t.exportFunction(n+"_toMontgomery"),t.exportFunction(n+"_toMontgomeryAffine"),t.exportFunction(n+"_timesScalar"),t.exportFunction(n+"_timesScalarAffine"),t.exportFunction(n+"_normalize"),t.exportFunction(n+"_LEMtoU"),t.exportFunction(n+"_LEMtoC"),t.exportFunction(n+"_UtoLEM"),t.exportFunction(n+"_CtoLEM"),t.exportFunction(n+"_batchLEMtoU"),t.exportFunction(n+"_batchLEMtoC"),t.exportFunction(n+"_batchUtoLEM"),t.exportFunction(n+"_batchCtoLEM"),t.exportFunction(n+"_toAffine"),t.exportFunction(n+"_toJacobian"),t.exportFunction(n+"_batchToAffine"),t.exportFunction(n+"_batchToJacobian"),t.exportFunction(n+"_inCurve"),t.exportFunction(n+"_inCurveAffine"),n};const{isOdd:Uc,modInv:Te,modPow:ma}=un,Da=Nn;var $o=function(t,n,a,i,e){const s=t.modules[i].n64*8,d=t.modules[a].n64*8,c=t.modules[i].q;let f=c-1n,y=0;for(;!Uc(f);)y++,f=f>>1n;let L=2n;for(;ma(L,c>>1n,c)===1n;)L=L+1n;const v=new Array(y+1);v[y]=ma(L,f,c);let T=y-1;for(;T>=0;)v[T]=ma(v[T+1],2n,c),T--;const B=[],E=(1n<<BigInt(s*8))%c;for(let C=0;C<v.length;C++){const u=v[C]*E%c;B.push(...Da.bigInt2BytesLE(u,s))}const A=t.alloc(B),G=new Array(y+1);G[0]=1n;for(let C=1;C<=y;C++)G[C]=G[C-1]*2n;const P=[];for(let C=0;C<=y;C++){const u=Te(G[C],c)*E%c;P.push(...Da.bigInt2BytesLE(u,s))}const U=t.alloc(P),I=ma(L,2n,c),_=[],b=[];for(let C=0;C<=y;C++){const u=ma(I,2n**BigInt(C),c),x=Te(c+1n-u,c);_.push(...Da.bigInt2BytesLE(u*E%c,s)),b.push(...Da.bigInt2BytesLE(x*E%c,s))}const $=t.alloc(_),K=t.alloc(b);function j(C){let u=0;for(let x=0;x<8;x++)C&1<<x&&(u=u|128>>x);return u}const M=Array(256);for(let C=0;C<256;C++)M[C]=j(C);const S=t.alloc(M);function z(){const C=t.addFunction(n+"__log2");C.addParam("n","i32"),C.setReturnType("i32"),C.addLocal("bits","i32"),C.addLocal("aux","i32");const u=C.getCodeBuilder();C.addCode(u.setLocal("aux",u.i32_shr_u(u.getLocal("n"),u.i32_const(1)))),C.addCode(u.setLocal("bits",u.i32_const(0))),C.addCode(u.block(u.loop(u.br_if(1,u.i32_eqz(u.getLocal("aux"))),u.setLocal("aux",u.i32_shr_u(u.getLocal("aux"),u.i32_const(1))),u.setLocal("bits",u.i32_add(u.getLocal("bits"),u.i32_const(1))),u.br(0)))),C.addCode(u.if(u.i32_ne(u.getLocal("n"),u.i32_shl(u.i32_const(1),u.getLocal("bits"))),u.unreachable())),C.addCode(u.if(u.i32_gt_u(u.getLocal("bits"),u.i32_const(y)),u.unreachable())),C.addCode(u.getLocal("bits"))}function q(){const C=t.addFunction(n+"_fft");C.addParam("px","i32"),C.addParam("n","i32"),C.addLocal("bits","i32");const u=C.getCodeBuilder(),x=u.i32_const(t.alloc(s));C.addCode(u.setLocal("bits",u.call(n+"__log2",u.getLocal("n"))),u.call(i+"_one",x),u.call(n+"_rawfft",u.getLocal("px"),u.getLocal("bits"),u.i32_const(0),x))}function Z(){const C=t.addFunction(n+"_ifft");C.addParam("px","i32"),C.addParam("n","i32"),C.addLocal("bits","i32"),C.addLocal("pInv2","i32");const u=C.getCodeBuilder();C.addCode(u.setLocal("bits",u.call(n+"__log2",u.getLocal("n"))),u.setLocal("pInv2",u.i32_add(u.i32_const(U),u.i32_mul(u.getLocal("bits"),u.i32_const(s)))),u.call(n+"_rawfft",u.getLocal("px"),u.getLocal("bits"),u.i32_const(1),u.getLocal("pInv2")))}function Y(){const C=t.addFunction(n+"_rawfft");C.addParam("px","i32"),C.addParam("bits","i32"),C.addParam("reverse","i32"),C.addParam("mulFactor","i32"),C.addLocal("s","i32"),C.addLocal("k","i32"),C.addLocal("j","i32"),C.addLocal("m","i32"),C.addLocal("mdiv2","i32"),C.addLocal("n","i32"),C.addLocal("pwm","i32"),C.addLocal("idx1","i32"),C.addLocal("idx2","i32");const u=C.getCodeBuilder(),x=u.i32_const(t.alloc(s)),F=u.i32_const(t.alloc(d)),p=u.i32_const(t.alloc(d));C.addCode(u.call(n+"__reversePermutation",u.getLocal("px"),u.getLocal("bits")),u.setLocal("n",u.i32_shl(u.i32_const(1),u.getLocal("bits"))),u.setLocal("s",u.i32_const(1)),u.block(u.loop(u.br_if(1,u.i32_gt_u(u.getLocal("s"),u.getLocal("bits"))),u.setLocal("m",u.i32_shl(u.i32_const(1),u.getLocal("s"))),u.setLocal("pwm",u.i32_add(u.i32_const(A),u.i32_mul(u.getLocal("s"),u.i32_const(s)))),u.setLocal("k",u.i32_const(0)),u.block(u.loop(u.br_if(1,u.i32_ge_u(u.getLocal("k"),u.getLocal("n"))),u.call(i+"_one",x),u.setLocal("mdiv2",u.i32_shr_u(u.getLocal("m"),u.i32_const(1))),u.setLocal("j",u.i32_const(0)),u.block(u.loop(u.br_if(1,u.i32_ge_u(u.getLocal("j"),u.getLocal("mdiv2"))),u.setLocal("idx1",u.i32_add(u.getLocal("px"),u.i32_mul(u.i32_add(u.getLocal("k"),u.getLocal("j")),u.i32_const(d)))),u.setLocal("idx2",u.i32_add(u.getLocal("idx1"),u.i32_mul(u.getLocal("mdiv2"),u.i32_const(d)))),u.call(e,u.getLocal("idx2"),x,F),u.call(a+"_copy",u.getLocal("idx1"),p),u.call(a+"_add",p,F,u.getLocal("idx1")),u.call(a+"_sub",p,F,u.getLocal("idx2")),u.call(i+"_mul",x,u.getLocal("pwm"),x),u.setLocal("j",u.i32_add(u.getLocal("j"),u.i32_const(1))),u.br(0))),u.setLocal("k",u.i32_add(u.getLocal("k"),u.getLocal("m"))),u.br(0))),u.setLocal("s",u.i32_add(u.getLocal("s"),u.i32_const(1))),u.br(0))),u.call(n+"__fftFinal",u.getLocal("px"),u.getLocal("bits"),u.getLocal("reverse"),u.getLocal("mulFactor")))}function V(){const C=t.addFunction(n+"__fftFinal");C.addParam("px","i32"),C.addParam("bits","i32"),C.addParam("reverse","i32"),C.addParam("mulFactor","i32"),C.addLocal("n","i32"),C.addLocal("ndiv2","i32"),C.addLocal("pInv2","i32"),C.addLocal("i","i32"),C.addLocal("mask","i32"),C.addLocal("idx1","i32"),C.addLocal("idx2","i32");const u=C.getCodeBuilder(),x=u.i32_const(t.alloc(d));C.addCode(u.if(u.i32_and(u.i32_eqz(u.getLocal("reverse")),u.call(i+"_isOne",u.getLocal("mulFactor"))),u.ret([])),u.setLocal("n",u.i32_shl(u.i32_const(1),u.getLocal("bits"))),u.setLocal("mask",u.i32_sub(u.getLocal("n"),u.i32_const(1))),u.setLocal("i",u.i32_const(1)),u.setLocal("ndiv2",u.i32_shr_u(u.getLocal("n"),u.i32_const(1))),u.block(u.loop(u.br_if(1,u.i32_ge_u(u.getLocal("i"),u.getLocal("ndiv2"))),u.setLocal("idx1",u.i32_add(u.getLocal("px"),u.i32_mul(u.getLocal("i"),u.i32_const(d)))),u.setLocal("idx2",u.i32_add(u.getLocal("px"),u.i32_mul(u.i32_sub(u.getLocal("n"),u.getLocal("i")),u.i32_const(d)))),u.if(u.getLocal("reverse"),u.if(u.call(i+"_isOne",u.getLocal("mulFactor")),[...u.call(a+"_copy",u.getLocal("idx1"),x),...u.call(a+"_copy",u.getLocal("idx2"),u.getLocal("idx1")),...u.call(a+"_copy",x,u.getLocal("idx2"))],[...u.call(a+"_copy",u.getLocal("idx1"),x),...u.call(e,u.getLocal("idx2"),u.getLocal("mulFactor"),u.getLocal("idx1")),...u.call(e,x,u.getLocal("mulFactor"),u.getLocal("idx2"))]),u.if(u.call(i+"_isOne",u.getLocal("mulFactor")),[],[...u.call(e,u.getLocal("idx1"),u.getLocal("mulFactor"),u.getLocal("idx1")),...u.call(e,u.getLocal("idx2"),u.getLocal("mulFactor"),u.getLocal("idx2"))])),u.setLocal("i",u.i32_add(u.getLocal("i"),u.i32_const(1))),u.br(0))),u.if(u.call(i+"_isOne",u.getLocal("mulFactor")),[],[...u.call(e,u.getLocal("px"),u.getLocal("mulFactor"),u.getLocal("px")),...u.setLocal("idx2",u.i32_add(u.getLocal("px"),u.i32_mul(u.getLocal("ndiv2"),u.i32_const(d)))),...u.call(e,u.getLocal("idx2"),u.getLocal("mulFactor"),u.getLocal("idx2"))]))}function nt(){const C=t.addFunction(n+"__reversePermutation");C.addParam("px","i32"),C.addParam("bits","i32"),C.addLocal("n","i32"),C.addLocal("i","i32"),C.addLocal("ri","i32"),C.addLocal("idx1","i32"),C.addLocal("idx2","i32");const u=C.getCodeBuilder(),x=u.i32_const(t.alloc(d));C.addCode(u.setLocal("n",u.i32_shl(u.i32_const(1),u.getLocal("bits"))),u.setLocal("i",u.i32_const(0)),u.block(u.loop(u.br_if(1,u.i32_eq(u.getLocal("i"),u.getLocal("n"))),u.setLocal("idx1",u.i32_add(u.getLocal("px"),u.i32_mul(u.getLocal("i"),u.i32_const(d)))),u.setLocal("ri",u.call(n+"__rev",u.getLocal("i"),u.getLocal("bits"))),u.setLocal("idx2",u.i32_add(u.getLocal("px"),u.i32_mul(u.getLocal("ri"),u.i32_const(d)))),u.if(u.i32_lt_u(u.getLocal("i"),u.getLocal("ri")),[...u.call(a+"_copy",u.getLocal("idx1"),x),...u.call(a+"_copy",u.getLocal("idx2"),u.getLocal("idx1")),...u.call(a+"_copy",x,u.getLocal("idx2"))]),u.setLocal("i",u.i32_add(u.getLocal("i"),u.i32_const(1))),u.br(0))))}function Q(){const C=t.addFunction(n+"__rev");C.addParam("x","i32"),C.addParam("bits","i32"),C.setReturnType("i32");const u=C.getCodeBuilder();C.addCode(u.i32_rotl(u.i32_add(u.i32_add(u.i32_shl(u.i32_load8_u(u.i32_and(u.getLocal("x"),u.i32_const(255)),S,0),u.i32_const(24)),u.i32_shl(u.i32_load8_u(u.i32_and(u.i32_shr_u(u.getLocal("x"),u.i32_const(8)),u.i32_const(255)),S,0),u.i32_const(16))),u.i32_add(u.i32_shl(u.i32_load8_u(u.i32_and(u.i32_shr_u(u.getLocal("x"),u.i32_const(16)),u.i32_const(255)),S,0),u.i32_const(8)),u.i32_load8_u(u.i32_and(u.i32_shr_u(u.getLocal("x"),u.i32_const(24)),u.i32_const(255)),S,0))),u.getLocal("bits")))}function it(){const C=t.addFunction(n+"_fftJoin");C.addParam("pBuff1","i32"),C.addParam("pBuff2","i32"),C.addParam("n","i32"),C.addParam("first","i32"),C.addParam("inc","i32"),C.addLocal("idx1","i32"),C.addLocal("idx2","i32"),C.addLocal("i","i32");const u=C.getCodeBuilder(),x=u.i32_const(t.alloc(s)),F=u.i32_const(t.alloc(d)),p=u.i32_const(t.alloc(d));C.addCode(u.call(i+"_copy",u.getLocal("first"),x),u.setLocal("i",u.i32_const(0)),u.block(u.loop(u.br_if(1,u.i32_eq(u.getLocal("i"),u.getLocal("n"))),u.setLocal("idx1",u.i32_add(u.getLocal("pBuff1"),u.i32_mul(u.getLocal("i"),u.i32_const(d)))),u.setLocal("idx2",u.i32_add(u.getLocal("pBuff2"),u.i32_mul(u.getLocal("i"),u.i32_const(d)))),u.call(e,u.getLocal("idx2"),x,F),u.call(a+"_copy",u.getLocal("idx1"),p),u.call(a+"_add",p,F,u.getLocal("idx1")),u.call(a+"_sub",p,F,u.getLocal("idx2")),u.call(i+"_mul",x,u.getLocal("inc"),x),u.setLocal("i",u.i32_add(u.getLocal("i"),u.i32_const(1))),u.br(0))))}function X(){const C=t.addFunction(n+"_fftJoinExt");C.addParam("pBuff1","i32"),C.addParam("pBuff2","i32"),C.addParam("n","i32"),C.addParam("first","i32"),C.addParam("inc","i32"),C.addParam("totalBits","i32"),C.addLocal("idx1","i32"),C.addLocal("idx2","i32"),C.addLocal("i","i32"),C.addLocal("pShiftToM","i32");const u=C.getCodeBuilder(),x=u.i32_const(t.alloc(s)),F=u.i32_const(t.alloc(d));C.addCode(u.setLocal("pShiftToM",u.i32_add(u.i32_const($),u.i32_mul(u.getLocal("totalBits"),u.i32_const(s)))),u.call(i+"_copy",u.getLocal("first"),x),u.setLocal("i",u.i32_const(0)),u.block(u.loop(u.br_if(1,u.i32_eq(u.getLocal("i"),u.getLocal("n"))),u.setLocal("idx1",u.i32_add(u.getLocal("pBuff1"),u.i32_mul(u.getLocal("i"),u.i32_const(d)))),u.setLocal("idx2",u.i32_add(u.getLocal("pBuff2"),u.i32_mul(u.getLocal("i"),u.i32_const(d)))),u.call(a+"_add",u.getLocal("idx1"),u.getLocal("idx2"),F),u.call(e,u.getLocal("idx2"),u.getLocal("pShiftToM"),u.getLocal("idx2")),u.call(a+"_add",u.getLocal("idx1"),u.getLocal("idx2"),u.getLocal("idx2")),u.call(e,u.getLocal("idx2"),x,u.getLocal("idx2")),u.call(a+"_copy",F,u.getLocal("idx1")),u.call(i+"_mul",x,u.getLocal("inc"),x),u.setLocal("i",u.i32_add(u.getLocal("i"),u.i32_const(1))),u.br(0))))}function k(){const C=t.addFunction(n+"_fftJoinExtInv");C.addParam("pBuff1","i32"),C.addParam("pBuff2","i32"),C.addParam("n","i32"),C.addParam("first","i32"),C.addParam("inc","i32"),C.addParam("totalBits","i32"),C.addLocal("idx1","i32"),C.addLocal("idx2","i32"),C.addLocal("i","i32"),C.addLocal("pShiftToM","i32"),C.addLocal("pSConst","i32");const u=C.getCodeBuilder(),x=u.i32_const(t.alloc(s)),F=u.i32_const(t.alloc(d));C.addCode(u.setLocal("pShiftToM",u.i32_add(u.i32_const($),u.i32_mul(u.getLocal("totalBits"),u.i32_const(s)))),u.setLocal("pSConst",u.i32_add(u.i32_const(K),u.i32_mul(u.getLocal("totalBits"),u.i32_const(s)))),u.call(i+"_copy",u.getLocal("first"),x),u.setLocal("i",u.i32_const(0)),u.block(u.loop(u.br_if(1,u.i32_eq(u.getLocal("i"),u.getLocal("n"))),u.setLocal("idx1",u.i32_add(u.getLocal("pBuff1"),u.i32_mul(u.getLocal("i"),u.i32_const(d)))),u.setLocal("idx2",u.i32_add(u.getLocal("pBuff2"),u.i32_mul(u.getLocal("i"),u.i32_const(d)))),u.call(e,u.getLocal("idx2"),x,F),u.call(a+"_sub",u.getLocal("idx1"),F,u.getLocal("idx2")),u.call(e,u.getLocal("idx2"),u.getLocal("pSConst"),u.getLocal("idx2")),u.call(e,u.getLocal("idx1"),u.getLocal("pShiftToM"),u.getLocal("idx1")),u.call(a+"_sub",F,u.getLocal("idx1"),u.getLocal("idx1")),u.call(e,u.getLocal("idx1"),u.getLocal("pSConst"),u.getLocal("idx1")),u.call(i+"_mul",x,u.getLocal("inc"),x),u.setLocal("i",u.i32_add(u.getLocal("i"),u.i32_const(1))),u.br(0))))}function J(){const C=t.addFunction(n+"_prepareLagrangeEvaluation");C.addParam("pBuff1","i32"),C.addParam("pBuff2","i32"),C.addParam("n","i32"),C.addParam("first","i32"),C.addParam("inc","i32"),C.addParam("totalBits","i32"),C.addLocal("idx1","i32"),C.addLocal("idx2","i32"),C.addLocal("i","i32"),C.addLocal("pShiftToM","i32"),C.addLocal("pSConst","i32");const u=C.getCodeBuilder(),x=u.i32_const(t.alloc(s)),F=u.i32_const(t.alloc(d));C.addCode(u.setLocal("pShiftToM",u.i32_add(u.i32_const($),u.i32_mul(u.getLocal("totalBits"),u.i32_const(s)))),u.setLocal("pSConst",u.i32_add(u.i32_const(K),u.i32_mul(u.getLocal("totalBits"),u.i32_const(s)))),u.call(i+"_copy",u.getLocal("first"),x),u.setLocal("i",u.i32_const(0)),u.block(u.loop(u.br_if(1,u.i32_eq(u.getLocal("i"),u.getLocal("n"))),u.setLocal("idx1",u.i32_add(u.getLocal("pBuff1"),u.i32_mul(u.getLocal("i"),u.i32_const(d)))),u.setLocal("idx2",u.i32_add(u.getLocal("pBuff2"),u.i32_mul(u.getLocal("i"),u.i32_const(d)))),u.call(e,u.getLocal("idx1"),u.getLocal("pShiftToM"),F),u.call(a+"_sub",u.getLocal("idx2"),F,F),u.call(a+"_sub",u.getLocal("idx1"),u.getLocal("idx2"),u.getLocal("idx2")),u.call(e,F,u.getLocal("pSConst"),u.getLocal("idx1")),u.call(e,u.getLocal("idx2"),x,u.getLocal("idx2")),u.call(i+"_mul",x,u.getLocal("inc"),x),u.setLocal("i",u.i32_add(u.getLocal("i"),u.i32_const(1))),u.br(0))))}function m(){const C=t.addFunction(n+"_fftMix");C.addParam("pBuff","i32"),C.addParam("n","i32"),C.addParam("exp","i32"),C.addLocal("nGroups","i32"),C.addLocal("nPerGroup","i32"),C.addLocal("nPerGroupDiv2","i32"),C.addLocal("pairOffset","i32"),C.addLocal("idx1","i32"),C.addLocal("idx2","i32"),C.addLocal("i","i32"),C.addLocal("j","i32"),C.addLocal("pwm","i32");const u=C.getCodeBuilder(),x=u.i32_const(t.alloc(s)),F=u.i32_const(t.alloc(d)),p=u.i32_const(t.alloc(d));C.addCode(u.setLocal("nPerGroup",u.i32_shl(u.i32_const(1),u.getLocal("exp"))),u.setLocal("nPerGroupDiv2",u.i32_shr_u(u.getLocal("nPerGroup"),u.i32_const(1))),u.setLocal("nGroups",u.i32_shr_u(u.getLocal("n"),u.getLocal("exp"))),u.setLocal("pairOffset",u.i32_mul(u.getLocal("nPerGroupDiv2"),u.i32_const(d))),u.setLocal("pwm",u.i32_add(u.i32_const(A),u.i32_mul(u.getLocal("exp"),u.i32_const(s)))),u.setLocal("i",u.i32_const(0)),u.block(u.loop(u.br_if(1,u.i32_eq(u.getLocal("i"),u.getLocal("nGroups"))),u.call(i+"_one",x),u.setLocal("j",u.i32_const(0)),u.block(u.loop(u.br_if(1,u.i32_eq(u.getLocal("j"),u.getLocal("nPerGroupDiv2"))),u.setLocal("idx1",u.i32_add(u.getLocal("pBuff"),u.i32_mul(u.i32_add(u.i32_mul(u.getLocal("i"),u.getLocal("nPerGroup")),u.getLocal("j")),u.i32_const(d)))),u.setLocal("idx2",u.i32_add(u.getLocal("idx1"),u.getLocal("pairOffset"))),u.call(e,u.getLocal("idx2"),x,F),u.call(a+"_copy",u.getLocal("idx1"),p),u.call(a+"_add",p,F,u.getLocal("idx1")),u.call(a+"_sub",p,F,u.getLocal("idx2")),u.call(i+"_mul",x,u.getLocal("pwm"),x),u.setLocal("j",u.i32_add(u.getLocal("j"),u.i32_const(1))),u.br(0))),u.setLocal("i",u.i32_add(u.getLocal("i"),u.i32_const(1))),u.br(0))))}function r(){const C=t.addFunction(n+"_fftFinal");C.addParam("pBuff","i32"),C.addParam("n","i32"),C.addParam("factor","i32"),C.addLocal("idx1","i32"),C.addLocal("idx2","i32"),C.addLocal("i","i32"),C.addLocal("ndiv2","i32");const u=C.getCodeBuilder(),x=u.i32_const(t.alloc(d));C.addCode(u.setLocal("ndiv2",u.i32_shr_u(u.getLocal("n"),u.i32_const(1))),u.if(u.i32_and(u.getLocal("n"),u.i32_const(1)),u.call(e,u.i32_add(u.getLocal("pBuff"),u.i32_mul(u.getLocal("ndiv2"),u.i32_const(d))),u.getLocal("factor"),u.i32_add(u.getLocal("pBuff"),u.i32_mul(u.getLocal("ndiv2"),u.i32_const(d))))),u.setLocal("i",u.i32_const(0)),u.block(u.loop(u.br_if(1,u.i32_ge_u(u.getLocal("i"),u.getLocal("ndiv2"))),u.setLocal("idx1",u.i32_add(u.getLocal("pBuff"),u.i32_mul(u.getLocal("i"),u.i32_const(d)))),u.setLocal("idx2",u.i32_add(u.getLocal("pBuff"),u.i32_mul(u.i32_sub(u.i32_sub(u.getLocal("n"),u.i32_const(1)),u.getLocal("i")),u.i32_const(d)))),u.call(e,u.getLocal("idx2"),u.getLocal("factor"),x),u.call(e,u.getLocal("idx1"),u.getLocal("factor"),u.getLocal("idx2")),u.call(a+"_copy",x,u.getLocal("idx1")),u.setLocal("i",u.i32_add(u.getLocal("i"),u.i32_const(1))),u.br(0))))}Q(),nt(),V(),Y(),z(),q(),Z(),it(),X(),k(),m(),r(),J(),t.exportFunction(n+"_fft"),t.exportFunction(n+"_ifft"),t.exportFunction(n+"_rawfft"),t.exportFunction(n+"_fftJoin"),t.exportFunction(n+"_fftJoinExt"),t.exportFunction(n+"_fftJoinExtInv"),t.exportFunction(n+"_fftMix"),t.exportFunction(n+"_fftFinal"),t.exportFunction(n+"_prepareLagrangeEvaluation")},No=function(t,n,a){const e=t.modules[a].n64*8;function l(){const h=t.addFunction(n+"_zero");h.addParam("px","i32"),h.addParam("n","i32"),h.addLocal("lastp","i32"),h.addLocal("p","i32");const d=h.getCodeBuilder();h.addCode(d.setLocal("p",d.getLocal("px")),d.setLocal("lastp",d.i32_add(d.getLocal("px"),d.i32_mul(d.getLocal("n"),d.i32_const(e)))),d.block(d.loop(d.br_if(1,d.i32_eq(d.getLocal("p"),d.getLocal("lastp"))),d.call(a+"_zero",d.getLocal("p")),d.setLocal("p",d.i32_add(d.getLocal("p"),d.i32_const(e))),d.br(0))))}function s(){const h=t.addFunction(n+"_constructLC");h.addParam("ppolynomials","i32"),h.addParam("psignals","i32"),h.addParam("nSignals","i32"),h.addParam("pres","i32"),h.addLocal("i","i32"),h.addLocal("j","i32"),h.addLocal("pp","i32"),h.addLocal("ps","i32"),h.addLocal("pd","i32"),h.addLocal("ncoefs","i32");const d=h.getCodeBuilder(),c=d.i32_const(t.alloc(e));h.addCode(d.setLocal("i",d.i32_const(0)),d.setLocal("pp",d.getLocal("ppolynomials")),d.setLocal("ps",d.getLocal("psignals")),d.block(d.loop(d.br_if(1,d.i32_eq(d.getLocal("i"),d.getLocal("nSignals"))),d.setLocal("ncoefs",d.i32_load(d.getLocal("pp"))),d.setLocal("pp",d.i32_add(d.getLocal("pp"),d.i32_const(4))),d.setLocal("j",d.i32_const(0)),d.block(d.loop(d.br_if(1,d.i32_eq(d.getLocal("j"),d.getLocal("ncoefs"))),d.setLocal("pd",d.i32_add(d.getLocal("pres"),d.i32_mul(d.i32_load(d.getLocal("pp")),d.i32_const(e)))),d.setLocal("pp",d.i32_add(d.getLocal("pp"),d.i32_const(4))),d.call(a+"_mul",d.getLocal("ps"),d.getLocal("pp"),c),d.call(a+"_add",c,d.getLocal("pd"),d.getLocal("pd")),d.setLocal("pp",d.i32_add(d.getLocal("pp"),d.i32_const(e))),d.setLocal("j",d.i32_add(d.getLocal("j"),d.i32_const(1))),d.br(0))),d.setLocal("ps",d.i32_add(d.getLocal("ps"),d.i32_const(e))),d.setLocal("i",d.i32_add(d.getLocal("i"),d.i32_const(1))),d.br(0))))}return l(),s(),t.exportFunction(n+"_zero"),t.exportFunction(n+"_constructLC"),n},Do=function(t,n,a){const e=t.modules[a].n64*8;function l(){const d=t.addFunction(n+"_buildABC");d.addParam("pCoefs","i32"),d.addParam("nCoefs","i32"),d.addParam("pWitness","i32"),d.addParam("pA","i32"),d.addParam("pB","i32"),d.addParam("pC","i32"),d.addParam("offsetOut","i32"),d.addParam("nOut","i32"),d.addParam("offsetWitness","i32"),d.addParam("nWitness","i32"),d.addLocal("it","i32"),d.addLocal("ita","i32"),d.addLocal("itb","i32"),d.addLocal("last","i32"),d.addLocal("m","i32"),d.addLocal("c","i32"),d.addLocal("s","i32"),d.addLocal("pOut","i32");const c=d.getCodeBuilder(),f=c.i32_const(t.alloc(e));d.addCode(c.setLocal("ita",c.getLocal("pA")),c.setLocal("itb",c.getLocal("pB")),c.setLocal("last",c.i32_add(c.getLocal("pA"),c.i32_mul(c.getLocal("nOut"),c.i32_const(e)))),c.block(c.loop(c.br_if(1,c.i32_eq(c.getLocal("ita"),c.getLocal("last"))),c.call(a+"_zero",c.getLocal("ita")),c.call(a+"_zero",c.getLocal("itb")),c.setLocal("ita",c.i32_add(c.getLocal("ita"),c.i32_const(e))),c.setLocal("itb",c.i32_add(c.getLocal("itb"),c.i32_const(e))),c.br(0))),c.setLocal("it",c.getLocal("pCoefs")),c.setLocal("last",c.i32_add(c.getLocal("pCoefs"),c.i32_mul(c.getLocal("nCoefs"),c.i32_const(e+12)))),c.block(c.loop(c.br_if(1,c.i32_eq(c.getLocal("it"),c.getLocal("last"))),c.setLocal("s",c.i32_load(c.getLocal("it"),8)),c.if(c.i32_or(c.i32_lt_u(c.getLocal("s"),c.getLocal("offsetWitness")),c.i32_ge_u(c.getLocal("s"),c.i32_add(c.getLocal("offsetWitness"),c.getLocal("nWitness")))),[...c.setLocal("it",c.i32_add(c.getLocal("it"),c.i32_const(e+12))),...c.br(1)]),c.setLocal("m",c.i32_load(c.getLocal("it"))),c.if(c.i32_eq(c.getLocal("m"),c.i32_const(0)),c.setLocal("pOut",c.getLocal("pA")),c.if(c.i32_eq(c.getLocal("m"),c.i32_const(1)),c.setLocal("pOut",c.getLocal("pB")),[...c.setLocal("it",c.i32_add(c.getLocal("it"),c.i32_const(e+12))),...c.br(1)])),c.setLocal("c",c.i32_load(c.getLocal("it"),4)),c.if(c.i32_or(c.i32_lt_u(c.getLocal("c"),c.getLocal("offsetOut")),c.i32_ge_u(c.getLocal("c"),c.i32_add(c.getLocal("offsetOut"),c.getLocal("nOut")))),[...c.setLocal("it",c.i32_add(c.getLocal("it"),c.i32_const(e+12))),...c.br(1)]),c.setLocal("pOut",c.i32_add(c.getLocal("pOut"),c.i32_mul(c.i32_sub(c.getLocal("c"),c.getLocal("offsetOut")),c.i32_const(e)))),c.call(a+"_mul",c.i32_add(c.getLocal("pWitness"),c.i32_mul(c.i32_sub(c.getLocal("s"),c.getLocal("offsetWitness")),c.i32_const(e))),c.i32_add(c.getLocal("it"),c.i32_const(12)),f),c.call(a+"_add",c.getLocal("pOut"),f,c.getLocal("pOut")),c.setLocal("it",c.i32_add(c.getLocal("it"),c.i32_const(e+12))),c.br(0))),c.setLocal("ita",c.getLocal("pA")),c.setLocal("itb",c.getLocal("pB")),c.setLocal("it",c.getLocal("pC")),c.setLocal("last",c.i32_add(c.getLocal("pA"),c.i32_mul(c.getLocal("nOut"),c.i32_const(e)))),c.block(c.loop(c.br_if(1,c.i32_eq(c.getLocal("ita"),c.getLocal("last"))),c.call(a+"_mul",c.getLocal("ita"),c.getLocal("itb"),c.getLocal("it")),c.setLocal("ita",c.i32_add(c.getLocal("ita"),c.i32_const(e))),c.setLocal("itb",c.i32_add(c.getLocal("itb"),c.i32_const(e))),c.setLocal("it",c.i32_add(c.getLocal("it"),c.i32_const(e))),c.br(0))))}function s(){const d=t.addFunction(n+"_joinABC");d.addParam("pA","i32"),d.addParam("pB","i32"),d.addParam("pC","i32"),d.addParam("n","i32"),d.addParam("pP","i32"),d.addLocal("ita","i32"),d.addLocal("itb","i32"),d.addLocal("itc","i32"),d.addLocal("itp","i32"),d.addLocal("last","i32");const c=d.getCodeBuilder(),f=c.i32_const(t.alloc(e));d.addCode(c.setLocal("ita",c.getLocal("pA")),c.setLocal("itb",c.getLocal("pB")),c.setLocal("itc",c.getLocal("pC")),c.setLocal("itp",c.getLocal("pP")),c.setLocal("last",c.i32_add(c.getLocal("pA"),c.i32_mul(c.getLocal("n"),c.i32_const(e)))),c.block(c.loop(c.br_if(1,c.i32_eq(c.getLocal("ita"),c.getLocal("last"))),c.call(a+"_mul",c.getLocal("ita"),c.getLocal("itb"),f),c.call(a+"_sub",f,c.getLocal("itc"),c.getLocal("itp")),c.setLocal("ita",c.i32_add(c.getLocal("ita"),c.i32_const(e))),c.setLocal("itb",c.i32_add(c.getLocal("itb"),c.i32_const(e))),c.setLocal("itc",c.i32_add(c.getLocal("itc"),c.i32_const(e))),c.setLocal("itp",c.i32_add(c.getLocal("itp"),c.i32_const(e))),c.br(0))))}function h(){const d=t.addFunction(n+"_batchAdd");d.addParam("pa","i32"),d.addParam("pb","i32"),d.addParam("n","i32"),d.addParam("pr","i32"),d.addLocal("ita","i32"),d.addLocal("itb","i32"),d.addLocal("itr","i32"),d.addLocal("last","i32");const c=d.getCodeBuilder();d.addCode(c.setLocal("ita",c.getLocal("pa")),c.setLocal("itb",c.getLocal("pb")),c.setLocal("itr",c.getLocal("pr")),c.setLocal("last",c.i32_add(c.getLocal("pa"),c.i32_mul(c.getLocal("n"),c.i32_const(e)))),c.block(c.loop(c.br_if(1,c.i32_eq(c.getLocal("ita"),c.getLocal("last"))),c.call(a+"_add",c.getLocal("ita"),c.getLocal("itb"),c.getLocal("itr")),c.setLocal("ita",c.i32_add(c.getLocal("ita"),c.i32_const(e))),c.setLocal("itb",c.i32_add(c.getLocal("itb"),c.i32_const(e))),c.setLocal("itr",c.i32_add(c.getLocal("itr"),c.i32_const(e))),c.br(0))))}return l(),s(),h(),t.exportFunction(n+"_buildABC"),t.exportFunction(n+"_joinABC"),t.exportFunction(n+"_batchAdd"),n},Vo=function(t,n,a,i,e,l,s,h){const d=t.addFunction(n);d.addParam("pIn","i32"),d.addParam("n","i32"),d.addParam("pFirst","i32"),d.addParam("pInc","i32"),d.addParam("pOut","i32"),d.addLocal("pOldFree","i32"),d.addLocal("i","i32"),d.addLocal("pFrom","i32"),d.addLocal("pTo","i32");const c=d.getCodeBuilder(),f=c.i32_const(t.alloc(s));d.addCode(c.setLocal("pFrom",c.getLocal("pIn")),c.setLocal("pTo",c.getLocal("pOut"))),d.addCode(c.call(i+"_copy",c.getLocal("pFirst"),f)),d.addCode(c.setLocal("i",c.i32_const(0)),c.block(c.loop(c.br_if(1,c.i32_eq(c.getLocal("i"),c.getLocal("n"))),c.call(h,c.getLocal("pFrom"),f,c.getLocal("pTo")),c.setLocal("pFrom",c.i32_add(c.getLocal("pFrom"),c.i32_const(e))),c.setLocal("pTo",c.i32_add(c.getLocal("pTo"),c.i32_const(l))),c.call(i+"_mul",f,c.getLocal("pInc"),f),c.setLocal("i",c.i32_add(c.getLocal("i"),c.i32_const(1))),c.br(0)))),t.exportFunction(n)};const zt=Nn,Mc=_e,zc=qo,Oe=Qo,qc=Ro,Ue=ko,gi=$o,Qc=No,Rc=Do,ba=Vo,{bitLength:kc,modInv:$c,isOdd:Me,isNegative:Nc}=un;var Dc=function(t,n){const a=n||"bn128";if(t.modules[a])return a;const i=21888242871839275222246405745257275088696311157297823662689037894645226208583n,e=21888242871839275222246405745257275088548364400416034343698204186575808495617n,l=Math.floor((kc(i-1n)-1)/64)+1,s=l*8,h=s,d=s,c=d*2,f=d*12,y=t.alloc(zt.bigInt2BytesLE(e,h)),L=Mc(t,i,"f1m");zc(t,e,"fr","frm");const v=t.alloc(zt.bigInt2BytesLE(P(3n),d)),T=Ue(t,"g1m","f1m",v);gi(t,"frm","frm","frm","frm_mul"),Qc(t,"pol","frm"),Rc(t,"qap","frm");const B=Oe(t,"f1m_neg","f2m","f1m"),E=t.alloc([...zt.bigInt2BytesLE(P(19485874751759354771024239261021720505790618469301721065564631296452457478373n),d),...zt.bigInt2BytesLE(P(266929791119991161246907387137283842545076965332900288569378510910307636690n),d)]),A=Ue(t,"g2m","f2m",E);function G(ot,g){const w=t.addFunction(ot);w.addParam("pG","i32"),w.addParam("pFr","i32"),w.addParam("pr","i32");const W=w.getCodeBuilder(),at=W.i32_const(t.alloc(s));w.addCode(W.call("frm_fromMontgomery",W.getLocal("pFr"),at),W.call(g,W.getLocal("pG"),at,W.i32_const(s),W.getLocal("pr"))),t.exportFunction(ot)}G("g1m_timesFr","g1m_timesScalar"),gi(t,"g1m","g1m","frm","g1m_timesFr"),G("g2m_timesFr","g2m_timesScalar"),gi(t,"g2m","g2m","frm","g2m_timesFr"),G("g1m_timesFrAffine","g1m_timesScalarAffine"),G("g2m_timesFrAffine","g2m_timesScalarAffine"),ba(t,"frm_batchApplyKey","fmr","frm",s,s,s,"frm_mul"),ba(t,"g1m_batchApplyKey","g1m","frm",s*3,s*3,s,"g1m_timesFr"),ba(t,"g1m_batchApplyKeyMixed","g1m","frm",s*2,s*3,s,"g1m_timesFrAffine"),ba(t,"g2m_batchApplyKey","g2m","frm",s*2*3,s*3*2,s,"g2m_timesFr"),ba(t,"g2m_batchApplyKeyMixed","g2m","frm",s*2*2,s*3*2,s,"g2m_timesFrAffine");function P(ot){return BigInt(ot)*(1n<<BigInt(d*8))%i}const U=[1n,2n,1n],I=t.alloc([...zt.bigInt2BytesLE(P(U[0]),d),...zt.bigInt2BytesLE(P(U[1]),d),...zt.bigInt2BytesLE(P(U[2]),d)]),_=[0n,1n,0n],b=t.alloc([...zt.bigInt2BytesLE(P(_[0]),d),...zt.bigInt2BytesLE(P(_[1]),d),...zt.bigInt2BytesLE(P(_[2]),d)]),$=[[10857046999023057135944570762232829481370756359578518086990519993285655852781n,11559732032986387107991004021392285783925812861821192530917403151452391805634n],[8495653923123431417604973247489272438418190587263600148770280649306958101930n,4082367875863433681332203403145435568316851327593401208105741076214120093531n],[1n,0n]],K=t.alloc([...zt.bigInt2BytesLE(P($[0][0]),d),...zt.bigInt2BytesLE(P($[0][1]),d),...zt.bigInt2BytesLE(P($[1][0]),d),...zt.bigInt2BytesLE(P($[1][1]),d),...zt.bigInt2BytesLE(P($[2][0]),d),...zt.bigInt2BytesLE(P($[2][1]),d)]),j=[[0n,0n],[1n,0n],[0n,0n]],M=t.alloc([...zt.bigInt2BytesLE(P(j[0][0]),d),...zt.bigInt2BytesLE(P(j[0][1]),d),...zt.bigInt2BytesLE(P(j[1][0]),d),...zt.bigInt2BytesLE(P(j[1][1]),d),...zt.bigInt2BytesLE(P(j[2][0]),d),...zt.bigInt2BytesLE(P(j[2][1]),d)]),S=t.alloc([...zt.bigInt2BytesLE(P(1),d),...zt.bigInt2BytesLE(P(0),d),...zt.bigInt2BytesLE(P(0),d),...zt.bigInt2BytesLE(P(0),d),...zt.bigInt2BytesLE(P(0),d),...zt.bigInt2BytesLE(P(0),d),...zt.bigInt2BytesLE(P(0),d),...zt.bigInt2BytesLE(P(0),d),...zt.bigInt2BytesLE(P(0),d),...zt.bigInt2BytesLE(P(0),d),...zt.bigInt2BytesLE(P(0),d),...zt.bigInt2BytesLE(P(0),d)]),z=t.alloc([...zt.bigInt2BytesLE(P(9),d),...zt.bigInt2BytesLE(P(1),d)]),q=t.alloc([...zt.bigInt2BytesLE(P($c(2n,i)),d),...zt.bigInt2BytesLE(0n,d)]),Z=z,Y=t.alloc([...zt.bigInt2BytesLE(P(19485874751759354771024239261021720505790618469301721065564631296452457478373n),d),...zt.bigInt2BytesLE(P(266929791119991161246907387137283842545076965332900288569378510910307636690n),d)]);function V(){const ot=t.addFunction(a+"_mulNR6");ot.addParam("x","i32"),ot.addParam("pr","i32");const g=ot.getCodeBuilder();ot.addCode(g.call(B+"_mul",g.i32_const(z),g.getLocal("x"),g.getLocal("pr")))}V();const nt=qc(t,a+"_mulNR6","f6m","f2m");function Q(){const ot=t.addFunction(a+"_mulNR12");ot.addParam("x","i32"),ot.addParam("pr","i32");const g=ot.getCodeBuilder();ot.addCode(g.call(B+"_mul",g.i32_const(z),g.i32_add(g.getLocal("x"),g.i32_const(s*4)),g.getLocal("pr")),g.call(B+"_copy",g.getLocal("x"),g.i32_add(g.getLocal("pr"),g.i32_const(s*2))),g.call(B+"_copy",g.i32_add(g.getLocal("x"),g.i32_const(s*2)),g.i32_add(g.getLocal("pr"),g.i32_const(s*4))))}Q();const it=Oe(t,a+"_mulNR12","ftm",nt),k=R(29793968203157093288n),J=t.alloc(k),m=3*c,r=k.length-1,u=k.reduce((ot,g)=>ot+(g!=0?1:0),0)+r+1,x=6*s,F=3*s*2+u*m;t.modules[a]={n64:l,pG1gen:I,pG1zero:b,pG1b:v,pG2gen:K,pG2zero:M,pG2b:E,pq:t.modules.f1m.pq,pr:y,pOneT:S,prePSize:x,preQSize:F,r:e.toString(),q:i.toString()};const p=4965661367192848881n;function O(ot){let g=ot;const w=[];for(;g>0n;){if(Me(g)){const W=2-Number(g%4n);w.push(W),g=g-BigInt(W)}else w.push(0);g=g>>1n}return w}function R(ot){let g=ot;const w=[];for(;g>0n;)Me(g)?w.push(1):w.push(0),g=g>>1n;return w}function N(){const ot=t.addFunction(a+"_prepareG1");ot.addParam("pP","i32"),ot.addParam("ppreP","i32");const g=ot.getCodeBuilder();ot.addCode(g.call(T+"_normalize",g.getLocal("pP"),g.getLocal("ppreP")))}function H(){const ot=t.addFunction(a+"_prepAddStep");ot.addParam("pQ","i32"),ot.addParam("pR","i32"),ot.addParam("pCoef","i32");const g=ot.getCodeBuilder(),w=g.getLocal("pQ"),W=g.i32_add(g.getLocal("pQ"),g.i32_const(c)),at=g.getLocal("pR"),D=g.i32_add(g.getLocal("pR"),g.i32_const(c)),et=g.i32_add(g.getLocal("pR"),g.i32_const(2*c)),tt=g.getLocal("pCoef"),rt=g.i32_add(g.getLocal("pCoef"),g.i32_const(c)),_t=g.i32_add(g.getLocal("pCoef"),g.i32_const(2*c)),gt=rt,dt=g.i32_const(t.alloc(c)),wt=g.i32_const(t.alloc(c)),It=g.i32_const(t.alloc(c)),Ct=g.i32_const(t.alloc(c)),mt=g.i32_const(t.alloc(c)),St=g.i32_const(t.alloc(c)),xt=g.i32_const(t.alloc(c));ot.addCode(g.call(B+"_mul",w,et,gt),g.call(B+"_sub",at,gt,gt),g.call(B+"_mul",W,et,dt),g.call(B+"_sub",D,dt,dt),g.call(B+"_square",gt,wt),g.call(B+"_square",dt,It),g.call(B+"_mul",gt,wt,Ct),g.call(B+"_mul",at,wt,mt),g.call(B+"_add",mt,mt,xt),g.call(B+"_mul",et,It,St),g.call(B+"_add",Ct,St,St),g.call(B+"_sub",St,xt,St),g.call(B+"_mul",gt,St,at),g.call(B+"_mul",Ct,D,D),g.call(B+"_sub",mt,St,xt),g.call(B+"_mul",dt,xt,xt),g.call(B+"_sub",xt,D,D),g.call(B+"_mul",et,Ct,et),g.call(B+"_mul",gt,W,xt),g.call(B+"_mul",dt,w,tt),g.call(B+"_sub",tt,xt,tt),g.call(B+"_mul",tt,g.i32_const(Z),tt),g.call(B+"_neg",dt,_t))}function lt(){const ot=t.addFunction(a+"_prepDblStep");ot.addParam("pR","i32"),ot.addParam("pCoef","i32");const g=ot.getCodeBuilder(),w=g.getLocal("pR"),W=g.i32_add(g.getLocal("pR"),g.i32_const(c)),at=g.i32_add(g.getLocal("pR"),g.i32_const(2*c)),D=g.getLocal("pCoef"),et=g.i32_add(g.getLocal("pCoef"),g.i32_const(c)),tt=g.i32_add(g.getLocal("pCoef"),g.i32_const(2*c)),rt=g.i32_const(t.alloc(c)),_t=g.i32_const(t.alloc(c)),gt=g.i32_const(t.alloc(c)),dt=g.i32_const(t.alloc(c)),wt=g.i32_const(t.alloc(c)),It=g.i32_const(t.alloc(c)),Ct=g.i32_const(t.alloc(c)),mt=g.i32_const(t.alloc(c)),St=g.i32_const(t.alloc(c)),xt=g.i32_const(t.alloc(c)),Qt=g.i32_const(t.alloc(c)),Gt=g.i32_const(t.alloc(c));ot.addCode(g.call(B+"_mul",W,g.i32_const(q),rt),g.call(B+"_mul",w,rt,rt),g.call(B+"_square",W,_t),g.call(B+"_square",at,gt),g.call(B+"_add",gt,gt,dt),g.call(B+"_add",dt,gt,dt),g.call(B+"_mul",g.i32_const(Y),dt,wt),g.call(B+"_add",wt,wt,It),g.call(B+"_add",wt,It,It),g.call(B+"_add",_t,It,Ct),g.call(B+"_mul",Ct,g.i32_const(q),Ct),g.call(B+"_add",_t,gt,Gt),g.call(B+"_add",W,at,mt),g.call(B+"_square",mt,mt),g.call(B+"_sub",mt,Gt,mt),g.call(B+"_sub",wt,_t,St),g.call(B+"_square",w,xt),g.call(B+"_square",wt,Qt),g.call(B+"_sub",_t,It,Gt),g.call(B+"_mul",rt,Gt,w),g.call(B+"_add",Qt,Qt,Gt),g.call(B+"_add",Qt,Gt,Gt),g.call(B+"_square",Ct,W),g.call(B+"_sub",W,Gt,W),g.call(B+"_mul",_t,mt,at),g.call(B+"_mul",g.i32_const(Z),St,D),g.call(B+"_neg",mt,et),g.call(B+"_add",xt,xt,tt),g.call(B+"_add",xt,tt,tt))}function ht(){const ot=t.addFunction(a+"_mulByQ");ot.addParam("p1","i32"),ot.addParam("pr","i32");const g=ot.getCodeBuilder(),w=g.getLocal("p1"),W=g.i32_add(g.getLocal("p1"),g.i32_const(c)),at=g.i32_add(g.getLocal("p1"),g.i32_const(c*2)),D=g.getLocal("pr"),et=g.i32_add(g.getLocal("pr"),g.i32_const(c)),tt=g.i32_add(g.getLocal("pr"),g.i32_const(c*2)),rt=g.i32_const(t.alloc([...zt.bigInt2BytesLE(P("21575463638280843010398324269430826099269044274347216827212613867836435027261"),d),...zt.bigInt2BytesLE(P("10307601595873709700152284273816112264069230130616436755625194854815875713954"),d)])),_t=g.i32_const(t.alloc([...zt.bigInt2BytesLE(P("2821565182194536844548159561693502659359617185244120367078079554186484126554"),d),...zt.bigInt2BytesLE(P("3505843767911556378687030309984248845540243509899259641013678093033130930403"),d)]));ot.addCode(g.call(B+"_conjugate",w,D),g.call(B+"_mul",rt,D,D),g.call(B+"_conjugate",W,et),g.call(B+"_mul",_t,et,et),g.call(B+"_conjugate",at,tt))}function pt(){ht();const ot=t.addFunction(a+"_prepareG2");ot.addParam("pQ","i32"),ot.addParam("ppreQ","i32"),ot.addLocal("pCoef","i32"),ot.addLocal("i","i32");const g=ot.getCodeBuilder(),w=g.getLocal("pQ"),W=t.alloc(c*3),at=g.i32_const(W),D=g.i32_const(W),et=g.i32_const(W+c),tt=g.i32_const(W+2*c),rt=g.i32_add(g.getLocal("ppreQ"),g.i32_const(0)),_t=g.i32_add(g.getLocal("ppreQ"),g.i32_const(c)),gt=t.alloc(c*3),dt=g.i32_const(gt),wt=t.alloc(c*3),It=g.i32_const(wt),Ct=g.i32_const(wt+c);ot.addCode(g.call(A+"_normalize",w,rt),g.call(B+"_copy",rt,D),g.call(B+"_copy",_t,et),g.call(B+"_one",tt)),ot.addCode(g.setLocal("pCoef",g.i32_add(g.getLocal("ppreQ"),g.i32_const(c*3))),g.setLocal("i",g.i32_const(k.length-2)),g.block(g.loop(g.call(a+"_prepDblStep",at,g.getLocal("pCoef")),g.setLocal("pCoef",g.i32_add(g.getLocal("pCoef"),g.i32_const(m))),g.if(g.i32_load8_s(g.getLocal("i"),J),[...g.call(a+"_prepAddStep",rt,at,g.getLocal("pCoef")),...g.setLocal("pCoef",g.i32_add(g.getLocal("pCoef"),g.i32_const(m)))]),g.br_if(1,g.i32_eqz(g.getLocal("i"))),g.setLocal("i",g.i32_sub(g.getLocal("i"),g.i32_const(1))),g.br(0)))),ot.addCode(g.call(a+"_mulByQ",rt,dt),g.call(a+"_mulByQ",dt,It)),ot.addCode(g.call(B+"_neg",Ct,Ct),g.call(a+"_prepAddStep",dt,at,g.getLocal("pCoef")),g.setLocal("pCoef",g.i32_add(g.getLocal("pCoef"),g.i32_const(m))),g.call(a+"_prepAddStep",It,at,g.getLocal("pCoef")),g.setLocal("pCoef",g.i32_add(g.getLocal("pCoef"),g.i32_const(m))))}function ut(){const ot=t.addFunction(a+"__mulBy024Old");ot.addParam("pEll0","i32"),ot.addParam("pEllVW","i32"),ot.addParam("pEllVV","i32"),ot.addParam("pR","i32");const g=ot.getCodeBuilder(),w=g.getLocal("pEll0"),W=g.getLocal("pEllVV"),at=g.getLocal("pEllVW"),D=g.getLocal("pR"),et=t.alloc(f),tt=g.i32_const(et),rt=g.i32_const(et),_t=g.i32_const(et+c),gt=g.i32_const(et+c*2),dt=g.i32_const(et+c*3),wt=g.i32_const(et+c*4),It=g.i32_const(et+c*5);ot.addCode(g.call(B+"_copy",w,rt),g.call(B+"_zero",_t),g.call(B+"_copy",W,gt),g.call(B+"_zero",dt),g.call(B+"_copy",at,wt),g.call(B+"_zero",It),g.call(it+"_mul",tt,D,D))}function st(){const ot=t.addFunction(a+"__mulBy024");ot.addParam("pEll0","i32"),ot.addParam("pEllVW","i32"),ot.addParam("pEllVV","i32"),ot.addParam("pR","i32");const g=ot.getCodeBuilder(),w=g.getLocal("pEll0"),W=g.getLocal("pEllVV"),at=g.getLocal("pEllVW"),D=g.getLocal("pR"),et=g.i32_add(g.getLocal("pR"),g.i32_const(2*s)),tt=g.i32_add(g.getLocal("pR"),g.i32_const(4*s)),rt=g.i32_add(g.getLocal("pR"),g.i32_const(6*s)),_t=g.i32_add(g.getLocal("pR"),g.i32_const(8*s)),gt=g.i32_add(g.getLocal("pR"),g.i32_const(10*s)),dt=g.i32_const(t.alloc(c)),wt=g.i32_const(t.alloc(c)),It=g.i32_const(t.alloc(c)),Ct=g.i32_const(t.alloc(c)),mt=g.i32_const(t.alloc(c)),St=g.i32_const(t.alloc(c)),xt=g.i32_const(t.alloc(c)),Qt=g.i32_const(t.alloc(c)),Gt=g.i32_const(t.alloc(c)),Pt=g.i32_const(t.alloc(c)),Et=g.i32_const(t.alloc(c));ot.addCode(g.call(B+"_mul",D,w,xt),g.call(B+"_mul",tt,W,Qt),g.call(B+"_mul",_t,at,Gt),g.call(B+"_add",D,_t,It),g.call(B+"_add",D,tt,wt),g.call(B+"_add",et,rt,Ct),g.call(B+"_add",Ct,gt,Ct),g.call(B+"_mul",et,W,Pt),g.call(B+"_add",Pt,Gt,mt),g.call(B+"_mul",g.i32_const(z),mt,St),g.call(B+"_add",St,xt,D),g.call(B+"_mul",gt,at,mt),g.call(B+"_add",Pt,mt,Pt),g.call(B+"_add",mt,Qt,mt),g.call(B+"_mul",g.i32_const(z),mt,St),g.call(B+"_mul",et,w,mt),g.call(B+"_add",Pt,mt,Pt),g.call(B+"_add",St,mt,et),g.call(B+"_add",w,W,dt),g.call(B+"_mul",wt,dt,mt),g.call(B+"_add",xt,Qt,Et),g.call(B+"_sub",mt,Et,mt),g.call(B+"_mul",rt,at,St),g.call(B+"_add",Pt,St,Pt),g.call(B+"_add",tt,_t,dt),g.call(B+"_add",mt,St,tt),g.call(B+"_add",W,at,wt),g.call(B+"_mul",wt,dt,mt),g.call(B+"_add",Qt,Gt,Et),g.call(B+"_sub",mt,Et,mt),g.call(B+"_mul",g.i32_const(z),mt,St),g.call(B+"_mul",rt,w,mt),g.call(B+"_add",Pt,mt,Pt),g.call(B+"_add",St,mt,rt),g.call(B+"_mul",gt,W,mt),g.call(B+"_add",Pt,mt,Pt),g.call(B+"_mul",g.i32_const(z),mt,St),g.call(B+"_add",w,at,dt),g.call(B+"_mul",It,dt,mt),g.call(B+"_add",xt,Gt,Et),g.call(B+"_sub",mt,Et,mt),g.call(B+"_add",St,mt,_t),g.call(B+"_add",w,W,dt),g.call(B+"_add",dt,at,dt),g.call(B+"_mul",Ct,dt,mt),g.call(B+"_sub",mt,Pt,gt))}function ct(){const ot=t.addFunction(a+"_millerLoop");ot.addParam("ppreP","i32"),ot.addParam("ppreQ","i32"),ot.addParam("r","i32"),ot.addLocal("pCoef","i32"),ot.addLocal("i","i32");const g=ot.getCodeBuilder(),w=g.getLocal("ppreP"),W=g.i32_add(g.getLocal("ppreP"),g.i32_const(d)),at=g.getLocal("pCoef"),D=g.i32_add(g.getLocal("pCoef"),g.i32_const(c)),et=g.i32_add(g.getLocal("pCoef"),g.i32_const(2*c)),tt=t.alloc(c),rt=g.i32_const(tt),_t=t.alloc(c),gt=g.i32_const(_t),dt=g.getLocal("r");ot.addCode(g.call(it+"_one",dt),g.setLocal("pCoef",g.i32_add(g.getLocal("ppreQ"),g.i32_const(c*3))),g.setLocal("i",g.i32_const(k.length-2)),g.block(g.loop(g.call(it+"_square",dt,dt),g.call(B+"_mul1",D,W,rt),g.call(B+"_mul1",et,w,gt),g.call(a+"__mulBy024",at,rt,gt,dt),g.setLocal("pCoef",g.i32_add(g.getLocal("pCoef"),g.i32_const(m))),g.if(g.i32_load8_s(g.getLocal("i"),J),[...g.call(B+"_mul1",D,W,rt),...g.call(B+"_mul1",et,w,gt),...g.call(a+"__mulBy024",at,rt,gt,dt),...g.setLocal("pCoef",g.i32_add(g.getLocal("pCoef"),g.i32_const(m)))]),g.br_if(1,g.i32_eqz(g.getLocal("i"))),g.setLocal("i",g.i32_sub(g.getLocal("i"),g.i32_const(1))),g.br(0)))),ot.addCode(g.call(B+"_mul1",D,W,rt),g.call(B+"_mul1",et,w,gt),g.call(a+"__mulBy024",at,rt,gt,dt),g.setLocal("pCoef",g.i32_add(g.getLocal("pCoef"),g.i32_const(m))),g.call(B+"_mul1",D,W,rt),g.call(B+"_mul1",et,w,gt),g.call(a+"__mulBy024",at,rt,gt,dt),g.setLocal("pCoef",g.i32_add(g.getLocal("pCoef"),g.i32_const(m))))}function Lt(ot){const g=[[[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n]],[[1n,0n],[8376118865763821496583973867626364092589906065868298776909617916018768340080n,16469823323077808223889137241176536799009286646108169935659301613961712198316n],[21888242871839275220042445260109153167277707414472061641714758635765020556617n,0n],[11697423496358154304825782922584725312912383441159505038794027105778954184319n,303847389135065887422783454877609941456349188919719272345083954437860409601n],[21888242871839275220042445260109153167277707414472061641714758635765020556616n,0n],[3321304630594332808241809054958361220322477375291206261884409189760185844239n,5722266937896532885780051958958348231143373700109372999374820235121374419868n],[21888242871839275222246405745257275088696311157297823662689037894645226208582n,0n],[13512124006075453725662431877630910996106405091429524885779419978626457868503n,5418419548761466998357268504080738289687024511189653727029736280683514010267n],[2203960485148121921418603742825762020974279258880205651966n,0n],[10190819375481120917420622822672549775783927716138318623895010788866272024264n,21584395482704209334823622290379665147239961968378104390343953940207365798982n],[2203960485148121921418603742825762020974279258880205651967n,0n],[18566938241244942414004596690298913868373833782006617400804628704885040364344n,16165975933942742336466353786298926857552937457188450663314217659523851788715n]]],w=[[[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n]],[[1n,0n],[21575463638280843010398324269430826099269044274347216827212613867836435027261n,10307601595873709700152284273816112264069230130616436755625194854815875713954n],[21888242871839275220042445260109153167277707414472061641714758635765020556616n,0n],[3772000881919853776433695186713858239009073593817195771773381919316419345261n,2236595495967245188281701248203181795121068902605861227855261137820944008926n],[2203960485148121921418603742825762020974279258880205651966n,0n],[18429021223477853657660792034369865839114504446431234726392080002137598044644n,9344045779998320333812420223237981029506012124075525679208581902008406485703n]],[[1n,0n],[2581911344467009335267311115468803099551665605076196740867805258568234346338n,19937756971775647987995932169929341994314640652964949448313374472400716661030n],[2203960485148121921418603742825762020974279258880205651966n,0n],[5324479202449903542726783395506214481928257762400643279780343368557297135718n,16208900380737693084919495127334387981393726419856888799917914180988844123039n],[21888242871839275220042445260109153167277707414472061641714758635765020556616n,0n],[13981852324922362344252311234282257507216387789820983642040889267519694726527n,7629828391165209371577384193250820201684255241773809077146787135900891633097n]]],W=t.addFunction(a+"__frobeniusMap"+ot);W.addParam("x","i32"),W.addParam("r","i32");const at=W.getCodeBuilder();for(let et=0;et<6;et++){const tt=et==0?at.getLocal("x"):at.i32_add(at.getLocal("x"),at.i32_const(et*c)),rt=tt,_t=at.i32_add(at.getLocal("x"),at.i32_const(et*c+d)),gt=et==0?at.getLocal("r"):at.i32_add(at.getLocal("r"),at.i32_const(et*c)),dt=gt,wt=at.i32_add(at.getLocal("r"),at.i32_const(et*c+d)),It=D(g[Math.floor(et/3)][ot%12],w[et%3][ot%6]),Ct=t.alloc([...zt.bigInt2BytesLE(P(It[0]),32),...zt.bigInt2BytesLE(P(It[1]),32)]);ot%2==1?W.addCode(at.call(L+"_copy",rt,dt),at.call(L+"_neg",_t,wt),at.call(B+"_mul",gt,at.i32_const(Ct),gt)):W.addCode(at.call(B+"_mul",tt,at.i32_const(Ct),gt))}function D(et,tt){const rt=BigInt(et[0]),_t=BigInt(et[1]),gt=BigInt(tt[0]),dt=BigInt(tt[1]),wt=[(rt*gt-_t*dt)%i,(rt*dt+_t*gt)%i];return Nc(wt[0])&&(wt[0]=wt[0]+i),wt}}function At(){const ot=t.addFunction(a+"__finalExponentiationFirstChunk");ot.addParam("x","i32"),ot.addParam("r","i32");const g=ot.getCodeBuilder(),w=g.getLocal("x"),W=w,at=g.i32_add(w,g.i32_const(s*6)),D=g.getLocal("r"),et=t.alloc(f),tt=g.i32_const(et),rt=tt,_t=g.i32_const(et+s*6),gt=g.i32_const(t.alloc(f)),dt=g.i32_const(t.alloc(f)),wt=g.i32_const(t.alloc(f));ot.addCode(g.call(nt+"_copy",W,rt),g.call(nt+"_neg",at,_t),g.call(it+"_inverse",w,gt),g.call(it+"_mul",tt,gt,dt),g.call(a+"__frobeniusMap2",dt,wt),g.call(it+"_mul",dt,wt,D))}function Bt(){const ot=t.addFunction(a+"__cyclotomicSquare");ot.addParam("x","i32"),ot.addParam("r","i32");const g=ot.getCodeBuilder(),w=g.getLocal("x"),W=g.i32_add(g.getLocal("x"),g.i32_const(c)),at=g.i32_add(g.getLocal("x"),g.i32_const(2*c)),D=g.i32_add(g.getLocal("x"),g.i32_const(3*c)),et=g.i32_add(g.getLocal("x"),g.i32_const(4*c)),tt=g.i32_add(g.getLocal("x"),g.i32_const(5*c)),rt=g.getLocal("r"),_t=g.i32_add(g.getLocal("r"),g.i32_const(c)),gt=g.i32_add(g.getLocal("r"),g.i32_const(2*c)),dt=g.i32_add(g.getLocal("r"),g.i32_const(3*c)),wt=g.i32_add(g.getLocal("r"),g.i32_const(4*c)),It=g.i32_add(g.getLocal("r"),g.i32_const(5*c)),Ct=g.i32_const(t.alloc(c)),mt=g.i32_const(t.alloc(c)),St=g.i32_const(t.alloc(c)),xt=g.i32_const(t.alloc(c)),Qt=g.i32_const(t.alloc(c)),Gt=g.i32_const(t.alloc(c)),Pt=g.i32_const(t.alloc(c)),Et=g.i32_const(t.alloc(c));ot.addCode(g.call(B+"_mul",w,et,Pt),g.call(B+"_mul",et,g.i32_const(z),Ct),g.call(B+"_add",w,Ct,Ct),g.call(B+"_add",w,et,Et),g.call(B+"_mul",Et,Ct,Ct),g.call(B+"_mul",g.i32_const(z),Pt,Et),g.call(B+"_add",Pt,Et,Et),g.call(B+"_sub",Ct,Et,Ct),g.call(B+"_add",Pt,Pt,mt),g.call(B+"_mul",D,at,Pt),g.call(B+"_mul",at,g.i32_const(z),St),g.call(B+"_add",D,St,St),g.call(B+"_add",D,at,Et),g.call(B+"_mul",Et,St,St),g.call(B+"_mul",g.i32_const(z),Pt,Et),g.call(B+"_add",Pt,Et,Et),g.call(B+"_sub",St,Et,St),g.call(B+"_add",Pt,Pt,xt),g.call(B+"_mul",W,tt,Pt),g.call(B+"_mul",tt,g.i32_const(z),Qt),g.call(B+"_add",W,Qt,Qt),g.call(B+"_add",W,tt,Et),g.call(B+"_mul",Et,Qt,Qt),g.call(B+"_mul",g.i32_const(z),Pt,Et),g.call(B+"_add",Pt,Et,Et),g.call(B+"_sub",Qt,Et,Qt),g.call(B+"_add",Pt,Pt,Gt),g.call(B+"_sub",Ct,w,rt),g.call(B+"_add",rt,rt,rt),g.call(B+"_add",Ct,rt,rt),g.call(B+"_add",mt,et,wt),g.call(B+"_add",wt,wt,wt),g.call(B+"_add",mt,wt,wt),g.call(B+"_mul",Gt,g.i32_const(Z),Et),g.call(B+"_add",Et,D,dt),g.call(B+"_add",dt,dt,dt),g.call(B+"_add",Et,dt,dt),g.call(B+"_sub",Qt,at,gt),g.call(B+"_add",gt,gt,gt),g.call(B+"_add",Qt,gt,gt),g.call(B+"_sub",St,W,_t),g.call(B+"_add",_t,_t,_t),g.call(B+"_add",St,_t,_t),g.call(B+"_add",xt,tt,It),g.call(B+"_add",It,It,It),g.call(B+"_add",xt,It,It))}function Mt(ot,g){const w=O(ot).map(_t=>_t==-1?255:_t),W=t.alloc(w),at=t.addFunction(a+"__cyclotomicExp_"+g);at.addParam("x","i32"),at.addParam("r","i32"),at.addLocal("bit","i32"),at.addLocal("i","i32");const D=at.getCodeBuilder(),et=D.getLocal("x"),tt=D.getLocal("r"),rt=D.i32_const(t.alloc(f));at.addCode(D.call(it+"_conjugate",et,rt),D.call(it+"_one",tt),D.if(D.teeLocal("bit",D.i32_load8_s(D.i32_const(w.length-1),W)),D.if(D.i32_eq(D.getLocal("bit"),D.i32_const(1)),D.call(it+"_mul",tt,et,tt),D.call(it+"_mul",tt,rt,tt))),D.setLocal("i",D.i32_const(w.length-2)),D.block(D.loop(D.call(a+"__cyclotomicSquare",tt,tt),D.if(D.teeLocal("bit",D.i32_load8_s(D.getLocal("i"),W)),D.if(D.i32_eq(D.getLocal("bit"),D.i32_const(1)),D.call(it+"_mul",tt,et,tt),D.call(it+"_mul",tt,rt,tt))),D.br_if(1,D.i32_eqz(D.getLocal("i"))),D.setLocal("i",D.i32_sub(D.getLocal("i"),D.i32_const(1))),D.br(0))))}function $t(){Bt(),Mt(p,"w0");const ot=t.addFunction(a+"__finalExponentiationLastChunk");ot.addParam("x","i32"),ot.addParam("r","i32");const g=ot.getCodeBuilder(),w=g.getLocal("x"),W=g.getLocal("r"),at=g.i32_const(t.alloc(f)),D=g.i32_const(t.alloc(f)),et=g.i32_const(t.alloc(f)),tt=g.i32_const(t.alloc(f)),rt=g.i32_const(t.alloc(f)),_t=g.i32_const(t.alloc(f)),gt=g.i32_const(t.alloc(f)),dt=g.i32_const(t.alloc(f)),wt=g.i32_const(t.alloc(f)),It=g.i32_const(t.alloc(f)),Ct=g.i32_const(t.alloc(f)),mt=g.i32_const(t.alloc(f)),St=g.i32_const(t.alloc(f)),xt=g.i32_const(t.alloc(f)),Qt=g.i32_const(t.alloc(f)),Gt=g.i32_const(t.alloc(f)),Pt=g.i32_const(t.alloc(f)),Et=g.i32_const(t.alloc(f)),jt=g.i32_const(t.alloc(f)),ln=g.i32_const(t.alloc(f)),gn=g.i32_const(t.alloc(f));ot.addCode(g.call(a+"__cyclotomicExp_w0",w,at),g.call(it+"_conjugate",at,at),g.call(a+"__cyclotomicSquare",at,D),g.call(a+"__cyclotomicSquare",D,et),g.call(it+"_mul",et,D,tt),g.call(a+"__cyclotomicExp_w0",tt,rt),g.call(it+"_conjugate",rt,rt),g.call(a+"__cyclotomicSquare",rt,_t),g.call(a+"__cyclotomicExp_w0",_t,gt),g.call(it+"_conjugate",gt,gt),g.call(it+"_conjugate",tt,dt),g.call(it+"_conjugate",gt,wt),g.call(it+"_mul",wt,rt,It),g.call(it+"_mul",It,dt,Ct),g.call(it+"_mul",Ct,D,mt),g.call(it+"_mul",Ct,rt,St),g.call(it+"_mul",St,w,xt),g.call(a+"__frobeniusMap1",mt,Qt),g.call(it+"_mul",Qt,xt,Gt),g.call(a+"__frobeniusMap2",Ct,Pt),g.call(it+"_mul",Pt,Gt,Et),g.call(it+"_conjugate",w,jt),g.call(it+"_mul",jt,mt,ln),g.call(a+"__frobeniusMap3",ln,gn),g.call(it+"_mul",gn,Et,W))}function Dt(){At(),$t();const ot=t.addFunction(a+"_finalExponentiation");ot.addParam("x","i32"),ot.addParam("r","i32");const g=ot.getCodeBuilder(),w=g.getLocal("x"),W=g.getLocal("r"),at=g.i32_const(t.alloc(f));ot.addCode(g.call(a+"__finalExponentiationFirstChunk",w,at),g.call(a+"__finalExponentiationLastChunk",at,W))}function vt(){const ot=t.addFunction(a+"_finalExponentiationOld");ot.addParam("x","i32"),ot.addParam("r","i32");const w=t.alloc(zt.bigInt2BytesLE(552484233613224096312617126783173147097382103762957654188882734314196910839907541213974502761540629817009608548654680343627701153829446747810907373256841551006201639677726139946029199968412598804882391702273019083653272047566316584365559776493027495458238373902875937659943504873220554161550525926302303331747463515644711876653177129578303191095900909191624817826566688241804408081892785725967931714097716709526092261278071952560171111444072049229123565057483750161460024353346284167282452756217662335528813519139808291170539072125381230815729071544861602750936964829313608137325426383735122175229541155376346436093930287402089517426973178917569713384748081827255472576937471496195752727188261435633271238710131736096299798168852925540549342330775279877006784354801422249722573783561685179618816480037695005515426162362431072245638324744480n,352)),W=ot.getCodeBuilder();ot.addCode(W.call(it+"_exp",W.getLocal("x"),W.i32_const(w),W.i32_const(352),W.getLocal("r")))}const bt=t.alloc(x),qt=t.alloc(F);function Yt(ot){const g=t.addFunction(a+"_pairingEq"+ot);for(let D=0;D<ot;D++)g.addParam("p_"+D,"i32"),g.addParam("q_"+D,"i32");g.addParam("c","i32"),g.setReturnType("i32");const w=g.getCodeBuilder(),W=w.i32_const(t.alloc(f)),at=w.i32_const(t.alloc(f));g.addCode(w.call(it+"_one",W));for(let D=0;D<ot;D++)g.addCode(w.call(a+"_prepareG1",w.getLocal("p_"+D),w.i32_const(bt))),g.addCode(w.call(a+"_prepareG2",w.getLocal("q_"+D),w.i32_const(qt))),g.addCode(w.call(a+"_millerLoop",w.i32_const(bt),w.i32_const(qt),at)),g.addCode(w.call(it+"_mul",W,at,W));g.addCode(w.call(a+"_finalExponentiation",W,W)),g.addCode(w.call(it+"_eq",W,w.getLocal("c")))}function Ht(){const ot=t.addFunction(a+"_pairing");ot.addParam("p","i32"),ot.addParam("q","i32"),ot.addParam("r","i32");const g=ot.getCodeBuilder(),w=g.i32_const(t.alloc(f));ot.addCode(g.call(a+"_prepareG1",g.getLocal("p"),g.i32_const(bt))),ot.addCode(g.call(a+"_prepareG2",g.getLocal("q"),g.i32_const(qt))),ot.addCode(g.call(a+"_millerLoop",g.i32_const(bt),g.i32_const(qt),w)),ot.addCode(g.call(a+"_finalExponentiation",w,g.getLocal("r")))}H(),lt(),N(),pt(),st(),ut(),ct();for(let ot=0;ot<10;ot++)Lt(ot),t.exportFunction(a+"__frobeniusMap"+ot);vt(),Dt();for(let ot=1;ot<=5;ot++)Yt(ot),t.exportFunction(a+"_pairingEq"+ot);Ht(),t.exportFunction(a+"_pairing"),t.exportFunction(a+"_prepareG1"),t.exportFunction(a+"_prepareG2"),t.exportFunction(a+"_millerLoop"),t.exportFunction(a+"_finalExponentiation"),t.exportFunction(a+"_finalExponentiationOld"),t.exportFunction(a+"__mulBy024"),t.exportFunction(a+"__mulBy024Old"),t.exportFunction(a+"__cyclotomicSquare"),t.exportFunction(a+"__cyclotomicExp_w0")};const Ot=Nn,Vc=_e,Hc=qo,ze=Qo,Kc=Ro,qe=ko,pi=$o,jc=No,Zc=Do,Aa=Vo,{bitLength:Qe,isOdd:Re,isNegative:Wc}=un;var Yc=function(t,n){const a=n||"bls12381";if(t.modules[a])return a;const i=0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn,e=0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001n,l=Math.floor((Qe(i-1n)-1)/64)+1,s=l*8,h=s,d=h*2,c=h*12,f=Math.floor((Qe(e-1n)-1)/64)+1,y=f*8,L=y,v=t.alloc(Ot.bigInt2BytesLE(e,L)),T=Vc(t,i,"f1m","intq");Hc(t,e,"fr","frm","intr");const B=t.alloc(Ot.bigInt2BytesLE(I(4n),h)),E=qe(t,"g1m","f1m",B);pi(t,"frm","frm","frm","frm_mul"),jc(t,"pol","frm"),Zc(t,"qap","frm");const A=ze(t,"f1m_neg","f2m","f1m"),G=t.alloc([...Ot.bigInt2BytesLE(I(4n),h),...Ot.bigInt2BytesLE(I(4n),h)]),P=qe(t,"g2m","f2m",G);function U(g,w){const W=t.addFunction(g);W.addParam("pG","i32"),W.addParam("pFr","i32"),W.addParam("pr","i32");const at=W.getCodeBuilder(),D=at.i32_const(t.alloc(y));W.addCode(at.call("frm_fromMontgomery",at.getLocal("pFr"),D),at.call(w,at.getLocal("pG"),D,at.i32_const(y),at.getLocal("pr"))),t.exportFunction(g)}U("g1m_timesFr","g1m_timesScalar"),pi(t,"g1m","g1m","frm","g1m_timesFr"),U("g2m_timesFr","g2m_timesScalar"),pi(t,"g2m","g2m","frm","g2m_timesFr"),U("g1m_timesFrAffine","g1m_timesScalarAffine"),U("g2m_timesFrAffine","g2m_timesScalarAffine"),Aa(t,"frm_batchApplyKey","fmr","frm",y,y,y,"frm_mul"),Aa(t,"g1m_batchApplyKey","g1m","frm",s*3,s*3,y,"g1m_timesFr"),Aa(t,"g1m_batchApplyKeyMixed","g1m","frm",s*2,s*3,y,"g1m_timesFrAffine"),Aa(t,"g2m_batchApplyKey","g2m","frm",s*2*3,s*3*2,y,"g2m_timesFr"),Aa(t,"g2m_batchApplyKeyMixed","g2m","frm",s*2*2,s*3*2,y,"g2m_timesFrAffine");function I(g){return BigInt(g)*(1n<<BigInt(h*8))%i}const _=[3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507n,1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569n,1n],b=t.alloc([...Ot.bigInt2BytesLE(I(_[0]),h),...Ot.bigInt2BytesLE(I(_[1]),h),...Ot.bigInt2BytesLE(I(_[2]),h)]),$=[0n,1n,0n],K=t.alloc([...Ot.bigInt2BytesLE(I($[0]),h),...Ot.bigInt2BytesLE(I($[1]),h),...Ot.bigInt2BytesLE(I($[2]),h)]),j=[[352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160n,3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758n],[1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905n,927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582n],[1n,0n]],M=t.alloc([...Ot.bigInt2BytesLE(I(j[0][0]),h),...Ot.bigInt2BytesLE(I(j[0][1]),h),...Ot.bigInt2BytesLE(I(j[1][0]),h),...Ot.bigInt2BytesLE(I(j[1][1]),h),...Ot.bigInt2BytesLE(I(j[2][0]),h),...Ot.bigInt2BytesLE(I(j[2][1]),h)]),S=[[0n,0n],[1n,0n],[0n,0n]],z=t.alloc([...Ot.bigInt2BytesLE(I(S[0][0]),h),...Ot.bigInt2BytesLE(I(S[0][1]),h),...Ot.bigInt2BytesLE(I(S[1][0]),h),...Ot.bigInt2BytesLE(I(S[1][1]),h),...Ot.bigInt2BytesLE(I(S[2][0]),h),...Ot.bigInt2BytesLE(I(S[2][1]),h)]),q=t.alloc([...Ot.bigInt2BytesLE(I(1n),h),...Ot.bigInt2BytesLE(I(0n),h),...Ot.bigInt2BytesLE(I(0n),h),...Ot.bigInt2BytesLE(I(0n),h),...Ot.bigInt2BytesLE(I(0n),h),...Ot.bigInt2BytesLE(I(0n),h),...Ot.bigInt2BytesLE(I(0n),h),...Ot.bigInt2BytesLE(I(0n),h),...Ot.bigInt2BytesLE(I(0n),h),...Ot.bigInt2BytesLE(I(0n),h),...Ot.bigInt2BytesLE(I(0n),h),...Ot.bigInt2BytesLE(I(0n),h)]),Z=t.alloc([...Ot.bigInt2BytesLE(I(1n),h),...Ot.bigInt2BytesLE(I(1n),h)]);function Y(){const g=t.addFunction(A+"_mulNR");g.addParam("x","i32"),g.addParam("pr","i32");const w=g.getCodeBuilder(),W=w.i32_const(t.alloc(h)),at=w.getLocal("x"),D=w.i32_add(w.getLocal("x"),w.i32_const(h)),et=w.getLocal("pr"),tt=w.i32_add(w.getLocal("pr"),w.i32_const(h));g.addCode(w.call(T+"_copy",at,W),w.call(T+"_sub",at,D,et),w.call(T+"_add",W,D,tt))}Y();const V=Kc(t,A+"_mulNR","f6m","f2m");function nt(){const g=t.addFunction(V+"_mulNR");g.addParam("x","i32"),g.addParam("pr","i32");const w=g.getCodeBuilder(),W=w.i32_const(t.alloc(h*2));g.addCode(w.call(A+"_copy",w.getLocal("x"),W),w.call(A+"_mulNR",w.i32_add(w.getLocal("x"),w.i32_const(s*4)),w.getLocal("pr")),w.call(A+"_copy",w.i32_add(w.getLocal("x"),w.i32_const(s*2)),w.i32_add(w.getLocal("pr"),w.i32_const(s*4))),w.call(A+"_copy",W,w.i32_add(w.getLocal("pr"),w.i32_const(s*2))))}nt();const Q=ze(t,V+"_mulNR","ftm",V),X=R(0xd201000000010000n),k=t.alloc(X),J=3*d,m=X.length-1,C=X.reduce((g,w)=>g+(w!=0?1:0),0)+m+1,u=6*s,x=3*s*2+C*J,F=!0,p=15132376222941642752n;t.modules[a]={n64q:l,n64r:f,n8q:s,n8r:y,pG1gen:b,pG1zero:K,pG1b:B,pG2gen:M,pG2zero:z,pG2b:G,pq:t.modules.f1m.pq,pr:v,pOneT:q,r:e,q:i,prePSize:u,preQSize:x};function O(g){let w=g;const W=[];for(;w>0n;){if(Re(w)){const at=2-Number(w%4n);W.push(at),w=w-BigInt(at)}else W.push(0);w=w>>1n}return W}function R(g){let w=g;const W=[];for(;w>0n;)Re(w)?W.push(1):W.push(0),w=w>>1n;return W}function N(){const g=t.addFunction(a+"_prepareG1");g.addParam("pP","i32"),g.addParam("ppreP","i32");const w=g.getCodeBuilder();g.addCode(w.call(E+"_normalize",w.getLocal("pP"),w.getLocal("ppreP")))}function H(){const g=t.addFunction(a+"_prepDblStep");g.addParam("R","i32"),g.addParam("r","i32");const w=g.getCodeBuilder(),W=w.getLocal("R"),at=w.i32_add(w.getLocal("R"),w.i32_const(2*s)),D=w.i32_add(w.getLocal("R"),w.i32_const(4*s)),et=w.getLocal("r"),tt=w.i32_add(w.getLocal("r"),w.i32_const(2*s)),rt=w.i32_add(w.getLocal("r"),w.i32_const(4*s)),_t=w.i32_const(t.alloc(d)),gt=w.i32_const(t.alloc(d)),dt=w.i32_const(t.alloc(d)),wt=w.i32_const(t.alloc(d)),It=w.i32_const(t.alloc(d));g.addCode(w.call(A+"_square",W,et),w.call(A+"_square",at,gt),w.call(A+"_square",gt,dt),w.call(A+"_add",gt,W,tt),w.call(A+"_square",tt,tt),w.call(A+"_sub",tt,et,tt),w.call(A+"_sub",tt,dt,tt),w.call(A+"_add",tt,tt,tt),w.call(A+"_add",et,et,wt),w.call(A+"_add",wt,et,wt),w.call(A+"_add",W,wt,rt),w.call(A+"_square",wt,It),w.call(A+"_square",D,_t),w.call(A+"_sub",It,tt,W),w.call(A+"_sub",W,tt,W),w.call(A+"_add",D,at,D),w.call(A+"_square",D,D),w.call(A+"_sub",D,gt,D),w.call(A+"_sub",D,_t,D),w.call(A+"_sub",tt,W,at),w.call(A+"_mul",at,wt,at),w.call(A+"_add",dt,dt,dt),w.call(A+"_add",dt,dt,dt),w.call(A+"_add",dt,dt,dt),w.call(A+"_sub",at,dt,at),w.call(A+"_mul",wt,_t,tt),w.call(A+"_add",tt,tt,tt),w.call(A+"_neg",tt,tt),w.call(A+"_square",rt,rt),w.call(A+"_sub",rt,et,rt),w.call(A+"_sub",rt,It,rt),w.call(A+"_add",gt,gt,gt),w.call(A+"_add",gt,gt,gt),w.call(A+"_sub",rt,gt,rt),w.call(A+"_mul",D,_t,et),w.call(A+"_add",et,et,et))}function lt(){const g=t.addFunction(a+"_prepAddStep");g.addParam("R","i32"),g.addParam("Q","i32"),g.addParam("r","i32");const w=g.getCodeBuilder(),W=w.getLocal("R"),at=w.i32_add(w.getLocal("R"),w.i32_const(2*s)),D=w.i32_add(w.getLocal("R"),w.i32_const(4*s)),et=w.getLocal("Q"),tt=w.i32_add(w.getLocal("Q"),w.i32_const(2*s)),rt=w.getLocal("r"),_t=w.i32_add(w.getLocal("r"),w.i32_const(2*s)),gt=w.i32_add(w.getLocal("r"),w.i32_const(4*s)),dt=w.i32_const(t.alloc(d)),wt=w.i32_const(t.alloc(d)),It=w.i32_const(t.alloc(d)),Ct=w.i32_const(t.alloc(d)),mt=w.i32_const(t.alloc(d)),St=w.i32_const(t.alloc(d)),xt=w.i32_const(t.alloc(d)),Qt=w.i32_const(t.alloc(d)),Gt=w.i32_const(t.alloc(d)),Pt=w.i32_const(t.alloc(d)),Et=w.i32_const(t.alloc(d));g.addCode(w.call(A+"_square",D,dt),w.call(A+"_square",tt,wt),w.call(A+"_mul",dt,et,Ct),w.call(A+"_add",tt,D,_t),w.call(A+"_square",_t,_t),w.call(A+"_sub",_t,wt,_t),w.call(A+"_sub",_t,dt,_t),w.call(A+"_mul",_t,dt,_t),w.call(A+"_sub",Ct,W,mt),w.call(A+"_square",mt,St),w.call(A+"_add",St,St,xt),w.call(A+"_add",xt,xt,xt),w.call(A+"_mul",xt,mt,Qt),w.call(A+"_sub",_t,at,Gt),w.call(A+"_sub",Gt,at,Gt),w.call(A+"_mul",Gt,et,gt),w.call(A+"_mul",xt,W,Pt),w.call(A+"_square",Gt,W),w.call(A+"_sub",W,Qt,W),w.call(A+"_sub",W,Pt,W),w.call(A+"_sub",W,Pt,W),w.call(A+"_add",D,mt,D),w.call(A+"_square",D,D),w.call(A+"_sub",D,dt,D),w.call(A+"_sub",D,St,D),w.call(A+"_add",tt,D,rt),w.call(A+"_sub",Pt,W,Et),w.call(A+"_mul",Et,Gt,Et),w.call(A+"_mul",at,Qt,Ct),w.call(A+"_add",Ct,Ct,Ct),w.call(A+"_sub",Et,Ct,at),w.call(A+"_square",rt,rt),w.call(A+"_sub",rt,wt,rt),w.call(A+"_square",D,It),w.call(A+"_sub",rt,It,rt),w.call(A+"_add",gt,gt,gt),w.call(A+"_sub",gt,rt,gt),w.call(A+"_add",D,D,rt),w.call(A+"_neg",Gt,Gt),w.call(A+"_add",Gt,Gt,_t))}function ht(){const g=t.addFunction(a+"_prepareG2");g.addParam("pQ","i32"),g.addParam("ppreQ","i32"),g.addLocal("pCoef","i32"),g.addLocal("i","i32");const w=g.getCodeBuilder(),W=w.getLocal("pQ"),at=t.alloc(d*3),D=w.i32_const(at),et=w.getLocal("ppreQ");g.addCode(w.call(P+"_normalize",W,et),w.if(w.call(P+"_isZero",et),w.ret([])),w.call(P+"_copy",et,D),w.setLocal("pCoef",w.i32_add(w.getLocal("ppreQ"),w.i32_const(d*3)))),g.addCode(w.setLocal("i",w.i32_const(X.length-2)),w.block(w.loop(w.call(a+"_prepDblStep",D,w.getLocal("pCoef")),w.setLocal("pCoef",w.i32_add(w.getLocal("pCoef"),w.i32_const(J))),w.if(w.i32_load8_s(w.getLocal("i"),k),[...w.call(a+"_prepAddStep",D,et,w.getLocal("pCoef")),...w.setLocal("pCoef",w.i32_add(w.getLocal("pCoef"),w.i32_const(J)))]),w.br_if(1,w.i32_eqz(w.getLocal("i"))),w.setLocal("i",w.i32_sub(w.getLocal("i"),w.i32_const(1))),w.br(0))))}function pt(){const g=t.addFunction(V+"_mul1");g.addParam("pA","i32"),g.addParam("pC1","i32"),g.addParam("pR","i32");const w=g.getCodeBuilder(),W=w.getLocal("pA"),at=w.i32_add(w.getLocal("pA"),w.i32_const(h*2)),D=w.i32_add(w.getLocal("pA"),w.i32_const(h*4)),et=w.getLocal("pC1"),tt=w.getLocal("pR"),rt=w.i32_add(w.getLocal("pR"),w.i32_const(h*2)),_t=w.i32_add(w.getLocal("pR"),w.i32_const(h*4)),gt=w.i32_const(t.alloc(h*2)),dt=w.i32_const(t.alloc(h*2));g.addCode(w.call(A+"_add",W,at,gt),w.call(A+"_add",at,D,dt),w.call(A+"_mul",at,et,_t),w.call(A+"_mul",dt,et,tt),w.call(A+"_sub",tt,_t,tt),w.call(A+"_mulNR",tt,tt),w.call(A+"_mul",gt,et,rt),w.call(A+"_sub",rt,_t,rt))}pt();function ut(){const g=t.addFunction(V+"_mul01");g.addParam("pA","i32"),g.addParam("pC0","i32"),g.addParam("pC1","i32"),g.addParam("pR","i32");const w=g.getCodeBuilder(),W=w.getLocal("pA"),at=w.i32_add(w.getLocal("pA"),w.i32_const(h*2)),D=w.i32_add(w.getLocal("pA"),w.i32_const(h*4)),et=w.getLocal("pC0"),tt=w.getLocal("pC1"),rt=w.getLocal("pR"),_t=w.i32_add(w.getLocal("pR"),w.i32_const(h*2)),gt=w.i32_add(w.getLocal("pR"),w.i32_const(h*4)),dt=w.i32_const(t.alloc(h*2)),wt=w.i32_const(t.alloc(h*2)),It=w.i32_const(t.alloc(h*2)),Ct=w.i32_const(t.alloc(h*2));g.addCode(w.call(A+"_mul",W,et,dt),w.call(A+"_mul",at,tt,wt),w.call(A+"_add",W,at,It),w.call(A+"_add",W,D,Ct),w.call(A+"_add",at,D,rt),w.call(A+"_mul",rt,tt,rt),w.call(A+"_sub",rt,wt,rt),w.call(A+"_mulNR",rt,rt),w.call(A+"_add",rt,dt,rt),w.call(A+"_add",et,tt,_t),w.call(A+"_mul",_t,It,_t),w.call(A+"_sub",_t,dt,_t),w.call(A+"_sub",_t,wt,_t),w.call(A+"_mul",Ct,et,gt),w.call(A+"_sub",gt,dt,gt),w.call(A+"_add",gt,wt,gt))}ut();function st(){const g=t.addFunction(Q+"_mul014");g.addParam("pA","i32"),g.addParam("pC0","i32"),g.addParam("pC1","i32"),g.addParam("pC4","i32"),g.addParam("pR","i32");const w=g.getCodeBuilder(),W=w.getLocal("pA"),at=w.i32_add(w.getLocal("pA"),w.i32_const(h*6)),D=w.getLocal("pC0"),et=w.getLocal("pC1"),tt=w.getLocal("pC4"),rt=w.i32_const(t.alloc(h*6)),_t=w.i32_const(t.alloc(h*6)),gt=w.i32_const(t.alloc(h*2)),dt=w.getLocal("pR"),wt=w.i32_add(w.getLocal("pR"),w.i32_const(h*6));g.addCode(w.call(V+"_mul01",W,D,et,rt),w.call(V+"_mul1",at,tt,_t),w.call(A+"_add",et,tt,gt),w.call(V+"_add",at,W,wt),w.call(V+"_mul01",wt,D,gt,wt),w.call(V+"_sub",wt,rt,wt),w.call(V+"_sub",wt,_t,wt),w.call(V+"_copy",_t,dt),w.call(V+"_mulNR",dt,dt),w.call(V+"_add",dt,rt,dt))}st();function ct(){const g=t.addFunction(a+"_ell");g.addParam("pP","i32"),g.addParam("pCoefs","i32"),g.addParam("pF","i32");const w=g.getCodeBuilder(),W=w.getLocal("pP"),at=w.i32_add(w.getLocal("pP"),w.i32_const(s)),D=w.getLocal("pF"),et=w.getLocal("pCoefs"),tt=w.i32_add(w.getLocal("pCoefs"),w.i32_const(h)),rt=w.i32_add(w.getLocal("pCoefs"),w.i32_const(h*2)),_t=w.i32_add(w.getLocal("pCoefs"),w.i32_const(h*3)),gt=w.i32_add(w.getLocal("pCoefs"),w.i32_const(h*4)),dt=t.alloc(h*2),wt=w.i32_const(dt),It=w.i32_const(dt),Ct=w.i32_const(dt+h),mt=t.alloc(h*2),St=w.i32_const(mt),xt=w.i32_const(mt),Qt=w.i32_const(mt+h);g.addCode(w.call(T+"_mul",et,at,It),w.call(T+"_mul",tt,at,Ct),w.call(T+"_mul",rt,W,xt),w.call(T+"_mul",_t,W,Qt),w.call(Q+"_mul014",D,gt,St,wt,D))}ct();function Lt(){const g=t.addFunction(a+"_millerLoop");g.addParam("ppreP","i32"),g.addParam("ppreQ","i32"),g.addParam("r","i32"),g.addLocal("pCoef","i32"),g.addLocal("i","i32");const w=g.getCodeBuilder(),W=w.getLocal("ppreP"),at=w.getLocal("pCoef"),D=w.getLocal("r");g.addCode(w.call(Q+"_one",D),w.if(w.call(E+"_isZero",W),w.ret([])),w.if(w.call(E+"_isZero",w.getLocal("ppreQ")),w.ret([])),w.setLocal("pCoef",w.i32_add(w.getLocal("ppreQ"),w.i32_const(d*3))),w.setLocal("i",w.i32_const(X.length-2)),w.block(w.loop(w.call(a+"_ell",W,at,D),w.setLocal("pCoef",w.i32_add(w.getLocal("pCoef"),w.i32_const(J))),w.if(w.i32_load8_s(w.getLocal("i"),k),[...w.call(a+"_ell",W,at,D),...w.setLocal("pCoef",w.i32_add(w.getLocal("pCoef"),w.i32_const(J)))]),w.call(Q+"_square",D,D),w.br_if(1,w.i32_eq(w.getLocal("i"),w.i32_const(1))),w.setLocal("i",w.i32_sub(w.getLocal("i"),w.i32_const(1))),w.br(0))),w.call(a+"_ell",W,at,D)),g.addCode(w.call(Q+"_conjugate",D,D))}function At(g){const w=[[[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n]],[[1n,0n],[3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n,151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n],[793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n,0n],[2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n,1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n],[793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n,0n],[3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n,877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n],[4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n,0n],[151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n,3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n],[4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n,0n],[1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n,2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n],[4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n,0n],[877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n,3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n]]],W=[[[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n],[1n,0n]],[[1n,0n],[0n,4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n],[793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n,0n],[0n,1n],[4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n,0n],[0n,793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n]],[[1n,0n],[4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n,0n],[4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n,0n],[4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n,0n],[793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n,0n],[793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n,0n]]],at=t.addFunction(Q+"_frobeniusMap"+g);at.addParam("x","i32"),at.addParam("r","i32");const D=at.getCodeBuilder();for(let tt=0;tt<6;tt++){const rt=tt==0?D.getLocal("x"):D.i32_add(D.getLocal("x"),D.i32_const(tt*d)),_t=rt,gt=D.i32_add(D.getLocal("x"),D.i32_const(tt*d+h)),dt=tt==0?D.getLocal("r"):D.i32_add(D.getLocal("r"),D.i32_const(tt*d)),wt=dt,It=D.i32_add(D.getLocal("r"),D.i32_const(tt*d+h)),Ct=et(w[Math.floor(tt/3)][g%12],W[tt%3][g%6]),mt=t.alloc([...Ot.bigInt2BytesLE(I(Ct[0]),s),...Ot.bigInt2BytesLE(I(Ct[1]),s)]);g%2==1?at.addCode(D.call(T+"_copy",_t,wt),D.call(T+"_neg",gt,It),D.call(A+"_mul",dt,D.i32_const(mt),dt)):at.addCode(D.call(A+"_mul",rt,D.i32_const(mt),dt))}function et(tt,rt){const _t=tt[0],gt=tt[1],dt=rt[0],wt=rt[1],It=[(_t*dt-gt*wt)%i,(_t*wt+gt*dt)%i];return Wc(It[0])&&(It[0]=It[0]+i),It}}function Bt(){const g=t.addFunction(a+"__cyclotomicSquare");g.addParam("x","i32"),g.addParam("r","i32");const w=g.getCodeBuilder(),W=w.getLocal("x"),at=w.i32_add(w.getLocal("x"),w.i32_const(d)),D=w.i32_add(w.getLocal("x"),w.i32_const(2*d)),et=w.i32_add(w.getLocal("x"),w.i32_const(3*d)),tt=w.i32_add(w.getLocal("x"),w.i32_const(4*d)),rt=w.i32_add(w.getLocal("x"),w.i32_const(5*d)),_t=w.getLocal("r"),gt=w.i32_add(w.getLocal("r"),w.i32_const(d)),dt=w.i32_add(w.getLocal("r"),w.i32_const(2*d)),wt=w.i32_add(w.getLocal("r"),w.i32_const(3*d)),It=w.i32_add(w.getLocal("r"),w.i32_const(4*d)),Ct=w.i32_add(w.getLocal("r"),w.i32_const(5*d)),mt=w.i32_const(t.alloc(d)),St=w.i32_const(t.alloc(d)),xt=w.i32_const(t.alloc(d)),Qt=w.i32_const(t.alloc(d)),Gt=w.i32_const(t.alloc(d)),Pt=w.i32_const(t.alloc(d)),Et=w.i32_const(t.alloc(d)),jt=w.i32_const(t.alloc(d));g.addCode(w.call(A+"_mul",W,tt,Et),w.call(A+"_mulNR",tt,mt),w.call(A+"_add",W,mt,mt),w.call(A+"_add",W,tt,jt),w.call(A+"_mul",jt,mt,mt),w.call(A+"_mulNR",Et,jt),w.call(A+"_add",Et,jt,jt),w.call(A+"_sub",mt,jt,mt),w.call(A+"_add",Et,Et,St),w.call(A+"_mul",et,D,Et),w.call(A+"_mulNR",D,xt),w.call(A+"_add",et,xt,xt),w.call(A+"_add",et,D,jt),w.call(A+"_mul",jt,xt,xt),w.call(A+"_mulNR",Et,jt),w.call(A+"_add",Et,jt,jt),w.call(A+"_sub",xt,jt,xt),w.call(A+"_add",Et,Et,Qt),w.call(A+"_mul",at,rt,Et),w.call(A+"_mulNR",rt,Gt),w.call(A+"_add",at,Gt,Gt),w.call(A+"_add",at,rt,jt),w.call(A+"_mul",jt,Gt,Gt),w.call(A+"_mulNR",Et,jt),w.call(A+"_add",Et,jt,jt),w.call(A+"_sub",Gt,jt,Gt),w.call(A+"_add",Et,Et,Pt),w.call(A+"_sub",mt,W,_t),w.call(A+"_add",_t,_t,_t),w.call(A+"_add",mt,_t,_t),w.call(A+"_add",St,tt,It),w.call(A+"_add",It,It,It),w.call(A+"_add",St,It,It),w.call(A+"_mul",Pt,w.i32_const(Z),jt),w.call(A+"_add",jt,et,wt),w.call(A+"_add",wt,wt,wt),w.call(A+"_add",jt,wt,wt),w.call(A+"_sub",Gt,D,dt),w.call(A+"_add",dt,dt,dt),w.call(A+"_add",Gt,dt,dt),w.call(A+"_sub",xt,at,gt),w.call(A+"_add",gt,gt,gt),w.call(A+"_add",xt,gt,gt),w.call(A+"_add",Qt,rt,Ct),w.call(A+"_add",Ct,Ct,Ct),w.call(A+"_add",Qt,Ct,Ct))}function Mt(g,w,W){const at=O(g).map(dt=>dt==-1?255:dt),D=t.alloc(at),et=t.addFunction(a+"__cyclotomicExp_"+W);et.addParam("x","i32"),et.addParam("r","i32"),et.addLocal("bit","i32"),et.addLocal("i","i32");const tt=et.getCodeBuilder(),rt=tt.getLocal("x"),_t=tt.getLocal("r"),gt=tt.i32_const(t.alloc(c));et.addCode(tt.call(Q+"_conjugate",rt,gt),tt.call(Q+"_one",_t),tt.if(tt.teeLocal("bit",tt.i32_load8_s(tt.i32_const(at.length-1),D)),tt.if(tt.i32_eq(tt.getLocal("bit"),tt.i32_const(1)),tt.call(Q+"_mul",_t,rt,_t),tt.call(Q+"_mul",_t,gt,_t))),tt.setLocal("i",tt.i32_const(at.length-2)),tt.block(tt.loop(tt.call(a+"__cyclotomicSquare",_t,_t),tt.if(tt.teeLocal("bit",tt.i32_load8_s(tt.getLocal("i"),D)),tt.if(tt.i32_eq(tt.getLocal("bit"),tt.i32_const(1)),tt.call(Q+"_mul",_t,rt,_t),tt.call(Q+"_mul",_t,gt,_t))),tt.br_if(1,tt.i32_eqz(tt.getLocal("i"))),tt.setLocal("i",tt.i32_sub(tt.getLocal("i"),tt.i32_const(1))),tt.br(0)))),et.addCode(tt.call(Q+"_conjugate",_t,_t))}function $t(){Bt(),Mt(p,F,"w0");const g=t.addFunction(a+"_finalExponentiation");g.addParam("x","i32"),g.addParam("r","i32");const w=g.getCodeBuilder(),W=w.getLocal("x"),at=w.getLocal("r"),D=w.i32_const(t.alloc(c)),et=w.i32_const(t.alloc(c)),tt=w.i32_const(t.alloc(c)),rt=w.i32_const(t.alloc(c)),_t=w.i32_const(t.alloc(c)),gt=w.i32_const(t.alloc(c)),dt=w.i32_const(t.alloc(c));g.addCode(w.call(Q+"_frobeniusMap6",W,D),w.call(Q+"_inverse",W,et),w.call(Q+"_mul",D,et,tt),w.call(Q+"_copy",tt,et),w.call(Q+"_frobeniusMap2",tt,tt),w.call(Q+"_mul",tt,et,tt),w.call(a+"__cyclotomicSquare",tt,et),w.call(Q+"_conjugate",et,et),w.call(a+"__cyclotomicExp_w0",tt,rt),w.call(a+"__cyclotomicSquare",rt,_t),w.call(Q+"_mul",et,rt,gt),w.call(a+"__cyclotomicExp_w0",gt,et),w.call(a+"__cyclotomicExp_w0",et,D),w.call(a+"__cyclotomicExp_w0",D,dt),w.call(Q+"_mul",dt,_t,dt),w.call(a+"__cyclotomicExp_w0",dt,_t),w.call(Q+"_conjugate",gt,gt),w.call(Q+"_mul",_t,gt,_t),w.call(Q+"_mul",_t,tt,_t),w.call(Q+"_conjugate",tt,gt),w.call(Q+"_mul",et,tt,et),w.call(Q+"_frobeniusMap3",et,et),w.call(Q+"_mul",dt,gt,dt),w.call(Q+"_frobeniusMap1",dt,dt),w.call(Q+"_mul",rt,D,rt),w.call(Q+"_frobeniusMap2",rt,rt),w.call(Q+"_mul",rt,et,rt),w.call(Q+"_mul",rt,dt,rt),w.call(Q+"_mul",rt,_t,at))}function Dt(){const g=t.addFunction(a+"_finalExponentiationOld");g.addParam("x","i32"),g.addParam("r","i32");const W=t.alloc(Ot.bigInt2BytesLE(322277361516934140462891564586510139908379969514828494218366688025288661041104682794998680497580008899973249814104447692778988208376779573819485263026159588510513834876303014016798809919343532899164848730280942609956670917565618115867287399623286813270357901731510188149934363360381614501334086825442271920079363289954510565375378443704372994881406797882676971082200626541916413184642520269678897559532260949334760604962086348898118982248842634379637598665468817769075878555493752214492790122785850202957575200176084204422751485957336465472324810982833638490904279282696134323072515220044451592646885410572234451732790590013479358343841220074174848221722017083597872017638514103174122784843925578370430843522959600095676285723737049438346544753168912974976791528535276317256904336520179281145394686565050419250614107803233314658825463117900250701199181529205942363159325765991819433914303908860460720581408201373164047773794825411011922305820065611121544561808414055302212057471395719432072209245600258134364584636810093520285711072578721435517884103526483832733289802426157301542744476740008494780363354305116978805620671467071400711358839553375340724899735460480144599782014906586543813292157922220645089192130209334926661588737007768565838519456601560804957985667880395221049249803753582637708560n,544)),at=g.getCodeBuilder();g.addCode(at.call(Q+"_exp",at.getLocal("x"),at.i32_const(W),at.i32_const(544),at.getLocal("r")))}const vt=t.alloc(u),bt=t.alloc(x);function qt(g){const w=t.addFunction(a+"_pairingEq"+g);for(let et=0;et<g;et++)w.addParam("p_"+et,"i32"),w.addParam("q_"+et,"i32");w.addParam("c","i32"),w.setReturnType("i32");const W=w.getCodeBuilder(),at=W.i32_const(t.alloc(c)),D=W.i32_const(t.alloc(c));w.addCode(W.call(Q+"_one",at));for(let et=0;et<g;et++)w.addCode(W.call(a+"_prepareG1",W.getLocal("p_"+et),W.i32_const(vt))),w.addCode(W.call(a+"_prepareG2",W.getLocal("q_"+et),W.i32_const(bt))),w.addCode(W.if(W.i32_eqz(W.call(E+"_inGroupAffine",W.i32_const(vt))),W.ret(W.i32_const(0))),W.if(W.i32_eqz(W.call(P+"_inGroupAffine",W.i32_const(bt))),W.ret(W.i32_const(0)))),w.addCode(W.call(a+"_millerLoop",W.i32_const(vt),W.i32_const(bt),D)),w.addCode(W.call(Q+"_mul",at,D,at));w.addCode(W.call(a+"_finalExponentiation",at,at)),w.addCode(W.call(Q+"_eq",at,W.getLocal("c")))}function Yt(){const g=t.addFunction(a+"_pairing");g.addParam("p","i32"),g.addParam("q","i32"),g.addParam("r","i32");const w=g.getCodeBuilder(),W=w.i32_const(t.alloc(c));g.addCode(w.call(a+"_prepareG1",w.getLocal("p"),w.i32_const(vt))),g.addCode(w.call(a+"_prepareG2",w.getLocal("q"),w.i32_const(bt))),g.addCode(w.call(a+"_millerLoop",w.i32_const(vt),w.i32_const(bt),W)),g.addCode(w.call(a+"_finalExponentiation",W,w.getLocal("r")))}function Ht(){const g=t.addFunction(P+"_inGroupAffine");g.addParam("p","i32"),g.setReturnType("i32");const w=g.getCodeBuilder(),W=[2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279894n,2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279893n],at=4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n,D=[2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n,2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n],et=w.i32_const(t.alloc([...Ot.bigInt2BytesLE(I(W[0]),s),...Ot.bigInt2BytesLE(I(W[1]),s)])),tt=w.i32_const(t.alloc(Ot.bigInt2BytesLE(I(at),s))),rt=w.i32_const(t.alloc([...Ot.bigInt2BytesLE(I(D[0]),s),...Ot.bigInt2BytesLE(I(D[1]),s)])),_t=w.i32_const(t.alloc(Ot.bigInt2BytesLE(p,8))),gt=w.getLocal("p"),dt=w.i32_add(w.getLocal("p"),w.i32_const(d)),wt=w.i32_const(t.alloc(h)),It=w.i32_const(t.alloc(d)),Ct=w.i32_const(t.alloc(d)),mt=t.alloc(d*2),St=w.i32_const(mt),xt=w.i32_const(mt),Qt=w.i32_const(mt),Gt=w.i32_const(mt+h),Pt=w.i32_const(mt+d),Et=w.i32_const(mt+d),jt=w.i32_const(mt+d+h),ln=t.alloc(d*3),gn=w.i32_const(ln),aa=w.i32_const(ln),Un=w.i32_const(ln),Mn=w.i32_const(ln+h),ia=w.i32_const(ln+d),zn=w.i32_const(ln+d),qn=w.i32_const(ln+d+h),ea=w.i32_const(ln+d*2);g.addCode(w.if(w.call(P+"_isZeroAffine",w.getLocal("p")),w.ret(w.i32_const(1))),w.if(w.i32_eqz(w.call(P+"_inCurveAffine",w.getLocal("p"))),w.ret(w.i32_const(0))),w.call(A+"_mul",gt,et,It),w.call(A+"_mul",dt,et,Ct),w.call(A+"_mul1",It,tt,xt),w.call(A+"_neg",Ct,Pt),w.call(A+"_neg",It,aa),w.call(A+"_mul",Ct,rt,ia),w.call(T+"_sub",Qt,Gt,wt),w.call(T+"_add",Qt,Gt,Gt),w.call(T+"_copy",wt,Qt),w.call(T+"_sub",Et,jt,wt),w.call(T+"_add",Et,jt,jt),w.call(T+"_copy",wt,Et),w.call(T+"_add",Un,Mn,wt),w.call(T+"_sub",Un,Mn,Mn),w.call(T+"_copy",wt,Un),w.call(T+"_sub",qn,zn,wt),w.call(T+"_add",zn,qn,qn),w.call(T+"_copy",wt,zn),w.call(A+"_one",ea),w.call(P+"_timesScalar",gn,_t,w.i32_const(8),gn),w.call(P+"_addMixed",gn,St,gn),w.ret(w.call(P+"_eqMixed",gn,w.getLocal("p"))));const Sn=t.addFunction(P+"_inGroup");Sn.addParam("pIn","i32"),Sn.setReturnType("i32");const Cn=Sn.getCodeBuilder(),Hn=Cn.i32_const(t.alloc(d*2));Sn.addCode(Cn.call(P+"_toAffine",Cn.getLocal("pIn"),Hn),Cn.ret(Cn.call(P+"_inGroupAffine",Hn)))}function ot(){const g=t.addFunction(E+"_inGroupAffine");g.addParam("p","i32"),g.setReturnType("i32");const w=g.getCodeBuilder(),W=4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n,at=793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n,D=(p*p-1n)/3n,et=w.i32_const(t.alloc(Ot.bigInt2BytesLE(I(W),s))),tt=w.i32_const(t.alloc(Ot.bigInt2BytesLE(I(at),s))),rt=w.i32_const(t.alloc(Ot.bigInt2BytesLE(D,16))),_t=w.getLocal("p"),gt=w.i32_add(w.getLocal("p"),w.i32_const(h)),dt=t.alloc(h*3),wt=w.i32_const(dt),It=w.i32_const(dt),Ct=w.i32_const(dt+h),mt=t.alloc(h*2),St=w.i32_const(mt),xt=w.i32_const(mt),Qt=w.i32_const(mt+h);g.addCode(w.if(w.call(E+"_isZeroAffine",w.getLocal("p")),w.ret(w.i32_const(1))),w.if(w.i32_eqz(w.call(E+"_inCurveAffine",w.getLocal("p"))),w.ret(w.i32_const(0))),w.call(T+"_mul",_t,et,It),w.call(T+"_copy",gt,Ct),w.call(T+"_mul",_t,tt,xt),w.call(T+"_copy",gt,Qt),w.call(E+"_doubleAffine",wt,wt),w.call(E+"_subMixed",wt,w.getLocal("p"),wt),w.call(E+"_subMixed",wt,St,wt),w.call(E+"_timesScalar",wt,rt,w.i32_const(16),wt),w.ret(w.call(E+"_eqMixed",wt,St)));const Gt=t.addFunction(E+"_inGroup");Gt.addParam("pIn","i32"),Gt.setReturnType("i32");const Pt=Gt.getCodeBuilder(),Et=Pt.i32_const(t.alloc(h*2));Gt.addCode(Pt.call(E+"_toAffine",Pt.getLocal("pIn"),Et),Pt.ret(Pt.call(E+"_inGroupAffine",Et)))}for(let g=0;g<10;g++)At(g),t.exportFunction(Q+"_frobeniusMap"+g);ot(),Ht(),lt(),H(),N(),ht(),Lt(),Dt(),$t();for(let g=1;g<=5;g++)qt(g),t.exportFunction(a+"_pairingEq"+g);Yt(),t.exportFunction(a+"_pairing"),t.exportFunction(a+"_prepareG1"),t.exportFunction(a+"_prepareG2"),t.exportFunction(a+"_millerLoop"),t.exportFunction(a+"_finalExponentiation"),t.exportFunction(a+"_finalExponentiationOld"),t.exportFunction(a+"__cyclotomicSquare"),t.exportFunction(a+"__cyclotomicExp_w0"),t.exportFunction(V+"_mul1"),t.exportFunction(V+"_mul01"),t.exportFunction(Q+"_mul014"),t.exportFunction(E+"_inGroupAffine"),t.exportFunction(E+"_inGroup"),t.exportFunction(P+"_inGroupAffine"),t.exportFunction(P+"_inGroup")},Xc=Dc,Jc=Yc;function zi(o){if(typeof o=="bigint"||o.eq!==void 0)return o.toString(10);if(o instanceof Uint8Array)return Ua(o,0);if(Array.isArray(o))return o.map(zi);if(typeof o=="object"){const t={};return Object.keys(o).forEach(a=>{t[a]=zi(o[a])}),t}else return o}function qi(o){if(typeof o=="string"&&/^[0-9]+$/.test(o))return BigInt(o);if(typeof o=="string"&&/^0x[0-9a-fA-F]+$/.test(o))return BigInt(o);if(Array.isArray(o))return o.map(qi);if(typeof o=="object"){if(o===null)return null;const t={};return Object.keys(o).forEach(a=>{t[a]=qi(o[a])}),t}else return o}function tl(o){let t=BigInt(0),n=o.length,a=0;const i=new DataView(o.buffer,o.byteOffset,o.byteLength);for(;n>0;)n>=4?(n-=4,t+=BigInt(i.getUint32(n))<<BigInt(a*8),a+=4):n>=2?(n-=2,t+=BigInt(i.getUint16(n))<<BigInt(a*8),a+=2):(n-=1,t+=BigInt(i.getUint8(n))<<BigInt(a*8),a+=1);return t}function nl(o,t){let n=o;const a=new Uint8Array(t),i=new DataView(a.buffer);let e=t;for(;e>0;)e-4>=0?(e-=4,i.setUint32(e,Number(n&BigInt(4294967295))),n=n>>BigInt(32)):e-2>=0?(e-=2,i.setUint16(e,Number(n&BigInt(65535))),n=n>>BigInt(16)):(e-=1,i.setUint8(e,Number(n&BigInt(255))),n=n>>BigInt(8));if(n)throw new Error("Number does not fit in this length");return a}function al(o){let t=BigInt(0),n=0;const a=new DataView(o.buffer,o.byteOffset,o.byteLength);for(;n<o.length;)n+4<=o.length?(t+=BigInt(a.getUint32(n,!0))<<BigInt(n*8),n+=4):n+2<=o.length?(t+=BigInt(a.getUint16(n,!0))<<BigInt(n*8),n+=2):(t+=BigInt(a.getUint8(n,!0))<<BigInt(n*8),n+=1);return t}function Ho(o,t){let n=o;typeof t>"u"&&(t=Math.floor((Ma(o)-1)/8)+1,t==0&&(t=1));const a=new Uint8Array(t),i=new DataView(a.buffer);let e=0;for(;e<t;)e+4<=t?(i.setUint32(e,Number(n&BigInt(4294967295)),!0),e+=4,n=n>>BigInt(32)):e+2<=t?(i.setUint16(e,Number(n&BigInt(65535)),!0),e+=2,n=n>>BigInt(16)):(i.setUint8(e,Number(n&BigInt(255)),!0),e+=1,n=n>>BigInt(8));if(n)throw new Error("Number does not fit in this length");return a}function Qi(o,t){if(typeof t=="bigint"||t.eq!==void 0)return t.toString(10);if(t instanceof Uint8Array)return o.toString(o.e(t));if(Array.isArray(t))return t.map(Qi.bind(this,o));if(typeof t=="object"){const n={};return Object.keys(t).forEach(i=>{n[i]=Qi(o,t[i])}),n}else return t}function Ri(o,t){if(typeof t=="string"&&/^[0-9]+$/.test(t))return o.e(t);if(typeof t=="string"&&/^0x[0-9a-fA-F]+$/.test(t))return o.e(t);if(Array.isArray(t))return t.map(Ri.bind(this,o));if(typeof t=="object"){if(t===null)return null;const n={};return Object.keys(t).forEach(i=>{n[i]=Ri(o,t[i])}),n}else return t}const Ea=[];for(let o=0;o<256;o++)Ea[o]=il(o,8);function il(o,t){let n=0,a=o;for(let i=0;i<t;i++)n<<=1,n=n|a&1,a>>=1;return n}function Ko(o,t){return(Ea[o>>>24]|Ea[o>>>16&255]<<8|Ea[o>>>8&255]<<16|Ea[o&255]<<24)>>>32-t}function _n(o){return((o&4294901760)!==0?(o&=4294901760,16):0)|((o&4278255360)!==0?(o&=4278255360,8):0)|((o&4042322160)!==0?(o&=4042322160,4):0)|((o&3435973836)!==0?(o&=3435973836,2):0)|(o&2863311530)!==0}function jo(o,t){const n=o.byteLength/t,a=_n(n);if(n!=1<<a)throw new Error("Invalid number of pointers");for(let i=0;i<n;i++){const e=Ko(i,a);if(i>e){const l=o.slice(i*t,(i+1)*t);o.set(o.slice(e*t,(e+1)*t),i*t),o.set(l,e*t)}}}function ge(o,t){const n=new Uint8Array(t*o.length);for(let a=0;a<o.length;a++)n.set(o[a],a*t);return n}function Ya(o,t){const n=o.byteLength/t,a=new Array(n);for(let i=0;i<n;i++)a[i]=o.slice(i*t,i*t+t);return a}var el=Object.freeze({__proto__:null,array2buffer:ge,beBuff2int:tl,beInt2Buff:nl,bitReverse:Ko,buffReverseBits:jo,buffer2array:Ya,leBuff2int:al,leInt2Buff:Ho,log2:_n,stringifyBigInts:zi,stringifyFElements:Qi,unstringifyBigInts:qi,unstringifyFElements:Ri});const sn=1<<30;class ft{constructor(t){this.buffers=[],this.byteLength=t;for(let n=0;n<t;n+=sn){const a=Math.min(t-n,sn);this.buffers.push(new Uint8Array(a))}}slice(t,n){n===void 0&&(n=this.byteLength),t===void 0&&(t=0);const a=n-t,i=Math.floor(t/sn),e=Math.floor((t+a-1)/sn);if(i==e||a==0)return this.buffers[i].slice(t%sn,t%sn+a);let l,s=i,h=t%sn,d=a;for(;d>0;){const c=h+d>sn?sn-h:d,f=new Uint8Array(this.buffers[s].buffer,this.buffers[s].byteOffset+h,c);if(c==a)return f.slice();l||(a<=sn?l=new Uint8Array(a):l=new ft(a)),l.set(f,a-d),d=d-c,s++,h=0}return l}set(t,n){n===void 0&&(n=0);const a=t.byteLength;if(a==0)return;const i=Math.floor(n/sn),e=Math.floor((n+a-1)/sn);if(i==e)return t instanceof ft&&t.buffers.length==1?this.buffers[i].set(t.buffers[0],n%sn):this.buffers[i].set(t,n%sn);let l=i,s=n%sn,h=a;for(;h>0;){const d=s+h>sn?sn-s:h,c=t.slice(a-h,a-h+d);new Uint8Array(this.buffers[l].buffer,this.buffers[l].byteOffset+s,d).set(c),h=h-d,l++,s=0}}}function Rn(o,t,n,a){return async function(e){const l=Math.floor(e.byteLength/n);if(l*n!==e.byteLength)throw new Error("Invalid buffer size");const s=Math.floor(l/o.concurrency),h=[];for(let y=0;y<o.concurrency;y++){let L;if(y<o.concurrency-1?L=s:L=l-y*s,L==0)continue;const T=[{cmd:"ALLOCSET",var:0,buff:e.slice(y*s*n,y*s*n+L*n)},{cmd:"ALLOC",var:1,len:a*L},{cmd:"CALL",fnName:t,params:[{var:0},{val:L},{var:1}]},{cmd:"GET",out:0,var:1,len:a*L}];h.push(o.queueAction(T))}const d=await Promise.all(h);let c;e instanceof ft?c=new ft(l*a):c=new Uint8Array(l*a);let f=0;for(let y=0;y<d.length;y++)c.set(d[y][0],f),f+=d[y][0].byteLength;return c}}class ke{constructor(t,n,a,i){if(this.tm=t,this.prefix=n,this.p=i,this.n8=a,this.type="F1",this.m=1,this.half=sa(i,jn),this.bitLength=Ma(i),this.mask=Tn(Za(jn,this.bitLength),jn),this.pOp1=t.alloc(a),this.pOp2=t.alloc(a),this.pOp3=t.alloc(a),this.tm.instance.exports[n+"_zero"](this.pOp1),this.zero=this.tm.getBuff(this.pOp1,this.n8),this.tm.instance.exports[n+"_one"](this.pOp1),this.one=this.tm.getBuff(this.pOp1,this.n8),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one),this.n64=Math.floor(a/8),this.n32=Math.floor(a/4),this.n64*8!=this.n8)throw new Error("n8 must be a multiple of 8");this.half=sa(this.p,jn),this.nqr=this.two;let e=this.exp(this.nqr,this.half);for(;!this.eq(e,this.negone);)this.nqr=this.add(this.nqr,this.one),e=this.exp(this.nqr,this.half);this.shift=this.mul(this.nqr,this.nqr),this.shiftInv=this.inv(this.shift),this.s=0;let l=Tn(this.p,jn);for(;!ee(l);)this.s=this.s+1,l=sa(l,jn);this.w=[],this.w[this.s]=this.exp(this.nqr,l);for(let s=this.s-1;s>=0;s--)this.w[s]=this.square(this.w[s+1]);if(!this.eq(this.w[0],this.one))throw new Error("Error calculating roots of unity");this.batchToMontgomery=Rn(t,n+"_batchToMontgomery",this.n8,this.n8),this.batchFromMontgomery=Rn(t,n+"_batchFromMontgomery",this.n8,this.n8)}op2(t,n,a){return this.tm.setBuff(this.pOp1,n),this.tm.setBuff(this.pOp2,a),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op2Bool(t,n,a){return this.tm.setBuff(this.pOp1,n),this.tm.setBuff(this.pOp2,a),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2)}op1(t,n){return this.tm.setBuff(this.pOp1,n),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op1Bool(t,n){return this.tm.setBuff(this.pOp1,n),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3)}add(t,n){return this.op2("_add",t,n)}eq(t,n){return this.op2Bool("_eq",t,n)}isZero(t){return this.op1Bool("_isZero",t)}sub(t,n){return this.op2("_sub",t,n)}neg(t){return this.op1("_neg",t)}inv(t){return this.op1("_inverse",t)}toMontgomery(t){return this.op1("_toMontgomery",t)}fromMontgomery(t){return this.op1("_fromMontgomery",t)}mul(t,n){return this.op2("_mul",t,n)}div(t,n){return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,n),this.tm.instance.exports[this.prefix+"_inverse"](this.pOp2,this.pOp2),this.tm.instance.exports[this.prefix+"_mul"](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}square(t){return this.op1("_square",t)}isSquare(t){return this.op1Bool("_isSquare",t)}sqrt(t){return this.op1("_sqrt",t)}exp(t,n){return n instanceof Uint8Array||(n=da(an(n))),this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,n),this.tm.instance.exports[this.prefix+"_exp"](this.pOp1,this.pOp2,n.byteLength,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}isNegative(t){return this.op1Bool("_isNegative",t)}e(t,n){if(t instanceof Uint8Array)return t;let a=an(t,n);Ao(a)?(a=Eo(a),Mi(a,this.p)&&(a=Fn(a,this.p)),a=Tn(this.p,a)):Mi(a,this.p)&&(a=Fn(a,this.p));const i=Ho(a,this.n8);return this.toMontgomery(i)}toString(t,n){const a=this.fromMontgomery(t),i=Ua(a,0);return ce(i,n)}fromRng(t){let n;const a=new Uint8Array(this.n8);do{n=vo;for(let i=0;i<this.n64;i++)n=oe(n,Za(t.nextU64(),64*i));n=se(n,this.mask)}while(Bo(n,this.p));return Oa(a,0,n,this.n8),a}random(){return this.fromRng(le())}toObject(t){const n=this.fromMontgomery(t);return Ua(n,0)}fromObject(t){const n=new Uint8Array(this.n8);return Oa(n,0,t,this.n8),this.toMontgomery(n)}toRprLE(t,n,a){t.set(this.fromMontgomery(a),n)}toRprBE(t,n,a){const i=this.fromMontgomery(a);for(let e=0;e<this.n8/2;e++){const l=i[e];i[e]=i[this.n8-1-e],i[this.n8-1-e]=l}t.set(i,n)}fromRprLE(t,n){n=n||0;const a=t.slice(n,n+this.n8);return this.toMontgomery(a)}async batchInverse(t){let n=!1;const a=this.n8,i=this.n8;Array.isArray(t)?(t=ge(t,a),n=!0):t=t.slice(0,t.byteLength);const e=Math.floor(t.byteLength/a);if(e*a!==t.byteLength)throw new Error("Invalid buffer size");const l=Math.floor(e/this.tm.concurrency),s=[];for(let f=0;f<this.tm.concurrency;f++){let y;if(f<this.tm.concurrency-1?y=l:y=e-f*l,y==0)continue;const v=[{cmd:"ALLOCSET",var:0,buff:t.slice(f*l*a,f*l*a+y*a)},{cmd:"ALLOC",var:1,len:i*y},{cmd:"CALL",fnName:this.prefix+"_batchInverse",params:[{var:0},{val:a},{val:y},{var:1},{val:i}]},{cmd:"GET",out:0,var:1,len:i*y}];s.push(this.tm.queueAction(v))}const h=await Promise.all(s);let d;t instanceof ft?d=new ft(e*i):d=new Uint8Array(e*i);let c=0;for(let f=0;f<h.length;f++)d.set(h[f][0],c),c+=h[f][0].byteLength;return n?Ya(d,i):d}}class $e{constructor(t,n,a){this.tm=t,this.prefix=n,this.F=a,this.type="F2",this.m=a.m*2,this.n8=this.F.n8*2,this.n32=this.F.n32*2,this.n64=this.F.n64*2,this.pOp1=t.alloc(a.n8*2),this.pOp2=t.alloc(a.n8*2),this.pOp3=t.alloc(a.n8*2),this.tm.instance.exports[n+"_zero"](this.pOp1),this.zero=t.getBuff(this.pOp1,this.n8),this.tm.instance.exports[n+"_one"](this.pOp1),this.one=t.getBuff(this.pOp1,this.n8),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one)}op2(t,n,a){return this.tm.setBuff(this.pOp1,n),this.tm.setBuff(this.pOp2,a),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op2Bool(t,n,a){return this.tm.setBuff(this.pOp1,n),this.tm.setBuff(this.pOp2,a),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2)}op1(t,n){return this.tm.setBuff(this.pOp1,n),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op1Bool(t,n){return this.tm.setBuff(this.pOp1,n),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3)}add(t,n){return this.op2("_add",t,n)}eq(t,n){return this.op2Bool("_eq",t,n)}isZero(t){return this.op1Bool("_isZero",t)}sub(t,n){return this.op2("_sub",t,n)}neg(t){return this.op1("_neg",t)}inv(t){return this.op1("_inverse",t)}isNegative(t){return this.op1Bool("_isNegative",t)}toMontgomery(t){return this.op1("_toMontgomery",t)}fromMontgomery(t){return this.op1("_fromMontgomery",t)}mul(t,n){return this.op2("_mul",t,n)}mul1(t,n){return this.op2("_mul1",t,n)}div(t,n){return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,n),this.tm.instance.exports[this.prefix+"_inverse"](this.pOp2,this.pOp2),this.tm.instance.exports[this.prefix+"_mul"](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}square(t){return this.op1("_square",t)}isSquare(t){return this.op1Bool("_isSquare",t)}sqrt(t){return this.op1("_sqrt",t)}exp(t,n){return n instanceof Uint8Array||(n=da(an(n))),this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,n),this.tm.instance.exports[this.prefix+"_exp"](this.pOp1,this.pOp2,n.byteLength,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}e(t,n){if(t instanceof Uint8Array)return t;if(Array.isArray(t)&&t.length==2){const a=this.F.e(t[0],n),i=this.F.e(t[1],n),e=new Uint8Array(this.F.n8*2);return e.set(a),e.set(i,this.F.n8*2),e}else throw new Error("invalid F2")}toString(t,n){const a=this.F.toString(t.slice(0,this.F.n8),n),i=this.F.toString(t.slice(this.F.n8),n);return`[${a}, ${i}]`}fromRng(t){const n=this.F.fromRng(t),a=this.F.fromRng(t),i=new Uint8Array(this.F.n8*2);return i.set(n),i.set(a,this.F.n8),i}random(){return this.fromRng(le())}toObject(t){const n=this.F.toObject(t.slice(0,this.F.n8)),a=this.F.toObject(t.slice(this.F.n8,this.F.n8*2));return[n,a]}fromObject(t){const n=new Uint8Array(this.F.n8*2),a=this.F.fromObject(t[0]),i=this.F.fromObject(t[1]);return n.set(a),n.set(i,this.F.n8),n}c1(t){return t.slice(0,this.F.n8)}c2(t){return t.slice(this.F.n8)}}class ol{constructor(t,n,a){this.tm=t,this.prefix=n,this.F=a,this.type="F3",this.m=a.m*3,this.n8=this.F.n8*3,this.n32=this.F.n32*3,this.n64=this.F.n64*3,this.pOp1=t.alloc(a.n8*3),this.pOp2=t.alloc(a.n8*3),this.pOp3=t.alloc(a.n8*3),this.tm.instance.exports[n+"_zero"](this.pOp1),this.zero=t.getBuff(this.pOp1,this.n8),this.tm.instance.exports[n+"_one"](this.pOp1),this.one=t.getBuff(this.pOp1,this.n8),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one)}op2(t,n,a){return this.tm.setBuff(this.pOp1,n),this.tm.setBuff(this.pOp2,a),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op2Bool(t,n,a){return this.tm.setBuff(this.pOp1,n),this.tm.setBuff(this.pOp2,a),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2)}op1(t,n){return this.tm.setBuff(this.pOp1,n),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}op1Bool(t,n){return this.tm.setBuff(this.pOp1,n),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3)}eq(t,n){return this.op2Bool("_eq",t,n)}isZero(t){return this.op1Bool("_isZero",t)}add(t,n){return this.op2("_add",t,n)}sub(t,n){return this.op2("_sub",t,n)}neg(t){return this.op1("_neg",t)}inv(t){return this.op1("_inverse",t)}isNegative(t){return this.op1Bool("_isNegative",t)}toMontgomery(t){return this.op1("_toMontgomery",t)}fromMontgomery(t){return this.op1("_fromMontgomery",t)}mul(t,n){return this.op2("_mul",t,n)}div(t,n){return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,n),this.tm.instance.exports[this.prefix+"_inverse"](this.pOp2,this.pOp2),this.tm.instance.exports[this.prefix+"_mul"](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.n8)}square(t){return this.op1("_square",t)}isSquare(t){return this.op1Bool("_isSquare",t)}sqrt(t){return this.op1("_sqrt",t)}exp(t,n){return n instanceof Uint8Array||(n=da(an(n))),this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,n),this.tm.instance.exports[this.prefix+"_exp"](this.pOp1,this.pOp2,n.byteLength,this.pOp3),this.getBuff(this.pOp3,this.n8)}e(t,n){if(t instanceof Uint8Array)return t;if(Array.isArray(t)&&t.length==3){const a=this.F.e(t[0],n),i=this.F.e(t[1],n),e=this.F.e(t[2],n),l=new Uint8Array(this.F.n8*3);return l.set(a),l.set(i,this.F.n8),l.set(e,this.F.n8*2),l}else throw new Error("invalid F3")}toString(t,n){const a=this.F.toString(t.slice(0,this.F.n8),n),i=this.F.toString(t.slice(this.F.n8,this.F.n8*2),n),e=this.F.toString(t.slice(this.F.n8*2),n);return`[${a}, ${i}, ${e}]`}fromRng(t){const n=this.F.fromRng(t),a=this.F.fromRng(t),i=this.F.fromRng(t),e=new Uint8Array(this.F.n8*3);return e.set(n),e.set(a,this.F.n8),e.set(i,this.F.n8*2),e}random(){return this.fromRng(le())}toObject(t){const n=this.F.toObject(t.slice(0,this.F.n8)),a=this.F.toObject(t.slice(this.F.n8,this.F.n8*2)),i=this.F.toObject(t.slice(this.F.n8*2,this.F.n8*3));return[n,a,i]}fromObject(t){const n=new Uint8Array(this.F.n8*3),a=this.F.fromObject(t[0]),i=this.F.fromObject(t[1]),e=this.F.fromObject(t[2]);return n.set(a),n.set(i,this.F.n8),n.set(e,this.F.n8*2),n}c1(t){return t.slice(0,this.F.n8)}c2(t){return t.slice(this.F.n8,this.F.n8*2)}c3(t){return t.slice(this.F.n8*2)}}class Ne{constructor(t,n,a,i,e,l){this.tm=t,this.prefix=n,this.F=a,this.pOp1=t.alloc(a.n8*3),this.pOp2=t.alloc(a.n8*3),this.pOp3=t.alloc(a.n8*3),this.tm.instance.exports[n+"_zero"](this.pOp1),this.zero=this.tm.getBuff(this.pOp1,a.n8*3),this.tm.instance.exports[n+"_zeroAffine"](this.pOp1),this.zeroAffine=this.tm.getBuff(this.pOp1,a.n8*2),this.one=this.tm.getBuff(i,a.n8*3),this.g=this.one,this.oneAffine=this.tm.getBuff(i,a.n8*2),this.gAffine=this.oneAffine,this.b=this.tm.getBuff(e,a.n8),l&&(this.cofactor=da(l)),this.negone=this.neg(this.one),this.two=this.add(this.one,this.one),this.batchLEMtoC=Rn(t,n+"_batchLEMtoC",a.n8*2,a.n8),this.batchLEMtoU=Rn(t,n+"_batchLEMtoU",a.n8*2,a.n8*2),this.batchCtoLEM=Rn(t,n+"_batchCtoLEM",a.n8,a.n8*2),this.batchUtoLEM=Rn(t,n+"_batchUtoLEM",a.n8*2,a.n8*2),this.batchToJacobian=Rn(t,n+"_batchToJacobian",a.n8*2,a.n8*3),this.batchToAffine=Rn(t,n+"_batchToAffine",a.n8*3,a.n8*2)}op2(t,n,a){return this.tm.setBuff(this.pOp1,n),this.tm.setBuff(this.pOp2,a),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.F.n8*3)}op2bool(t,n,a){return this.tm.setBuff(this.pOp1,n),this.tm.setBuff(this.pOp2,a),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp2,this.pOp3)}op1(t,n){return this.tm.setBuff(this.pOp1,n),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.F.n8*3)}op1Affine(t,n){return this.tm.setBuff(this.pOp1,n),this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3),this.tm.getBuff(this.pOp3,this.F.n8*2)}op1Bool(t,n){return this.tm.setBuff(this.pOp1,n),!!this.tm.instance.exports[this.prefix+t](this.pOp1,this.pOp3)}add(t,n){if(t.byteLength==this.F.n8*3){if(n.byteLength==this.F.n8*3)return this.op2("_add",t,n);if(n.byteLength==this.F.n8*2)return this.op2("_addMixed",t,n);throw new Error("invalid point size")}else if(t.byteLength==this.F.n8*2){if(n.byteLength==this.F.n8*3)return this.op2("_addMixed",n,t);if(n.byteLength==this.F.n8*2)return this.op2("_addAffine",t,n);throw new Error("invalid point size")}else throw new Error("invalid point size")}sub(t,n){if(t.byteLength==this.F.n8*3){if(n.byteLength==this.F.n8*3)return this.op2("_sub",t,n);if(n.byteLength==this.F.n8*2)return this.op2("_subMixed",t,n);throw new Error("invalid point size")}else if(t.byteLength==this.F.n8*2){if(n.byteLength==this.F.n8*3)return this.op2("_subMixed",n,t);if(n.byteLength==this.F.n8*2)return this.op2("_subAffine",t,n);throw new Error("invalid point size")}else throw new Error("invalid point size")}neg(t){if(t.byteLength==this.F.n8*3)return this.op1("_neg",t);if(t.byteLength==this.F.n8*2)return this.op1Affine("_negAffine",t);throw new Error("invalid point size")}double(t){if(t.byteLength==this.F.n8*3)return this.op1("_double",t);if(t.byteLength==this.F.n8*2)return this.op1("_doubleAffine",t);throw new Error("invalid point size")}isZero(t){if(t.byteLength==this.F.n8*3)return this.op1Bool("_isZero",t);if(t.byteLength==this.F.n8*2)return this.op1Bool("_isZeroAffine",t);throw new Error("invalid point size")}timesScalar(t,n){n instanceof Uint8Array||(n=da(an(n)));let a;if(t.byteLength==this.F.n8*3)a=this.prefix+"_timesScalar";else if(t.byteLength==this.F.n8*2)a=this.prefix+"_timesScalarAffine";else throw new Error("invalid point size");return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,n),this.tm.instance.exports[a](this.pOp1,this.pOp2,n.byteLength,this.pOp3),this.tm.getBuff(this.pOp3,this.F.n8*3)}timesFr(t,n){let a;if(t.byteLength==this.F.n8*3)a=this.prefix+"_timesFr";else if(t.byteLength==this.F.n8*2)a=this.prefix+"_timesFrAffine";else throw new Error("invalid point size");return this.tm.setBuff(this.pOp1,t),this.tm.setBuff(this.pOp2,n),this.tm.instance.exports[a](this.pOp1,this.pOp2,this.pOp3),this.tm.getBuff(this.pOp3,this.F.n8*3)}eq(t,n){if(t.byteLength==this.F.n8*3){if(n.byteLength==this.F.n8*3)return this.op2bool("_eq",t,n);if(n.byteLength==this.F.n8*2)return this.op2bool("_eqMixed",t,n);throw new Error("invalid point size")}else if(t.byteLength==this.F.n8*2){if(n.byteLength==this.F.n8*3)return this.op2bool("_eqMixed",n,t);if(n.byteLength==this.F.n8*2)return this.op2bool("_eqAffine",t,n);throw new Error("invalid point size")}else throw new Error("invalid point size")}toAffine(t){if(t.byteLength==this.F.n8*3)return this.op1Affine("_toAffine",t);if(t.byteLength==this.F.n8*2)return t;throw new Error("invalid point size")}toJacobian(t){if(t.byteLength==this.F.n8*3)return t;if(t.byteLength==this.F.n8*2)return this.op1("_toJacobian",t);throw new Error("invalid point size")}toRprUncompressed(t,n,a){if(this.tm.setBuff(this.pOp1,a),a.byteLength==this.F.n8*3)this.tm.instance.exports[this.prefix+"_toAffine"](this.pOp1,this.pOp1);else if(a.byteLength!=this.F.n8*2)throw new Error("invalid point size");this.tm.instance.exports[this.prefix+"_LEMtoU"](this.pOp1,this.pOp1);const i=this.tm.getBuff(this.pOp1,this.F.n8*2);t.set(i,n)}fromRprUncompressed(t,n){const a=t.slice(n,n+this.F.n8*2);return this.tm.setBuff(this.pOp1,a),this.tm.instance.exports[this.prefix+"_UtoLEM"](this.pOp1,this.pOp1),this.tm.getBuff(this.pOp1,this.F.n8*2)}toRprCompressed(t,n,a){if(this.tm.setBuff(this.pOp1,a),a.byteLength==this.F.n8*3)this.tm.instance.exports[this.prefix+"_toAffine"](this.pOp1,this.pOp1);else if(a.byteLength!=this.F.n8*2)throw new Error("invalid point size");this.tm.instance.exports[this.prefix+"_LEMtoC"](this.pOp1,this.pOp1);const i=this.tm.getBuff(this.pOp1,this.F.n8);t.set(i,n)}fromRprCompressed(t,n){const a=t.slice(n,n+this.F.n8);return this.tm.setBuff(this.pOp1,a),this.tm.instance.exports[this.prefix+"_CtoLEM"](this.pOp1,this.pOp2),this.tm.getBuff(this.pOp2,this.F.n8*2)}toUncompressed(t){const n=new Uint8Array(this.F.n8*2);return this.toRprUncompressed(n,0,t),n}toRprLEM(t,n,a){if(a.byteLength==this.F.n8*2){t.set(a,n);return}else if(a.byteLength==this.F.n8*3){this.tm.setBuff(this.pOp1,a),this.tm.instance.exports[this.prefix+"_toAffine"](this.pOp1,this.pOp1);const i=this.tm.getBuff(this.pOp1,this.F.n8*2);t.set(i,n)}else throw new Error("invalid point size")}fromRprLEM(t,n){return n=n||0,t.slice(n,n+this.F.n8*2)}toString(t,n){if(t.byteLength==this.F.n8*3){const a=this.F.toString(t.slice(0,this.F.n8),n),i=this.F.toString(t.slice(this.F.n8,this.F.n8*2),n),e=this.F.toString(t.slice(this.F.n8*2),n);return`[ ${a}, ${i}, ${e} ]`}else if(t.byteLength==this.F.n8*2){const a=this.F.toString(t.slice(0,this.F.n8),n),i=this.F.toString(t.slice(this.F.n8),n);return`[ ${a}, ${i} ]`}else throw new Error("invalid point size")}isValid(t){if(this.isZero(t))return!0;const n=this.F,a=this.toAffine(t),i=a.slice(0,this.F.n8),e=a.slice(this.F.n8,this.F.n8*2),l=n.add(n.mul(n.square(i),i),this.b),s=n.square(e);return n.eq(l,s)}fromRng(t){const n=this.F;let a=[],i,e;do a[0]=n.fromRng(t),i=t.nextBool(),e=n.add(n.mul(n.square(a[0]),a[0]),this.b);while(!n.isSquare(e));a[1]=n.sqrt(e);const l=n.isNegative(a[1]);i^l&&(a[1]=n.neg(a[1]));let s=new Uint8Array(this.F.n8*2);return s.set(a[0]),s.set(a[1],this.F.n8),this.cofactor&&(s=this.timesScalar(s,this.cofactor)),s}toObject(t){if(this.isZero(t))return[this.F.toObject(this.F.zero),this.F.toObject(this.F.one),this.F.toObject(this.F.zero)];const n=this.F.toObject(t.slice(0,this.F.n8)),a=this.F.toObject(t.slice(this.F.n8,this.F.n8*2));let i;return t.byteLength==this.F.n8*3?i=this.F.toObject(t.slice(this.F.n8*2,this.F.n8*3)):i=this.F.toObject(this.F.one),[n,a,i]}fromObject(t){const n=this.F.fromObject(t[0]),a=this.F.fromObject(t[1]);let i;if(t.length==3?i=this.F.fromObject(t[2]):i=this.F.one,this.F.isZero(i,this.F.one))return this.zeroAffine;if(this.F.eq(i,this.F.one)){const e=new Uint8Array(this.F.n8*2);return e.set(n),e.set(a,this.F.n8),e}else{const e=new Uint8Array(this.F.n8*3);return e.set(n),e.set(a,this.F.n8),e.set(i,this.F.n8*2),e}}e(t){return t instanceof Uint8Array?t:this.fromObject(t)}x(t){return this.toAffine(t).slice(0,this.F.n8)}y(t){return this.toAffine(t).slice(this.F.n8)}}function sl(o){let n,a;async function i(c){const f=new Uint8Array(c.code),y=await WebAssembly.compile(f);a=new WebAssembly.Memory({initial:c.init,maximum:32767}),n=await WebAssembly.instantiate(y,{env:{memory:a}})}function e(c){const f=new Uint32Array(a.buffer,0,1);for(;f[0]&3;)f[0]++;const y=f[0];if(f[0]+=c,f[0]+c>a.buffer.byteLength){const L=a.buffer.byteLength/65536;let v=Math.floor((f[0]+c)/65536)+1;v>32767&&(v=32767),a.grow(v-L)}return y}function l(c){const f=e(c.byteLength);return h(f,c),f}function s(c,f){const y=new Uint8Array(a.buffer);return new Uint8Array(y.buffer,y.byteOffset+c,f)}function h(c,f){new Uint8Array(a.buffer).set(new Uint8Array(f),c)}function d(c){if(c[0].cmd=="INIT")return i(c[0]);const f={vars:[],out:[]},L=new Uint32Array(a.buffer,0,1)[0];for(let T=0;T<c.length;T++)switch(c[T].cmd){case"ALLOCSET":f.vars[c[T].var]=l(c[T].buff);break;case"ALLOC":f.vars[c[T].var]=e(c[T].len);break;case"SET":h(f.vars[c[T].var],c[T].buff);break;case"CALL":{const B=[];for(let E=0;E<c[T].params.length;E++){const A=c[T].params[E];typeof A.var<"u"?B.push(f.vars[A.var]+(A.offset||0)):typeof A.val<"u"&&B.push(A.val)}n.exports[c[T].fnName](...B);break}case"GET":f.out[c[T].out]=s(f.vars[c[T].var],c[T].len).slice();break;default:throw new Error("Invalid cmd")}const v=new Uint32Array(a.buffer,0,1);return v[0]=L,f.out}return d}const wi=25;class De{constructor(){this.promise=new Promise((t,n)=>{this.reject=n,this.resolve=t})}}function cl(o){return new Promise(t=>setTimeout(t,o))}let ki;const Ve=`(function thread(self) {
    const MAXMEM = 32767;
    let instance;
    let memory;

    if (self) {
        self.onmessage = function(e) {
            let data;
            if (e.data) {
                data = e.data;
            } else {
                data = e;
            }

            if (data[0].cmd == "INIT") {
                init(data[0]).then(function() {
                    self.postMessage(data.result);
                });
            } else if (data[0].cmd == "TERMINATE") {
                self.close();
            } else {
                const res = runTask(data);
                self.postMessage(res);
            }
        };
    }

    async function init(data) {
        const code = new Uint8Array(data.code);
        const wasmModule = await WebAssembly.compile(code);
        memory = new WebAssembly.Memory({initial:data.init, maximum: MAXMEM});

        instance = await WebAssembly.instantiate(wasmModule, {
            env: {
                "memory": memory
            }
        });
    }



    function alloc(length) {
        const u32 = new Uint32Array(memory.buffer, 0, 1);
        while (u32[0] & 3) u32[0]++;  // Return always aligned pointers
        const res = u32[0];
        u32[0] += length;
        if (u32[0] + length > memory.buffer.byteLength) {
            const currentPages = memory.buffer.byteLength / 0x10000;
            let requiredPages = Math.floor((u32[0] + length) / 0x10000)+1;
            if (requiredPages>MAXMEM) requiredPages=MAXMEM;
            memory.grow(requiredPages-currentPages);
        }
        return res;
    }

    function allocBuffer(buffer) {
        const p = alloc(buffer.byteLength);
        setBuffer(p, buffer);
        return p;
    }

    function getBuffer(pointer, length) {
        const u8 = new Uint8Array(memory.buffer);
        return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);
    }

    function setBuffer(pointer, buffer) {
        const u8 = new Uint8Array(memory.buffer);
        u8.set(new Uint8Array(buffer), pointer);
    }

    function runTask(task) {
        if (task[0].cmd == "INIT") {
            return init(task[0]);
        }
        const ctx = {
            vars: [],
            out: []
        };
        const u32a = new Uint32Array(memory.buffer, 0, 1);
        const oldAlloc = u32a[0];
        for (let i=0; i<task.length; i++) {
            switch (task[i].cmd) {
            case "ALLOCSET":
                ctx.vars[task[i].var] = allocBuffer(task[i].buff);
                break;
            case "ALLOC":
                ctx.vars[task[i].var] = alloc(task[i].len);
                break;
            case "SET":
                setBuffer(ctx.vars[task[i].var], task[i].buff);
                break;
            case "CALL": {
                const params = [];
                for (let j=0; j<task[i].params.length; j++) {
                    const p = task[i].params[j];
                    if (typeof p.var !== "undefined") {
                        params.push(ctx.vars[p.var] + (p.offset || 0));
                    } else if (typeof p.val != "undefined") {
                        params.push(p.val);
                    }
                }
                instance.exports[task[i].fnName](...params);
                break;
            }
            case "GET":
                ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();
                break;
            default:
                throw new Error("Invalid cmd");
            }
        }
        const u32b = new Uint32Array(memory.buffer, 0, 1);
        u32b[0] = oldAlloc;
        return ctx.out;
    }


    return runTask;
})(self)`;if(globalThis?.Blob){const o=new TextEncoder().encode(Ve),t=new Blob([o],{type:"application/javascript"});ki=URL.createObjectURL(t)}else ki="data:application/javascript;base64,"+globalThis.btoa(Ve);async function ll(o,t){const n=new rl;n.memory=new WebAssembly.Memory({initial:wi}),n.u8=new Uint8Array(n.memory.buffer),n.u32=new Uint32Array(n.memory.buffer);const a=await WebAssembly.compile(o.code);if(n.instance=await WebAssembly.instantiate(a,{env:{memory:n.memory}}),globalThis?.Worker||(t=!0),n.singleThread=t,n.initalPFree=n.u32[0],n.pq=o.pq,n.pr=o.pr,n.pG1gen=o.pG1gen,n.pG1zero=o.pG1zero,n.pG2gen=o.pG2gen,n.pG2zero=o.pG2zero,n.pOneT=o.pOneT,t)n.code=o.code,n.taskManager=sl(),await n.taskManager([{cmd:"INIT",init:wi,code:n.code.slice()}]),n.concurrency=1;else{n.workers=[],n.pendingDeferreds=[],n.working=[];let e=2;typeof navigator=="object"&&navigator.hardwareConcurrency&&(e=navigator.hardwareConcurrency),e==0&&(e=2),e>64&&(e=64),n.concurrency=e;for(let s=0;s<e;s++)n.workers[s]=new Worker(ki),n.workers[s].addEventListener("message",i(s)),n.working[s]=!1;const l=[];for(let s=0;s<n.workers.length;s++){const h=o.code.slice();l.push(n.postAction(s,[{cmd:"INIT",init:wi,code:h}],[h.buffer]))}await Promise.all(l)}return n;function i(e){return function(l){let s;l&&l.data?s=l.data:s=l,n.working[e]=!1,n.pendingDeferreds[e].resolve(s),n.processWorks()}}}class rl{constructor(){this.actionQueue=[],this.oldPFree=0}startSyncOp(){if(this.oldPFree!=0)throw new Error("Sync operation in progress");this.oldPFree=this.u32[0]}endSyncOp(){if(this.oldPFree==0)throw new Error("No sync operation in progress");this.u32[0]=this.oldPFree,this.oldPFree=0}postAction(t,n,a,i){if(this.working[t])throw new Error("Posting a job t a working worker");return this.working[t]=!0,this.pendingDeferreds[t]=i||new De,this.workers[t].postMessage(n,a),this.pendingDeferreds[t].promise}processWorks(){for(let t=0;t<this.workers.length&&this.actionQueue.length>0;t++)if(this.working[t]==!1){const n=this.actionQueue.shift();this.postAction(t,n.data,n.transfers,n.deferred)}}queueAction(t,n){const a=new De;if(this.singleThread){const i=this.taskManager(t);a.resolve(i)}else this.actionQueue.push({data:t,transfers:n,deferred:a}),this.processWorks();return a.promise}resetMemory(){this.u32[0]=this.initalPFree}allocBuff(t){const n=this.alloc(t.byteLength);return this.setBuff(n,t),n}getBuff(t,n){return this.u8.slice(t,t+n)}setBuff(t,n){this.u8.set(new Uint8Array(n),t)}alloc(t){for(;this.u32[0]&3;)this.u32[0]++;const n=this.u32[0];return this.u32[0]+=t,n}async terminate(){for(let t=0;t<this.workers.length;t++)this.workers[t].postMessage([{cmd:"TERMINATE"}]);await cl(200)}}function Li(o,t){const n=o[t],a=o.Fr,i=o.tm;o[t].batchApplyKey=async function(e,l,s,h,d){h=h||"affine",d=d||"affine";let c,f,y,L,v;if(t=="G1")h=="jacobian"?(y=n.F.n8*3,c="g1m_batchApplyKey"):(y=n.F.n8*2,c="g1m_batchApplyKeyMixed"),L=n.F.n8*3,d=="jacobian"?v=n.F.n8*3:(f="g1m_batchToAffine",v=n.F.n8*2);else if(t=="G2")h=="jacobian"?(y=n.F.n8*3,c="g2m_batchApplyKey"):(y=n.F.n8*2,c="g2m_batchApplyKeyMixed"),L=n.F.n8*3,d=="jacobian"?v=n.F.n8*3:(f="g2m_batchToAffine",v=n.F.n8*2);else if(t=="Fr")c="frm_batchApplyKey",y=n.n8,L=n.n8,v=n.n8;else throw new Error("Invalid group: "+t);const T=Math.floor(e.byteLength/y),B=Math.floor(T/i.concurrency),E=[];s=a.e(s);let A=a.e(l);for(let I=0;I<i.concurrency;I++){let _;if(I<i.concurrency-1?_=B:_=T-I*B,_==0)continue;const b=[];b.push({cmd:"ALLOCSET",var:0,buff:e.slice(I*B*y,I*B*y+_*y)}),b.push({cmd:"ALLOCSET",var:1,buff:A}),b.push({cmd:"ALLOCSET",var:2,buff:s}),b.push({cmd:"ALLOC",var:3,len:_*Math.max(L,v)}),b.push({cmd:"CALL",fnName:c,params:[{var:0},{val:_},{var:1},{var:2},{var:3}]}),f&&b.push({cmd:"CALL",fnName:f,params:[{var:3},{val:_},{var:3}]}),b.push({cmd:"GET",out:0,var:3,len:_*v}),E.push(i.queueAction(b)),A=a.mul(A,a.exp(s,_))}const G=await Promise.all(E);let P;e instanceof ft?P=new ft(T*v):P=new Uint8Array(T*v);let U=0;for(let I=0;I<G.length;I++)P.set(G[I][0],U),U+=G[I][0].byteLength;return P}}function dl(o){const t=o.tm;o.pairing=function(a,i){t.startSyncOp();const e=t.allocBuff(o.G1.toJacobian(a)),l=t.allocBuff(o.G2.toJacobian(i)),s=t.alloc(o.Gt.n8);t.instance.exports[o.name+"_pairing"](e,l,s);const h=t.getBuff(s,o.Gt.n8);return t.endSyncOp(),h},o.pairingEq=async function(){let a,i;arguments.length%2==1?(a=arguments[arguments.length-1],i=(arguments.length-1)/2):(a=o.Gt.one,i=arguments.length/2);const e=[];for(let c=0;c<i;c++){const f=[],y=o.G1.toJacobian(arguments[c*2]);f.push({cmd:"ALLOCSET",var:0,buff:y}),f.push({cmd:"ALLOC",var:1,len:o.prePSize});const L=o.G2.toJacobian(arguments[c*2+1]);f.push({cmd:"ALLOCSET",var:2,buff:L}),f.push({cmd:"ALLOC",var:3,len:o.preQSize}),f.push({cmd:"ALLOC",var:4,len:o.Gt.n8}),f.push({cmd:"CALL",fnName:o.name+"_prepareG1",params:[{var:0},{var:1}]}),f.push({cmd:"CALL",fnName:o.name+"_prepareG2",params:[{var:2},{var:3}]}),f.push({cmd:"CALL",fnName:o.name+"_millerLoop",params:[{var:1},{var:3},{var:4}]}),f.push({cmd:"GET",out:0,var:4,len:o.Gt.n8}),e.push(t.queueAction(f))}const l=await Promise.all(e);t.startSyncOp();const s=t.alloc(o.Gt.n8);t.instance.exports.ftm_one(s);for(let c=0;c<l.length;c++){const f=t.allocBuff(l[c][0]);t.instance.exports.ftm_mul(s,f,s)}t.instance.exports[o.name+"_finalExponentiation"](s,s);const h=t.allocBuff(a),d=!!t.instance.exports.ftm_eq(s,h);return t.endSyncOp(),d},o.prepareG1=function(n){this.tm.startSyncOp();const a=this.tm.allocBuff(n),i=this.tm.alloc(this.prePSize);this.tm.instance.exports[this.name+"_prepareG1"](a,i);const e=this.tm.getBuff(i,this.prePSize);return this.tm.endSyncOp(),e},o.prepareG2=function(n){this.tm.startSyncOp();const a=this.tm.allocBuff(n),i=this.tm.alloc(this.preQSize);this.tm.instance.exports[this.name+"_prepareG2"](a,i);const e=this.tm.getBuff(i,this.preQSize);return this.tm.endSyncOp(),e},o.millerLoop=function(n,a){this.tm.startSyncOp();const i=this.tm.allocBuff(n),e=this.tm.allocBuff(a),l=this.tm.alloc(this.Gt.n8);this.tm.instance.exports[this.name+"_millerLoop"](i,e,l);const s=this.tm.getBuff(l,this.Gt.n8);return this.tm.endSyncOp(),s},o.finalExponentiation=function(n){this.tm.startSyncOp();const a=this.tm.allocBuff(n),i=this.tm.alloc(this.Gt.n8);this.tm.instance.exports[this.name+"_finalExponentiation"](a,i);const e=this.tm.getBuff(i,this.Gt.n8);return this.tm.endSyncOp(),e}}const He=[1,1,1,1,2,3,4,5,6,7,7,8,9,10,11,12,13,13,14,15,16,16,17,17,17,17,17,17,17,17,17,17];function Ke(o,t){const n=o[t],a=n.tm;async function i(l,s,h,d,c){if(!(l instanceof Uint8Array))throw d&&d.error(`${c} _multiExpChunk buffBases is not Uint8Array`),new Error(`${c} _multiExpChunk buffBases is not Uint8Array`);if(!(s instanceof Uint8Array))throw d&&d.error(`${c} _multiExpChunk buffScalars is not Uint8Array`),new Error(`${c} _multiExpChunk buffScalars is not Uint8Array`);h=h||"affine";let f,y;if(t=="G1")h=="affine"?(y="g1m_multiexpAffine_chunk",f=n.F.n8*2):(y="g1m_multiexp_chunk",f=n.F.n8*3);else if(t=="G2")h=="affine"?(y="g2m_multiexpAffine_chunk",f=n.F.n8*2):(y="g2m_multiexp_chunk",f=n.F.n8*3);else throw new Error("Invalid group");const L=Math.floor(l.byteLength/f);if(L==0)return n.zero;const v=Math.floor(s.byteLength/L);if(v*L!=s.byteLength)throw new Error("Scalar size does not match");const T=He[_n(L)],B=Math.floor((v*8-1)/T)+1,E=[];for(let P=0;P<B;P++){const U=[{cmd:"ALLOCSET",var:0,buff:l},{cmd:"ALLOCSET",var:1,buff:s},{cmd:"ALLOC",var:2,len:n.F.n8*3},{cmd:"CALL",fnName:y,params:[{var:0},{var:1},{val:v},{val:L},{val:P*T},{val:Math.min(v*8-P*T,T)},{var:2}]},{cmd:"GET",out:0,var:2,len:n.F.n8*3}];E.push(n.tm.queueAction(U))}const A=await Promise.all(E);let G=n.zero;for(let P=A.length-1;P>=0;P--){if(!n.isZero(G))for(let U=0;U<T;U++)G=n.double(G);G=n.add(G,A[P][0])}return G}async function e(l,s,h,d,c){let L;if(t=="G1")h=="affine"?L=n.F.n8*2:L=n.F.n8*3;else if(t=="G2")h=="affine"?L=n.F.n8*2:L=n.F.n8*3;else throw new Error("Invalid group");const v=Math.floor(l.byteLength/L);if(v==0)return n.zero;const T=Math.floor(s.byteLength/v);if(T*v!=s.byteLength)throw new Error("Scalar size does not match");const B=He[_n(v)],E=Math.floor((T*8-1)/B)+1;let A;A=Math.floor(v/(a.concurrency/E)),A>4194304&&(A=4194304),A<1024&&(A=1024);const G=[];for(let I=0;I<v;I+=A){d&&d.debug(`Multiexp start: ${c}: ${I}/${v}`);const _=Math.min(v-I,A),b=l.slice(I*L,(I+_)*L),$=s.slice(I*T,(I+_)*T);G.push(i(b,$,h,d,c).then(K=>(d&&d.debug(`Multiexp end: ${c}: ${I}/${v}`),K)))}const P=await Promise.all(G);let U=n.zero;for(let I=P.length-1;I>=0;I--)U=n.add(U,P[I]);return U}n.multiExp=async function(s,h,d,c){return await e(s,h,"jacobian",d,c)},n.multiExpAffine=async function(s,h,d,c){return await e(s,h,"affine",d,c)}}function mi(o,t){const n=o[t],a=o.Fr,i=n.tm;async function e(d,c,f,y,L,v){f=f||"affine",y=y||"affine";const T=14;let B,E,A,G,P,U,I,_;t=="G1"?(f=="affine"?(B=n.F.n8*2,G="g1m_batchToJacobian"):B=n.F.n8*3,E=n.F.n8*3,c&&(_="g1m_fftFinal"),I="g1m_fftJoin",U="g1m_fftMix",y=="affine"?(A=n.F.n8*2,P="g1m_batchToAffine"):A=n.F.n8*3):t=="G2"?(f=="affine"?(B=n.F.n8*2,G="g2m_batchToJacobian"):B=n.F.n8*3,E=n.F.n8*3,c&&(_="g2m_fftFinal"),I="g2m_fftJoin",U="g2m_fftMix",y=="affine"?(A=n.F.n8*2,P="g2m_batchToAffine"):A=n.F.n8*3):t=="Fr"&&(B=n.n8,E=n.n8,A=n.n8,c&&(_="frm_fftFinal"),U="frm_fftMix",I="frm_fftJoin");let b=!1;Array.isArray(d)?(d=ge(d,B),b=!0):d=d.slice(0,d.byteLength);const $=d.byteLength/B,K=_n($);if(1<<K!=$)throw new Error("fft must be multiple of 2");if(K==a.s+1){let V;return c?V=await s(d,f,y,L,v):V=await l(d,f,y,L,v),b?Ya(V,A):V}let j;c&&(j=a.inv(a.e($)));let M;jo(d,B);let S,z=Math.min(1<<T,$),q=$/z;for(;q<i.concurrency&&z>=16;)q*=2,z/=2;const Z=_n(z),Y=[];for(let V=0;V<q;V++){L&&L.debug(`${v}: fft ${K} mix start: ${V}/${q}`);const nt=[];nt.push({cmd:"ALLOC",var:0,len:E*z});const Q=d.slice(z*V*B,z*(V+1)*B);nt.push({cmd:"SET",var:0,buff:Q}),G&&nt.push({cmd:"CALL",fnName:G,params:[{var:0},{val:z},{var:0}]});for(let it=1;it<=Z;it++)nt.push({cmd:"CALL",fnName:U,params:[{var:0},{val:z},{val:it}]});Z==K?(_&&(nt.push({cmd:"ALLOCSET",var:1,buff:j}),nt.push({cmd:"CALL",fnName:_,params:[{var:0},{val:z},{var:1}]})),P&&nt.push({cmd:"CALL",fnName:P,params:[{var:0},{val:z},{var:0}]}),nt.push({cmd:"GET",out:0,var:0,len:z*A})):nt.push({cmd:"GET",out:0,var:0,len:E*z}),Y.push(i.queueAction(nt).then(it=>(L&&L.debug(`${v}: fft ${K} mix end: ${V}/${q}`),it)))}S=await Promise.all(Y);for(let V=0;V<q;V++)S[V]=S[V][0];for(let V=Z+1;V<=K;V++){L&&L.debug(`${v}: fft  ${K}  join: ${V}/${K}`);const nt=1<<K-V,Q=q/nt,it=[];for(let k=0;k<nt;k++)for(let J=0;J<Q/2;J++){const m=a.exp(a.w[V],J*z),r=a.w[V],C=k*Q+J,u=k*Q+J+Q/2,x=[];x.push({cmd:"ALLOCSET",var:0,buff:S[C]}),x.push({cmd:"ALLOCSET",var:1,buff:S[u]}),x.push({cmd:"ALLOCSET",var:2,buff:m}),x.push({cmd:"ALLOCSET",var:3,buff:r}),x.push({cmd:"CALL",fnName:I,params:[{var:0},{var:1},{val:z},{var:2},{var:3}]}),V==K?(_&&(x.push({cmd:"ALLOCSET",var:4,buff:j}),x.push({cmd:"CALL",fnName:_,params:[{var:0},{val:z},{var:4}]}),x.push({cmd:"CALL",fnName:_,params:[{var:1},{val:z},{var:4}]})),P&&(x.push({cmd:"CALL",fnName:P,params:[{var:0},{val:z},{var:0}]}),x.push({cmd:"CALL",fnName:P,params:[{var:1},{val:z},{var:1}]})),x.push({cmd:"GET",out:0,var:0,len:z*A}),x.push({cmd:"GET",out:1,var:1,len:z*A})):(x.push({cmd:"GET",out:0,var:0,len:z*E}),x.push({cmd:"GET",out:1,var:1,len:z*E})),it.push(i.queueAction(x).then(F=>(L&&L.debug(`${v}: fft ${K} join  ${V}/${K}  ${k+1}/${nt} ${J}/${Q/2}`),F)))}const X=await Promise.all(it);for(let k=0;k<nt;k++)for(let J=0;J<Q/2;J++){const m=k*Q+J,r=k*Q+J+Q/2,C=X.shift();S[m]=C[0],S[r]=C[1]}}if(d instanceof ft?M=new ft($*A):M=new Uint8Array($*A),c){M.set(S[0].slice((z-1)*A));let V=A;for(let nt=q-1;nt>0;nt--)M.set(S[nt],V),V+=z*A,delete S[nt];M.set(S[0].slice(0,(z-1)*A),V),delete S[0]}else for(let V=0;V<q;V++)M.set(S[V],z*A*V),delete S[V];return b?Ya(M,A):M}async function l(d,c,f,y,L){let v,T;v=d.slice(0,d.byteLength/2),T=d.slice(d.byteLength/2,d.byteLength);const B=[];[v,T]=await h(v,T,"fftJoinExt",a.one,a.shift,c,"jacobian",y,L),B.push(e(v,!1,"jacobian",f,y,L)),B.push(e(T,!1,"jacobian",f,y,L));const E=await Promise.all(B);let A;return E[0].byteLength>1<<28?A=new ft(E[0].byteLength*2):A=new Uint8Array(E[0].byteLength*2),A.set(E[0]),A.set(E[1],E[0].byteLength),A}async function s(d,c,f,y,L){let v,T;v=d.slice(0,d.byteLength/2),T=d.slice(d.byteLength/2,d.byteLength);const B=[];B.push(e(v,!0,c,"jacobian",y,L)),B.push(e(T,!0,c,"jacobian",y,L)),[v,T]=await Promise.all(B);const E=await h(v,T,"fftJoinExtInv",a.one,a.shiftInv,"jacobian",f,y,L);let A;return E[0].byteLength>1<<28?A=new ft(E[0].byteLength*2):A=new Uint8Array(E[0].byteLength*2),A.set(E[0]),A.set(E[1],E[0].byteLength),A}async function h(d,c,f,y,L,v,T,B,E){let P,U,I,_,b,$;if(t=="G1")v=="affine"?(b=n.F.n8*2,U="g1m_batchToJacobian"):b=n.F.n8*3,$=n.F.n8*3,P="g1m_"+f,T=="affine"?(I="g1m_batchToAffine",_=n.F.n8*2):_=n.F.n8*3;else if(t=="G2")v=="affine"?(b=n.F.n8*2,U="g2m_batchToJacobian"):b=n.F.n8*3,P="g2m_"+f,$=n.F.n8*3,T=="affine"?(I="g2m_batchToAffine",_=n.F.n8*2):_=n.F.n8*3;else if(t=="Fr")b=a.n8,_=a.n8,$=a.n8,P="frm_"+f;else throw new Error("Invalid group");if(d.byteLength!=c.byteLength)throw new Error("Invalid buffer size");const K=Math.floor(d.byteLength/b);if(K!=1<<_n(K))throw new Error("Invalid number of points");let j=Math.floor(K/i.concurrency);j<16&&(j=16),j>65536&&(j=65536);const M=[];for(let Y=0;Y<K;Y+=j){B&&B.debug(`${E}: fftJoinExt Start: ${Y}/${K}`);const V=Math.min(K-Y,j),nt=a.mul(y,a.exp(L,Y)),Q=[],it=d.slice(Y*b,(Y+V)*b),X=c.slice(Y*b,(Y+V)*b);Q.push({cmd:"ALLOC",var:0,len:$*V}),Q.push({cmd:"SET",var:0,buff:it}),Q.push({cmd:"ALLOC",var:1,len:$*V}),Q.push({cmd:"SET",var:1,buff:X}),Q.push({cmd:"ALLOCSET",var:2,buff:nt}),Q.push({cmd:"ALLOCSET",var:3,buff:L}),U&&(Q.push({cmd:"CALL",fnName:U,params:[{var:0},{val:V},{var:0}]}),Q.push({cmd:"CALL",fnName:U,params:[{var:1},{val:V},{var:1}]})),Q.push({cmd:"CALL",fnName:P,params:[{var:0},{var:1},{val:V},{var:2},{var:3},{val:a.s}]}),I&&(Q.push({cmd:"CALL",fnName:I,params:[{var:0},{val:V},{var:0}]}),Q.push({cmd:"CALL",fnName:I,params:[{var:1},{val:V},{var:1}]})),Q.push({cmd:"GET",out:0,var:0,len:V*_}),Q.push({cmd:"GET",out:1,var:1,len:V*_}),M.push(i.queueAction(Q).then(k=>(B&&B.debug(`${E}: fftJoinExt End: ${Y}/${K}`),k)))}const S=await Promise.all(M);let z,q;K*_>1<<28?(z=new ft(K*_),q=new ft(K*_)):(z=new Uint8Array(K*_),q=new Uint8Array(K*_));let Z=0;for(let Y=0;Y<S.length;Y++)z.set(S[Y][0],Z),q.set(S[Y][1],Z),Z+=S[Y][0].byteLength;return[z,q]}n.fft=async function(d,c,f,y,L){return await e(d,!1,c,f,y,L)},n.ifft=async function(d,c,f,y,L){return await e(d,!0,c,f,y,L)},n.lagrangeEvaluations=async function(d,c,f,y,L){c=c||"affine",f=f||"affine";let v;if(t=="G1")c=="affine"?v=n.F.n8*2:v=n.F.n8*3;else if(t=="G2")c=="affine"?v=n.F.n8*2:v=n.F.n8*3;else if(t=="Fr")v=a.n8;else throw new Error("Invalid group");const T=d.byteLength/v,B=_n(T);if(2**B*v!=d.byteLength)throw y&&y.error("lagrangeEvaluations iinvalid input size"),new Error("lagrangeEvaluations invalid Input size");if(B<=a.s)return await n.ifft(d,c,f,y,L);if(B>a.s+1)throw y&&y.error("lagrangeEvaluations input too big"),new Error("lagrangeEvaluations input too big");let E=d.slice(0,d.byteLength/2),A=d.slice(d.byteLength/2,d.byteLength);const G=a.exp(a.shift,T/2),P=a.inv(a.sub(a.one,G));[E,A]=await h(E,A,"prepareLagrangeEvaluation",P,a.shiftInv,c,"jacobian",y,L+" prep");const U=[];U.push(e(E,!0,"jacobian",f,y,L+" t0")),U.push(e(A,!0,"jacobian",f,y,L+" t1")),[E,A]=await Promise.all(U);let I;return E.byteLength>1<<28?I=new ft(E.byteLength*2):I=new Uint8Array(E.byteLength*2),I.set(E),I.set(A,E.byteLength),I},n.fftMix=async function(c){const f=n.F.n8*3;let y,L;if(t=="G1")y="g1m_fftMix",L="g1m_fftJoin";else if(t=="G2")y="g2m_fftMix",L="g2m_fftJoin";else if(t=="Fr")y="frm_fftMix",L="frm_fftJoin";else throw new Error("Invalid group");const v=Math.floor(c.byteLength/f),T=_n(v);let B=1<<_n(i.concurrency);v<=B*2&&(B=1);const E=v/B,A=_n(E),G=[];for(let b=0;b<B;b++){const $=[],K=c.slice(b*E*f,(b+1)*E*f);$.push({cmd:"ALLOCSET",var:0,buff:K});for(let j=1;j<=A;j++)$.push({cmd:"CALL",fnName:y,params:[{var:0},{val:E},{val:j}]});$.push({cmd:"GET",out:0,var:0,len:E*f}),G.push(i.queueAction($))}const P=await Promise.all(G),U=[];for(let b=0;b<P.length;b++)U[b]=P[b][0];for(let b=A+1;b<=T;b++){const $=1<<T-b,K=B/$,j=[];for(let S=0;S<$;S++)for(let z=0;z<K/2;z++){const q=a.exp(a.w[b],z*E),Z=a.w[b],Y=S*K+z,V=S*K+z+K/2,nt=[];nt.push({cmd:"ALLOCSET",var:0,buff:U[Y]}),nt.push({cmd:"ALLOCSET",var:1,buff:U[V]}),nt.push({cmd:"ALLOCSET",var:2,buff:q}),nt.push({cmd:"ALLOCSET",var:3,buff:Z}),nt.push({cmd:"CALL",fnName:L,params:[{var:0},{var:1},{val:E},{var:2},{var:3}]}),nt.push({cmd:"GET",out:0,var:0,len:E*f}),nt.push({cmd:"GET",out:1,var:1,len:E*f}),j.push(i.queueAction(nt))}const M=await Promise.all(j);for(let S=0;S<$;S++)for(let z=0;z<K/2;z++){const q=S*K+z,Z=S*K+z+K/2,Y=M.shift();U[q]=Y[0],U[Z]=Y[1]}}let I;c instanceof ft?I=new ft(v*f):I=new Uint8Array(v*f);let _=0;for(let b=0;b<B;b++)I.set(U[b],_),_+=U[b].byteLength;return I},n.fftJoin=async function(c,f,y,L){const v=n.F.n8*3;let T;if(t=="G1")T="g1m_fftJoin";else if(t=="G2")T="g2m_fftJoin";else if(t=="Fr")T="frm_fftJoin";else throw new Error("Invalid group");if(c.byteLength!=f.byteLength)throw new Error("Invalid buffer size");const B=Math.floor(c.byteLength/v);if(B!=1<<_n(B))throw new Error("Invalid number of points");let E=1<<_n(i.concurrency);B<=E*2&&(E=1);const A=B/E,G=[];for(let b=0;b<E;b++){const $=[],K=a.mul(y,a.exp(L,b*A)),j=c.slice(b*A*v,(b+1)*A*v),M=f.slice(b*A*v,(b+1)*A*v);$.push({cmd:"ALLOCSET",var:0,buff:j}),$.push({cmd:"ALLOCSET",var:1,buff:M}),$.push({cmd:"ALLOCSET",var:2,buff:K}),$.push({cmd:"ALLOCSET",var:3,buff:L}),$.push({cmd:"CALL",fnName:T,params:[{var:0},{var:1},{val:A},{var:2},{var:3}]}),$.push({cmd:"GET",out:0,var:0,len:A*v}),$.push({cmd:"GET",out:1,var:1,len:A*v}),G.push(i.queueAction($))}const P=await Promise.all(G);let U,I;c instanceof ft?(U=new ft(B*v),I=new ft(B*v)):(U=new Uint8Array(B*v),I=new Uint8Array(B*v));let _=0;for(let b=0;b<P.length;b++)U.set(P[b][0],_),I.set(P[b][1],_),_+=P[b][0].byteLength;return[U,I]},n.fftFinal=async function(c,f){const y=n.F.n8*3,L=n.F.n8*2;let v,T;if(t=="G1")v="g1m_fftFinal",T="g1m_batchToAffine";else if(t=="G2")v="g2m_fftFinal",T="g2m_batchToAffine";else throw new Error("Invalid group");const B=Math.floor(c.byteLength/y);if(B!=1<<_n(B))throw new Error("Invalid number of points");const E=Math.floor(B/i.concurrency),A=[];for(let I=0;I<i.concurrency;I++){let _;if(I<i.concurrency-1?_=E:_=B-I*E,_==0)continue;const b=[],$=c.slice(I*E*y,(I*E+_)*y);b.push({cmd:"ALLOCSET",var:0,buff:$}),b.push({cmd:"ALLOCSET",var:1,buff:f}),b.push({cmd:"CALL",fnName:v,params:[{var:0},{val:_},{var:1}]}),b.push({cmd:"CALL",fnName:T,params:[{var:0},{val:_},{var:0}]}),b.push({cmd:"GET",out:0,var:0,len:_*L}),A.push(i.queueAction(b))}const G=await Promise.all(A);let P;c instanceof ft?P=new ft(B*L):P=new Uint8Array(B*L);let U=0;for(let I=G.length-1;I>=0;I--)P.set(G[I][0],U),U+=G[I][0].byteLength;return P}}async function Zo(o){const t=await ll(o.wasm,o.singleThread),n={};return n.q=an(o.wasm.q.toString()),n.r=an(o.wasm.r.toString()),n.name=o.name,n.tm=t,n.prePSize=o.wasm.prePSize,n.preQSize=o.wasm.preQSize,n.Fr=new ke(t,"frm",o.n8r,o.r),n.F1=new ke(t,"f1m",o.n8q,o.q),n.F2=new $e(t,"f2m",n.F1),n.G1=new Ne(t,"g1m",n.F1,o.wasm.pG1gen,o.wasm.pG1b,o.cofactorG1),n.G2=new Ne(t,"g2m",n.F2,o.wasm.pG2gen,o.wasm.pG2b,o.cofactorG2),n.F6=new ol(t,"f6m",n.F2),n.F12=new $e(t,"ftm",n.F6),n.Gt=n.F12,Li(n,"G1"),Li(n,"G2"),Li(n,"Fr"),Ke(n,"G1"),Ke(n,"G2"),mi(n,"G1"),mi(n,"G2"),mi(n,"Fr"),dl(n),n.array2buffer=function(a,i){const e=new Uint8Array(i*a.length);for(let l=0;l<a.length;l++)e.set(a[l],l*i);return e},n.buffer2array=function(a,i){const e=a.byteLength/i,l=new Array(e);for(let s=0;s<e;s++)l[s]=a.slice(s*i,s*i+i);return l},n}function ha(o){return BigInt(o)}function Wo(o){return o<0n}function ul(o){return o===0n}function fl(o){return Wo(o)?o.toString(2).length-1:o.toString(2).length}function bi(o){const t=[],n=ha(o);return t.push(Number(n&0xFFn)),t.push(Number(n>>8n&0xFFn)),t.push(Number(n>>16n&0xFFn)),t.push(Number(n>>24n&0xFFn)),t}function hl(o){for(var t=[],n=0;n<o.length;n++){var a=o.charCodeAt(n);a<128?t.push(a):a<2048?t.push(192|a>>6,128|a&63):a<55296||a>=57344?t.push(224|a>>12,128|a>>6&63,128|a&63):(n++,a=65536+((a&1023)<<10|o.charCodeAt(n)&1023),t.push(240|a>>18,128|a>>12&63,128|a>>6&63,128|a&63))}return t}function ya(o){const t=hl(o);return[...Ut(t.length),...t]}function Yo(o){const t=[];let n=ha(o);if(Wo(n))throw new Error("Number cannot be negative");for(;!ul(n);)t.push(Number(n&0x7Fn)),n=n>>7n;t.length==0&&t.push(0);for(let a=0;a<t.length-1;a++)t[a]=t[a]|128;return t}function Xo(o){let t,n;const a=fl(o);o<0?(n=!0,t=(1n<<BigInt(a))+o):(n=!1,t=ha(o));const i=7-a%7,e=(1n<<BigInt(i))-1n<<BigInt(a),l=(1<<7-i)-1|128,s=Yo(t+e);return n||(s[s.length-1]=s[s.length-1]&l),s}function $i(o){let t=ha(o);if(t>0xFFFFFFFFn)throw new Error("Number too big");if(t>0x7FFFFFFFn&&(t=t-0x100000000n),t<-2147483648n)throw new Error("Number too small");return Xo(t)}function _l(o){let t=ha(o);if(t>0xFFFFFFFFFFFFFFFFn)throw new Error("Number too big");if(t>0x7FFFFFFFFFFFFFFFn&&(t=t-0x10000000000000000n),t<-9223372036854775808n)throw new Error("Number too small");return Xo(t)}function Ut(o){let t=ha(o);if(t>0xFFFFFFFFn)throw new Error("Number too big");return Yo(t)}function je(o){return Array.from(o,function(t){return("0"+(t&255).toString(16)).slice(-2)}).join("")}class gl{constructor(t){this.func=t,this.functionName=t.functionName,this.module=t.module}setLocal(t,n){const a=this.func.localIdxByName[t];if(a===void 0)throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${t} `);return[...n,33,...Ut(a)]}teeLocal(t,n){const a=this.func.localIdxByName[t];if(a===void 0)throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${t} `);return[...n,34,...Ut(a)]}getLocal(t){const n=this.func.localIdxByName[t];if(n===void 0)throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${t} `);return[32,...Ut(n)]}i64_load8_s(t,n,a){const i=n||0,e=a===void 0?0:a;return[...t,48,e,...Ut(i)]}i64_load8_u(t,n,a){const i=n||0,e=a===void 0?0:a;return[...t,49,e,...Ut(i)]}i64_load16_s(t,n,a){const i=n||0,e=a===void 0?1:a;return[...t,50,e,...Ut(i)]}i64_load16_u(t,n,a){const i=n||0,e=a===void 0?1:a;return[...t,51,e,...Ut(i)]}i64_load32_s(t,n,a){const i=n||0,e=a===void 0?2:a;return[...t,52,e,...Ut(i)]}i64_load32_u(t,n,a){const i=n||0,e=a===void 0?2:a;return[...t,53,e,...Ut(i)]}i64_load(t,n,a){const i=n||0,e=a===void 0?3:a;return[...t,41,e,...Ut(i)]}i64_store(t,n,a,i){let e,l,s;return Array.isArray(n)?(e=0,l=3,s=n):Array.isArray(a)?(e=n,l=3,s=a):Array.isArray(i)&&(e=n,l=a,s=i),[...t,...s,55,l,...Ut(e)]}i64_store32(t,n,a,i){let e,l,s;return Array.isArray(n)?(e=0,l=2,s=n):Array.isArray(a)?(e=n,l=2,s=a):Array.isArray(i)&&(e=n,l=a,s=i),[...t,...s,62,l,...Ut(e)]}i64_store16(t,n,a,i){let e,l,s;return Array.isArray(n)?(e=0,l=1,s=n):Array.isArray(a)?(e=n,l=1,s=a):Array.isArray(i)&&(e=n,l=a,s=i),[...t,...s,61,l,...Ut(e)]}i64_store8(t,n,a,i){let e,l,s;return Array.isArray(n)?(e=0,l=0,s=n):Array.isArray(a)?(e=n,l=0,s=a):Array.isArray(i)&&(e=n,l=a,s=i),[...t,...s,60,l,...Ut(e)]}i32_load8_s(t,n,a){const i=n||0,e=a===void 0?0:a;return[...t,44,e,...Ut(i)]}i32_load8_u(t,n,a){const i=n||0,e=a===void 0?0:a;return[...t,45,e,...Ut(i)]}i32_load16_s(t,n,a){const i=n||0,e=a===void 0?1:a;return[...t,46,e,...Ut(i)]}i32_load16_u(t,n,a){const i=n||0,e=a===void 0?1:a;return[...t,47,e,...Ut(i)]}i32_load(t,n,a){const i=n||0,e=a===void 0?2:a;return[...t,40,e,...Ut(i)]}i32_store(t,n,a,i){let e,l,s;return Array.isArray(n)?(e=0,l=2,s=n):Array.isArray(a)?(e=n,l=2,s=a):Array.isArray(i)&&(e=n,l=a,s=i),[...t,...s,54,l,...Ut(e)]}i32_store16(t,n,a,i){let e,l,s;return Array.isArray(n)?(e=0,l=1,s=n):Array.isArray(a)?(e=n,l=1,s=a):Array.isArray(i)&&(e=n,l=a,s=i),[...t,...s,59,l,...Ut(e)]}i32_store8(t,n,a,i){let e,l,s;return Array.isArray(n)?(e=0,l=0,s=n):Array.isArray(a)?(e=n,l=0,s=a):Array.isArray(i)&&(e=n,l=a,s=i),[...t,...s,58,l,...Ut(e)]}call(t,...n){const a=this.module.functionIdxByName[t];if(a===void 0)throw new Error(`Function not defined: Function: ${t}`);return[...[].concat(...n),16,...Ut(a)]}call_indirect(t,...n){return[...[].concat(...n),...t,17,0,0]}if(t,n,a){return a?[...t,4,64,...n,5,...a,11]:[...t,4,64,...n,11]}block(t){return[2,64,...t,11]}loop(...t){return[3,64,...[].concat(...t),11]}br_if(t,n){return[...n,13,...Ut(t)]}br(t){return[12,...Ut(t)]}ret(t){return[...t,15]}drop(t){return[...t,26]}i64_const(t){return[66,..._l(t)]}i32_const(t){return[65,...$i(t)]}i64_eqz(t){return[...t,80]}i64_eq(t,n){return[...t,...n,81]}i64_ne(t,n){return[...t,...n,82]}i64_lt_s(t,n){return[...t,...n,83]}i64_lt_u(t,n){return[...t,...n,84]}i64_gt_s(t,n){return[...t,...n,85]}i64_gt_u(t,n){return[...t,...n,86]}i64_le_s(t,n){return[...t,...n,87]}i64_le_u(t,n){return[...t,...n,88]}i64_ge_s(t,n){return[...t,...n,89]}i64_ge_u(t,n){return[...t,...n,90]}i64_add(t,n){return[...t,...n,124]}i64_sub(t,n){return[...t,...n,125]}i64_mul(t,n){return[...t,...n,126]}i64_div_s(t,n){return[...t,...n,127]}i64_div_u(t,n){return[...t,...n,128]}i64_rem_s(t,n){return[...t,...n,129]}i64_rem_u(t,n){return[...t,...n,130]}i64_and(t,n){return[...t,...n,131]}i64_or(t,n){return[...t,...n,132]}i64_xor(t,n){return[...t,...n,133]}i64_shl(t,n){return[...t,...n,134]}i64_shr_s(t,n){return[...t,...n,135]}i64_shr_u(t,n){return[...t,...n,136]}i64_extend_i32_s(t){return[...t,172]}i64_extend_i32_u(t){return[...t,173]}i64_clz(t){return[...t,121]}i64_ctz(t){return[...t,122]}i32_eqz(t){return[...t,69]}i32_eq(t,n){return[...t,...n,70]}i32_ne(t,n){return[...t,...n,71]}i32_lt_s(t,n){return[...t,...n,72]}i32_lt_u(t,n){return[...t,...n,73]}i32_gt_s(t,n){return[...t,...n,74]}i32_gt_u(t,n){return[...t,...n,75]}i32_le_s(t,n){return[...t,...n,76]}i32_le_u(t,n){return[...t,...n,77]}i32_ge_s(t,n){return[...t,...n,78]}i32_ge_u(t,n){return[...t,...n,79]}i32_add(t,n){return[...t,...n,106]}i32_sub(t,n){return[...t,...n,107]}i32_mul(t,n){return[...t,...n,108]}i32_div_s(t,n){return[...t,...n,109]}i32_div_u(t,n){return[...t,...n,110]}i32_rem_s(t,n){return[...t,...n,111]}i32_rem_u(t,n){return[...t,...n,112]}i32_and(t,n){return[...t,...n,113]}i32_or(t,n){return[...t,...n,114]}i32_xor(t,n){return[...t,...n,115]}i32_shl(t,n){return[...t,...n,116]}i32_shr_s(t,n){return[...t,...n,117]}i32_shr_u(t,n){return[...t,...n,118]}i32_rotl(t,n){return[...t,...n,119]}i32_rotr(t,n){return[...t,...n,120]}i32_wrap_i64(t){return[...t,167]}i32_clz(t){return[...t,103]}i32_ctz(t){return[...t,104]}unreachable(){return[0]}current_memory(){return[63,0]}comment(){return[]}}const Ai={i32:127,i64:126,f32:125,f64:124,anyfunc:112,func:96,emptyblock:64};class Ze{constructor(t,n,a,i,e){if(a=="import")this.fnType="import",this.moduleName=i,this.fieldName=e;else if(a=="internal")this.fnType="internal";else throw new Error("Invalid function fnType: "+a);this.module=t,this.fnName=n,this.params=[],this.locals=[],this.localIdxByName={},this.code=[],this.returnType=null,this.nextLocal=0}addParam(t,n){if(this.localIdxByName[t])throw new Error(`param already exists. Function: ${this.fnName}, Param: ${t} `);const a=this.nextLocal++;this.localIdxByName[t]=a,this.params.push({type:n})}addLocal(t,n,a){const i=a||1;if(this.localIdxByName[t])throw new Error(`local already exists. Function: ${this.fnName}, Param: ${t} `);const e=this.nextLocal++;this.localIdxByName[t]=e,this.locals.push({type:n,length:i})}setReturnType(t){if(this.returnType)throw new Error(`returnType already defined. Function: ${this.fnName}`);this.returnType=t}getSignature(){const t=[...Ut(this.params.length),...this.params.map(a=>Ai[a.type])],n=this.returnType?[1,Ai[this.returnType]]:[0];return[96,...t,...n]}getBody(){const t=this.locals.map(a=>[...Ut(a.length),Ai[a.type]]),n=[...Ut(this.locals.length),...[].concat(...t),...this.code,11];return[...Ut(n.length),...n]}addCode(...t){this.code.push(...[].concat(...t))}getCodeBuilder(){return new gl(this)}}class Jo{constructor(){this.functions=[],this.functionIdxByName={},this.nImportFunctions=0,this.nInternalFunctions=0,this.memory={pagesSize:1,moduleName:"env",fieldName:"memory"},this.free=8,this.datas=[],this.modules={},this.exports=[],this.functionsTable=[]}build(){return this._setSignatures(),new Uint8Array([...bi(1836278016),...bi(1),...this._buildType(),...this._buildImport(),...this._buildFunctionDeclarations(),...this._buildFunctionsTable(),...this._buildExports(),...this._buildElements(),...this._buildCode(),...this._buildData()])}addFunction(t){if(typeof this.functionIdxByName[t]<"u")throw new Error(`Function already defined: ${t}`);const n=this.functions.length;return this.functionIdxByName[t]=n,this.functions.push(new Ze(this,t,"internal")),this.nInternalFunctions++,this.functions[n]}addIimportFunction(t,n,a){if(typeof this.functionIdxByName[t]<"u")throw new Error(`Function already defined: ${t}`);if(this.functions.length>0&&this.functions[this.functions.length-1].type=="internal")throw new Error(`Import functions must be declared before internal: ${t}`);let i=a||t;const e=this.functions.length;return this.functionIdxByName[t]=e,this.functions.push(new Ze(this,t,"import",n,i)),this.nImportFunctions++,this.functions[e]}setMemory(t,n,a){this.memory={pagesSize:t,moduleName:n||"env",fieldName:a||"memory"}}exportFunction(t,n){const a=n||t;if(typeof this.functionIdxByName[t]>"u")throw new Error(`Function not defined: ${t}`);const i=this.functionIdxByName[t];a!=t&&(this.functionIdxByName[a]=i),this.exports.push({exportName:a,idx:i})}addFunctionToTable(t){const n=this.functionIdxByName[t];this.functionsTable.push(n)}addData(t,n){this.datas.push({offset:t,bytes:n})}alloc(t,n){let a,i;(Array.isArray(t)||ArrayBuffer.isView(t))&&typeof n>"u"?(a=t.length,i=t):(a=t,i=n),a=(a-1>>3)+1<<3;const e=this.free;return this.free+=a,i&&this.addData(e,i),e}allocString(t){const a=new globalThis.TextEncoder().encode(t);return this.alloc([...a,0])}_setSignatures(){this.signatures=[];const t={};if(this.functionsTable.length>0){const n=this.functions[this.functionsTable[0]].getSignature(),a="s_"+je(n);t[a]=0,this.signatures.push(n)}for(let n=0;n<this.functions.length;n++){const a=this.functions[n].getSignature(),i="s_"+je(a);typeof t[i]>"u"&&(t[i]=this.signatures.length,this.signatures.push(a)),this.functions[n].signatureIdx=t[i]}}_buildSection(t,n){return[t,...Ut(n.length),...n]}_buildType(){return this._buildSection(1,[...Ut(this.signatures.length),...[].concat(...this.signatures)])}_buildImport(){const t=[];t.push([...ya(this.memory.moduleName),...ya(this.memory.fieldName),2,0,...Ut(this.memory.pagesSize)]);for(let n=0;n<this.nImportFunctions;n++)t.push([...ya(this.functions[n].moduleName),...ya(this.functions[n].fieldName),0,...Ut(this.functions[n].signatureIdx)]);return this._buildSection(2,Ut(t.length).concat(...t))}_buildFunctionDeclarations(){const t=[];for(let n=this.nImportFunctions;n<this.nImportFunctions+this.nInternalFunctions;n++)t.push(...Ut(this.functions[n].signatureIdx));return this._buildSection(3,[...Ut(t.length),...t])}_buildFunctionsTable(){return this.functionsTable.length==0?[]:this._buildSection(4,[...Ut(1),112,0,...Ut(this.functionsTable.length)])}_buildElements(){if(this.functionsTable.length==0)return[];const t=[];for(let n=0;n<this.functionsTable.length;n++)t.push(...Ut(this.functionsTable[n]));return this._buildSection(9,[...Ut(1),...Ut(0),65,...$i(0),11,...Ut(this.functionsTable.length),...t])}_buildExports(){const t=[];for(let n=0;n<this.exports.length;n++)t.push([...ya(this.exports[n].exportName),0,...Ut(this.exports[n].idx)]);return this._buildSection(7,Ut(t.length).concat(...t))}_buildCode(){const t=[];for(let n=this.nImportFunctions;n<this.nImportFunctions+this.nInternalFunctions;n++)t.push(this.functions[n].getBody());return this._buildSection(10,Ut(t.length).concat(...t))}_buildData(){const t=[];t.push([0,65,0,11,4,...bi(this.free)]);for(let n=0;n<this.datas.length;n++)t.push([0,65,...$i(this.datas[n].offset),11,...Ut(this.datas[n].bytes.length),...this.datas[n].bytes]);return this._buildSection(11,Ut(t.length).concat(...t))}}globalThis.curve_bn128=null;async function oi(o,t){if(!o&&globalThis.curve_bn128)return globalThis.curve_bn128;const n=new Jo;n.setMemory(25),Xc(n);const a={};a.code=n.build(),a.pq=n.modules.f1m.pq,a.pr=n.modules.frm.pq,a.pG1gen=n.modules.bn128.pG1gen,a.pG1zero=n.modules.bn128.pG1zero,a.pG1b=n.modules.bn128.pG1b,a.pG2gen=n.modules.bn128.pG2gen,a.pG2zero=n.modules.bn128.pG2zero,a.pG2b=n.modules.bn128.pG2b,a.pOneT=n.modules.bn128.pOneT,a.prePSize=n.modules.bn128.prePSize,a.preQSize=n.modules.bn128.preQSize,a.n8q=32,a.n8r=32,a.q=n.modules.bn128.q,a.r=n.modules.bn128.r;const i={name:"bn128",wasm:a,q:an("21888242871839275222246405745257275088696311157297823662689037894645226208583"),r:an("21888242871839275222246405745257275088548364400416034343698204186575808495617"),n8q:32,n8r:32,cofactorG2:an("30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d",16),singleThread:!!o},e=await Zo(i);return e.terminate=async function(){i.singleThread||(globalThis.curve_bn128=null,await this.tm.terminate())},o||(globalThis.curve_bn128=e),e}globalThis.curve_bls12381=null;async function si(o,t){if(!o&&globalThis.curve_bls12381)return globalThis.curve_bls12381;const n=new Jo;n.setMemory(25),Jc(n);const a={};a.code=n.build(),a.pq=n.modules.f1m.pq,a.pr=n.modules.frm.pq,a.pG1gen=n.modules.bls12381.pG1gen,a.pG1zero=n.modules.bls12381.pG1zero,a.pG1b=n.modules.bls12381.pG1b,a.pG2gen=n.modules.bls12381.pG2gen,a.pG2zero=n.modules.bls12381.pG2zero,a.pG2b=n.modules.bls12381.pG2b,a.pOneT=n.modules.bls12381.pOneT,a.prePSize=n.modules.bls12381.prePSize,a.preQSize=n.modules.bls12381.preQSize,a.n8q=48,a.n8r=32,a.q=n.modules.bls12381.q,a.r=n.modules.bls12381.r;const i={name:"bls12381",wasm:a,q:an("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),r:an("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),n8q:48,n8r:32,cofactorG1:an("0x396c8c005555e1568c00aaab0000aaab",16),cofactorG2:an("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5",16),singleThread:!!o},e=await Zo(i);return e.terminate=async function(){i.singleThread||(globalThis.curve_bls12381=null,await this.tm.terminate())},o||(globalThis.curve_bls12381=e),e}const pl=an("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),wl=an("21888242871839275222246405745257275088548364400416034343698204186575808495617");an("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16);an("21888242871839275222246405745257275088696311157297823662689037894645226208583");async function Ll(o,t,n){let a;if(Gn(o,wl))a=await oi(t);else if(Gn(o,pl))a=await si(t);else throw new Error(`Curve not supported: ${ce(o)}`);return a}const Ft=Js,cn=el;var ts={};async function ns(o,t,n,a){if(n=n||4096*64,typeof t!="number"&&["w+","wx+","r","ax+","a+"].indexOf(t)<0)throw new Error("Invalid open option");const i=await ts.promises.open(o,t),e=await i.stat();return new ml(i,e,n,a,o)}class ml{constructor(t,n,a,i,e){for(this.fileName=e,this.fd=t,this.pos=0,this.pageSize=i||256;this.pageSize<n.blksize;)this.pageSize*=2;this.totalSize=n.size,this.totalPages=Math.floor((n.size-1)/this.pageSize)+1,this.maxPagesLoaded=Math.floor(a/this.pageSize)+1,this.pages={},this.pendingLoads=[],this.writing=!1,this.reading=!1,this.avBuffs=[],this.history={}}_loadPage(t){const n=this,a=new Promise((i,e)=>{n.pendingLoads.push({page:t,resolve:i,reject:e})});return n.__statusPage("After Load request: ",t),a}__statusPage(t,n){const a=[],i=this;if(!i.logHistory)return;a.push("=="+t+" "+n);let e="";for(let l=0;l<i.pendingLoads.length;l++)i.pendingLoads[l].page==n&&(e=e+" "+l);if(e&&a.push("Pending loads:"+e),typeof i.pages[n]<"u"){const l=i.pages[n];a.push("Loaded"),a.push("pendingOps: "+l.pendingOps),l.loading&&a.push("loading: "+l.loading),l.writing&&a.push("writing"),l.dirty&&a.push("dirty")}a.push("=="),i.history[n]||(i.history[n]=[]),i.history[n].push(a)}__printHistory(t){const n=this;n.history[t]||console.log("Empty History ",t),console.log("History "+t);for(let a=0;a<n.history[t].length;a++)for(let i=0;i<n.history[t][a].length;i++)console.log("-> "+n.history[t][a][i])}_triggerLoad(){const t=this;if(t.reading||t.pendingLoads.length==0)return;const n=Object.keys(t.pages),a=[];for(let s=0;s<n.length;s++){const h=t.pages[parseInt(n[s])];h.dirty==!1&&h.pendingOps==0&&!h.writing&&!h.loading&&a.push(parseInt(n[s]))}let i=t.maxPagesLoaded-n.length;const e=[];for(;t.pendingLoads.length>0&&(typeof t.pages[t.pendingLoads[0].page]<"u"||i>0||a.length>0);){const s=t.pendingLoads.shift();if(typeof t.pages[s.page]<"u"){t.pages[s.page].pendingOps++;const h=a.indexOf(s.page);h>=0&&a.splice(h,1),t.pages[s.page].loading?t.pages[s.page].loading.push(s):s.resolve(),t.__statusPage("After Load (cached): ",s.page)}else{if(i)i--;else{const h=a.shift();t.__statusPage("Before Unload: ",h),t.avBuffs.unshift(t.pages[h]),delete t.pages[h],t.__statusPage("After Unload: ",h)}s.page>=t.totalPages?(t.pages[s.page]=l(),s.resolve(),t.__statusPage("After Load (new): ",s.page)):(t.reading=!0,t.pages[s.page]=l(),t.pages[s.page].loading=[s],e.push(t.fd.read(t.pages[s.page].buff,0,t.pageSize,s.page*t.pageSize).then(h=>{t.pages[s.page].size=h.bytesRead;const d=t.pages[s.page].loading;delete t.pages[s.page].loading;for(let c=0;c<d.length;c++)d[c].resolve();return t.__statusPage("After Load (loaded): ",s.page),h},h=>{s.reject(h)})),t.__statusPage("After Load (loading): ",s.page))}}Promise.all(e).then(()=>{t.reading=!1,t.pendingLoads.length>0&&setImmediate(t._triggerLoad.bind(t)),t._tryClose()});function l(){if(t.avBuffs.length>0){const s=t.avBuffs.shift();return s.dirty=!1,s.pendingOps=1,s.size=0,s}else return{dirty:!1,buff:new Uint8Array(t.pageSize),pendingOps:1,size:0}}}_triggerWrite(){const t=this;if(t.writing)return;const n=Object.keys(t.pages),a=[];for(let i=0;i<n.length;i++){const e=t.pages[parseInt(n[i])];e.dirty&&(e.dirty=!1,e.writing=!0,t.writing=!0,a.push(t.fd.write(e.buff,0,e.size,parseInt(n[i])*t.pageSize).then(()=>{e.writing=!1},l=>{console.log("ERROR Writing: "+l),t.error=l,t._tryClose()})))}t.writing&&Promise.all(a).then(()=>{t.writing=!1,setImmediate(t._triggerWrite.bind(t)),t._tryClose(),t.pendingLoads.length>0&&setImmediate(t._triggerLoad.bind(t))})}_getDirtyPage(){for(let t in this.pages)if(this.pages[t].dirty)return t;return-1}async write(t,n){if(t.byteLength==0)return;const a=this;if(typeof n>"u"&&(n=a.pos),a.pos=n+t.byteLength,a.totalSize<n+t.byteLength&&(a.totalSize=n+t.byteLength),a.pendingClose)throw new Error("Writing a closing file");const i=Math.floor(n/a.pageSize),e=Math.floor((n+t.byteLength-1)/a.pageSize),l=[];for(let c=i;c<=e;c++)l.push(a._loadPage(c));a._triggerLoad();let s=i,h=n%a.pageSize,d=t.byteLength;for(;d>0;){await l[s-i];const c=h+d>a.pageSize?a.pageSize-h:d,f=t.slice(t.byteLength-d,t.byteLength-d+c);new Uint8Array(a.pages[s].buff.buffer,h,c).set(f),a.pages[s].dirty=!0,a.pages[s].pendingOps--,a.pages[s].size=Math.max(h+c,a.pages[s].size),s>=a.totalPages&&(a.totalPages=s+1),d=d-c,s++,h=0,a.writing||setImmediate(a._triggerWrite.bind(a))}}async read(t,n){const a=this;let i=new Uint8Array(t);return await a.readToBuffer(i,0,t,n),i}async readToBuffer(t,n,a,i){if(a==0)return;const e=this;if(a>e.pageSize*e.maxPagesLoaded*.8){const y=Math.floor(a*1.1);this.maxPagesLoaded=Math.floor(y/e.pageSize)+1}if(typeof i>"u"&&(i=e.pos),e.pos=i+a,e.pendingClose)throw new Error("Reading a closing file");const l=Math.floor(i/e.pageSize),s=Math.floor((i+a-1)/e.pageSize),h=[];for(let y=l;y<=s;y++)h.push(e._loadPage(y));e._triggerLoad();let d=l,c=i%e.pageSize,f=i+a>e.totalSize?a-(i+a-e.totalSize):a;for(;f>0;){await h[d-l],e.__statusPage("After Await (read): ",d);const y=c+f>e.pageSize?e.pageSize-c:f,L=new Uint8Array(e.pages[d].buff.buffer,e.pages[d].buff.byteOffset+c,y);t.set(L,n+a-f),e.pages[d].pendingOps--,e.__statusPage("After Op done: ",d),f=f-y,d++,c=0,e.pendingLoads.length>0&&setImmediate(e._triggerLoad.bind(e))}this.pos=i+a}_tryClose(){const t=this;!t.pendingClose||(t.error&&t.pendingCloseReject(t.error),t._getDirtyPage()>=0||t.writing||t.reading||t.pendingLoads.length>0)||t.pendingClose()}close(){const t=this;if(t.pendingClose)throw new Error("Closing the file twice");return new Promise((n,a)=>{t.pendingClose=n,t.pendingCloseReject=a,t._tryClose()}).then(()=>{t.fd.close()},n=>{throw t.fd.close(),n})}async discard(){await this.close(),await ts.promises.unlink(this.fileName)}async writeULE32(t,n){const a=this,i=new Uint8Array(4);new DataView(i.buffer).setUint32(0,t,!0),await a.write(i,n)}async writeUBE32(t,n){const a=this,i=new Uint8Array(4);new DataView(i.buffer).setUint32(0,t,!1),await a.write(i,n)}async writeULE64(t,n){const a=this,i=new Uint8Array(8),e=new DataView(i.buffer);e.setUint32(0,t&4294967295,!0),e.setUint32(4,Math.floor(t/4294967296),!0),await a.write(i,n)}async readULE32(t){const a=await this.read(4,t);return new Uint32Array(a.buffer)[0]}async readUBE32(t){const a=await this.read(4,t);return new DataView(a.buffer).getUint32(0,!1)}async readULE64(t){const a=await this.read(8,t),i=new Uint32Array(a.buffer);return i[1]*4294967296+i[0]}async readString(t){const n=this;if(n.pendingClose)throw new Error("Reading a closing file");let a=typeof t>"u"?n.pos:t,i=Math.floor(a/n.pageSize),e=!1,l="";for(;!e;){let s=n._loadPage(i);n._triggerLoad(),await s,n.__statusPage("After Await (read): ",i);let h=a%n.pageSize;const d=new Uint8Array(n.pages[i].buff.buffer,n.pages[i].buff.byteOffset+h,n.pageSize-h);let c=d.findIndex(f=>f===0);e=c!==-1,e?(l+=new TextDecoder().decode(d.slice(0,c)),n.pos=i*this.pageSize+h+c+1):(l+=new TextDecoder().decode(d),n.pos=i*this.pageSize+h+d.length),n.pages[i].pendingOps--,n.__statusPage("After Op done: ",i),a=n.pos,i++,n.pendingLoads.length>0&&setImmediate(n._triggerLoad.bind(n))}return l}}function bl(o){const t=o.initialSize||1048576,n=new is;return n.o=o,n.o.data=new Uint8Array(t),n.allocSize=t,n.totalSize=0,n.readOnly=!1,n.pos=0,n}function Al(o){const t=new is;return t.o=o,t.allocSize=o.data.byteLength,t.totalSize=o.data.byteLength,t.readOnly=!0,t.pos=0,t}const Ni=new Uint8Array(4),We=new DataView(Ni.buffer),as=new Uint8Array(8),Ye=new DataView(as.buffer);class is{constructor(){this.pageSize=16384}_resizeIfNeeded(t){if(t>this.allocSize){const n=Math.max(this.allocSize+1048576,Math.floor(this.allocSize*1.1),t),a=new Uint8Array(n);a.set(this.o.data),this.o.data=a,this.allocSize=n}}async write(t,n){if(typeof n>"u"&&(n=this.pos),this.readOnly)throw new Error("Writing a read only file");this._resizeIfNeeded(n+t.byteLength),this.o.data.set(t.slice(),n),n+t.byteLength>this.totalSize&&(this.totalSize=n+t.byteLength),this.pos=n+t.byteLength}async readToBuffer(t,n,a,i){if(typeof i>"u"&&(i=this.pos),this.readOnly&&i+a>this.totalSize)throw new Error("Reading out of bounds");this._resizeIfNeeded(i+a);const l=new Uint8Array(this.o.data.buffer,this.o.data.byteOffset+i,a);t.set(l,n),this.pos=i+a}async read(t,n){const a=this,i=new Uint8Array(t);return await a.readToBuffer(i,0,t,n),i}close(){this.o.data.byteLength!=this.totalSize&&(this.o.data=this.o.data.slice(0,this.totalSize))}async discard(){}async writeULE32(t,n){const a=this;We.setUint32(0,t,!0),await a.write(Ni,n)}async writeUBE32(t,n){const a=this;We.setUint32(0,t,!1),await a.write(Ni,n)}async writeULE64(t,n){const a=this;Ye.setUint32(0,t&4294967295,!0),Ye.setUint32(4,Math.floor(t/4294967296),!0),await a.write(as,n)}async readULE32(t){const a=await this.read(4,t);return new Uint32Array(a.buffer)[0]}async readUBE32(t){const a=await this.read(4,t);return new DataView(a.buffer).getUint32(0,!1)}async readULE64(t){const a=await this.read(8,t),i=new Uint32Array(a.buffer);return i[1]*4294967296+i[0]}async readString(t){const n=this;let a=typeof t>"u"?n.pos:t;if(a>this.totalSize){if(this.readOnly)throw new Error("Reading out of bounds");this._resizeIfNeeded(t)}const i=new Uint8Array(n.o.data.buffer,a,this.totalSize-a);let e=i.findIndex(h=>h===0),l=e!==-1,s="";return l?(s=new TextDecoder().decode(i.slice(0,e)),n.pos=a+e+1):n.pos=a,s}}const on=1<<22;function yl(o){const t=o.initialSize||0,n=new os;n.o=o;const a=t?Math.floor((t-1)/on)+1:0;n.o.data=[];for(let i=0;i<a-1;i++)n.o.data.push(new Uint8Array(on));return a&&n.o.data.push(new Uint8Array(t-on*(a-1))),n.totalSize=0,n.readOnly=!1,n.pos=0,n}function Cl(o){const t=new os;return t.o=o,t.totalSize=(o.data.length-1)*on+o.data[o.data.length-1].byteLength,t.readOnly=!0,t.pos=0,t}const Di=new Uint8Array(4),Xe=new DataView(Di.buffer),es=new Uint8Array(8),Je=new DataView(es.buffer);class os{constructor(){this.pageSize=16384}_resizeIfNeeded(t){if(t<=this.totalSize)return;if(this.readOnly)throw new Error("Reading out of file bounds");const n=Math.floor((t-1)/on)+1;for(let a=Math.max(this.o.data.length-1,0);a<n;a++){const i=a<n-1?on:t-(n-1)*on,e=new Uint8Array(i);a==this.o.data.length-1&&e.set(this.o.data[a]),this.o.data[a]=e}this.totalSize=t}async write(t,n){const a=this;if(typeof n>"u"&&(n=a.pos),this.readOnly)throw new Error("Writing a read only file");this._resizeIfNeeded(n+t.byteLength);let e=Math.floor(n/on),l=n%on,s=t.byteLength;for(;s>0;){const h=l+s>on?on-l:s,d=t.slice(t.byteLength-s,t.byteLength-s+h);new Uint8Array(a.o.data[e].buffer,l,h).set(d),s=s-h,e++,l=0}this.pos=n+t.byteLength}async readToBuffer(t,n,a,i){const e=this;if(typeof i>"u"&&(i=e.pos),this.readOnly&&i+a>this.totalSize)throw new Error("Reading out of bounds");this._resizeIfNeeded(i+a);let s=Math.floor(i/on),h=i%on,d=a;for(;d>0;){const c=h+d>on?on-h:d,f=new Uint8Array(e.o.data[s].buffer,h,c);t.set(f,n+a-d),d=d-c,s++,h=0}this.pos=i+a}async read(t,n){const a=this,i=new Uint8Array(t);return await a.readToBuffer(i,0,t,n),i}close(){}async discard(){}async writeULE32(t,n){const a=this;Xe.setUint32(0,t,!0),await a.write(Di,n)}async writeUBE32(t,n){const a=this;Xe.setUint32(0,t,!1),await a.write(Di,n)}async writeULE64(t,n){const a=this;Je.setUint32(0,t&4294967295,!0),Je.setUint32(4,Math.floor(t/4294967296),!0),await a.write(es,n)}async readULE32(t){const a=await this.read(4,t);return new Uint32Array(a.buffer)[0]}async readUBE32(t){const a=await this.read(4,t);return new DataView(a.buffer).getUint32(0,!1)}async readULE64(t){const a=await this.read(8,t),i=new Uint32Array(a.buffer);return i[1]*4294967296+i[0]}async readString(t){const n=this,a=2048;let i=typeof t>"u"?n.pos:t;if(i>this.totalSize){if(this.readOnly)throw new Error("Reading out of bounds");this._resizeIfNeeded(t)}let e=!1,l="";for(;!e;){let s=Math.floor(i/on),h=i%on;if(n.o.data[s]===void 0)throw new Error("ERROR");let d=Math.min(a,n.o.data[s].length-h);const c=new Uint8Array(n.o.data[s].buffer,h,d);let f=c.findIndex(y=>y===0);e=f!==-1,e?(l+=new TextDecoder().decode(c.slice(0,f)),n.pos=s*on+h+f+1):(l+=new TextDecoder().decode(c),n.pos=s*on+h+c.length),i=n.pos}return l}}const Il=1024,El=512,Fl=2,Bl=0,Sl=65536,xl=8192;async function _a(o,t,n){if(typeof o=="string"&&(o={type:"file",fileName:o,cacheSize:t||Sl,pageSize:n||xl}),o.type=="file")return await ns(o.fileName,Il|El|Fl,o.cacheSize,o.pageSize);if(o.type=="mem")return bl(o);if(o.type=="bigMem")return yl(o);throw new Error("Invalid FastFile type: "+o.type)}async function Dn(o,t,n){if(o instanceof Uint8Array&&(o={type:"mem",data:o}),typeof o=="string"&&(o={type:"mem",data:await fetch(o).then(function(i){return i.arrayBuffer()}).then(function(i){return new Uint8Array(i)})}),o.type=="file")return await ns(o.fileName,Bl,o.cacheSize,o.pageSize);if(o.type=="mem")return await Al(o);if(o.type=="bigMem")return await Cl(o);throw new Error("Invalid FastFile type: "+o.type)}async function Kt(o,t,n,a,i){const e=await Dn(o),l=await e.read(4);let s="";for(let f=0;f<4;f++)s+=String.fromCharCode(l[f]);if(s!=t)throw new Error(o+": Invalid File format");if(await e.readULE32()>n)throw new Error("Version not supported");const d=await e.readULE32();let c=[];for(let f=0;f<d;f++){let y=await e.readULE32(),L=await e.readULE64();typeof c[y]>"u"&&(c[y]=[]),c[y].push({p:e.pos,size:L}),e.pos+=L}return{fd:e,sections:c}}async function fn(o,t,n,a,i,e){const l=await _a(o,i,e),s=new Uint8Array(4);for(let h=0;h<4;h++)s[h]=t.charCodeAt(h);return await l.write(s,0),await l.writeULE32(n),await l.writeULE32(a),l}async function Rt(o,t){if(typeof o.writingSection<"u")throw new Error("Already writing a section");await o.writeULE32(t),o.writingSection={pSectionSize:o.pos},await o.writeULE64(0)}async function kt(o){if(typeof o.writingSection>"u")throw new Error("Not writing a section");const t=o.pos-o.writingSection.pSectionSize-8,n=o.pos;o.pos=o.writingSection.pSectionSize,await o.writeULE64(t),o.pos=n,delete o.writingSection}async function Zt(o,t,n){if(typeof o.readingSection<"u")throw new Error("Already reading a section");if(!t[n])throw new Error(o.fileName+": Missing section "+n);if(t[n].length>1)throw new Error(o.fileName+": Section Duplicated "+n);o.pos=t[n][0].p,o.readingSection=t[n][0]}async function Wt(o,t){if(typeof o.readingSection>"u")throw new Error("Not reading a section");if(!t&&o.pos-o.readingSection.p!=o.readingSection.size)throw new Error("Invalid section size reading");delete o.readingSection}async function An(o,t,n,a){const i=new Uint8Array(n);Ft.toRprLE(i,0,t,n),await o.write(i,a)}async function Bn(o,t,n){const a=await o.read(t,n);return Ft.fromRprLE(a,0,t)}async function Nt(o,t,n,a,i){typeof i>"u"&&(i=t[a][0].size);const e=o.pageSize;await Zt(o,t,a),await Rt(n,a);for(let l=0;l<i;l+=e){const s=Math.min(i-l,e),h=await o.read(s);await n.write(h)}await kt(n),await Wt(o,i!=t[a][0].size)}async function Vt(o,t,n,a,i){if(a=typeof a>"u"?0:a,i=typeof i>"u"?t[n][0].size-a:i,a+i>t[n][0].size)throw new Error("Reading out of the range of the section");let e;return i<1<<30?e=new Uint8Array(i):e=new ft(i),await o.readToBuffer(e,0,i,t[n][0].p+a),e}async function Ca(o,t,n,a,i){const e=o.pageSize*16;if(await Zt(o,t,i),await Zt(n,a,i),t[i][0].size!=a[i][0].size)return!1;const l=t[i][0].size;for(let s=0;s<l;s+=e){const h=Math.min(l-s,e),d=await o.read(h),c=await n.read(h);for(let f=0;f<h;f++)if(d[f]!=c[f])return!1}return await Wt(o),await Wt(n),!0}const vl=Ft.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),Gl=Ft.e("21888242871839275222246405745257275088548364400416034343698204186575808495617"),Pl=Ft.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),Tl=Ft.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");async function ss(o,t){let n,a=t&&t.singleThread;if(Ft.eq(o,Gl))n=await oi(a);else if(Ft.eq(o,vl))n=await si(a);else throw new Error(`Curve not supported: ${Ft.toString(o)}`);return n}async function hn(o,t){let n,a=t&&t.singleThread;if(Ft.eq(o,Tl))n=await oi(a);else if(Ft.eq(o,Pl))n=await si(a);else throw new Error(`Curve not supported: ${Ft.toString(o)}`);return n}async function ta(o,t){let n,a=t&&t.singleThread;const i=e(o);if(["BN128","BN254","ALTBN128"].indexOf(i)>=0)n=await oi(a);else if(["BLS12381"].indexOf(i)>=0)n=await si(a);else throw new Error(`Curve not supported: ${o}`);return n;function e(l){return l.toUpperCase().match(/[A-Za-z0-9]+/g).join("")}}var hu=Object.freeze({__proto__:null,getCurveFromR:ss,getCurveFromQ:hn,getCurveFromName:ta}),Ol=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof Ie<"u"?Ie:typeof self<"u"?self:{},Tt={exports:{}},Ul=ls;class cs extends Error{}cs.prototype.name="AssertionError";function ls(o,t){if(!o){var n=new cs(t);throw Error.captureStackTrace&&Error.captureStackTrace(n,ls),n}}var Vi={exports:{}};function rs(o){return o.length}function Ml(o){const t=o.byteLength;let n="";for(let a=0;a<t;a++)n+=String.fromCharCode(o[a]);return n}function zl(o,t,n=0,a=rs(t)){const i=Math.min(a,o.byteLength-n);for(let e=0;e<i;e++)o[n+e]=t.charCodeAt(e);return i}var ql={byteLength:rs,toString:Ml,write:zl};const oa="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",Wn=new Uint8Array(256);for(let o=0;o<oa.length;o++)Wn[oa.charCodeAt(o)]=o;Wn[45]=62;Wn[95]=63;function ds(o){let t=o.length;return o.charCodeAt(t-1)===61&&t--,t>1&&o.charCodeAt(t-1)===61&&t--,t*3>>>2}function Ql(o){const t=o.byteLength;let n="";for(let a=0;a<t;a+=3)n+=oa[o[a]>>2]+oa[(o[a]&3)<<4|o[a+1]>>4]+oa[(o[a+1]&15)<<2|o[a+2]>>6]+oa[o[a+2]&63];return t%3===2?n=n.substring(0,n.length-1)+"=":t%3===1&&(n=n.substring(0,n.length-2)+"=="),n}function Rl(o,t,n=0,a=ds(t)){const i=Math.min(a,o.byteLength-n);for(let e=0,l=0;l<i;e+=4){const s=Wn[t.charCodeAt(e)],h=Wn[t.charCodeAt(e+1)],d=Wn[t.charCodeAt(e+2)],c=Wn[t.charCodeAt(e+3)];o[l++]=s<<2|h>>4,o[l++]=(h&15)<<4|d>>2,o[l++]=(d&3)<<6|c&63}return i}var kl={byteLength:ds,toString:Ql,write:Rl};function us(o){return o.length>>>1}function $l(o){const t=o.byteLength;o=new DataView(o.buffer,o.byteOffset,t);let n="",a=0;for(let i=t-t%4;a<i;a+=4)n+=o.getUint32(a).toString(16).padStart(8,"0");for(;a<t;a++)n+=o.getUint8(a).toString(16).padStart(2,"0");return n}function Nl(o,t,n=0,a=us(t)){const i=Math.min(a,o.byteLength-n);for(let e=0;e<i;e++){const l=to(t.charCodeAt(e*2)),s=to(t.charCodeAt(e*2+1));if(l===void 0||s===void 0)return o.subarray(0,e);o[n+e]=l<<4|s}return i}var Dl={byteLength:us,toString:$l,write:Nl};function to(o){if(o>=48&&o<=57)return o-48;if(o>=65&&o<=70)return o-65+10;if(o>=97&&o<=102)return o-97+10}function Hi(o){let t=0;for(let n=0,a=o.length;n<a;n++){const i=o.charCodeAt(n);if(i>=55296&&i<=56319&&n+1<a){const e=o.charCodeAt(n+1);if(e>=56320&&e<=57343){t+=4,n++;continue}}i<=127?t+=1:i<=2047?t+=2:t+=3}return t}let Ki;if(typeof TextDecoder<"u"){const o=new TextDecoder;Ki=function(n){return o.decode(n)}}else Ki=function(t){const n=t.byteLength;let a="",i=0;for(;i<n;){let e=t[i];if(e<=127){a+=String.fromCharCode(e),i++;continue}let l=0,s=0;if(e<=223?(l=1,s=e&31):e<=239?(l=2,s=e&15):e<=244&&(l=3,s=e&7),n-i-l>0){let h=0;for(;h<l;)e=t[i+h+1],s=s<<6|e&63,h+=1}else s=65533,l=n-i;a+=String.fromCodePoint(s),i+=l+1}return a};let ji;if(typeof TextEncoder<"u"){const o=new TextEncoder;ji=function(n,a,i=0,e=Hi(a)){const l=Math.min(e,n.byteLength-i);return o.encodeInto(a,n.subarray(i,i+l)),l}}else ji=function(t,n,a=0,i=Hi(n)){const e=Math.min(i,t.byteLength-a);t=t.subarray(a,a+e);let l=0,s=0;for(;l<n.length;){const h=n.codePointAt(l);if(h<=127){t[s++]=h,l++;continue}let d=0,c=0;for(h<=2047?(d=6,c=192):h<=65535?(d=12,c=224):h<=2097151&&(d=18,c=240),t[s++]=c|h>>d,d-=6;d>=0;)t[s++]=128|h>>d&63,d-=6;l+=h>=65536?2:1}return e};var Vl={byteLength:Hi,toString:Ki,write:ji};function fs(o){return o.length*2}function Hl(o){const t=o.byteLength;let n="";for(let a=0;a<t-1;a+=2)n+=String.fromCharCode(o[a]+o[a+1]*256);return n}function Kl(o,t,n=0,a=fs(t)){const i=Math.min(a,o.byteLength-n);let e=i;for(let l=0;l<t.length&&!((e-=2)<0);++l){const s=t.charCodeAt(l),h=s>>8,d=s%256;o[n+l*2]=d,o[n+l*2+1]=h}return i}var jl={byteLength:fs,toString:Hl,write:Kl};(function(o,t){const n=ql,a=kl,i=Dl,e=Vl,l=jl,s=new Uint8Array(Uint16Array.of(255).buffer)[0]===255;function h(u){switch(u){case"ascii":return n;case"base64":return a;case"hex":return i;case"utf8":case"utf-8":case void 0:return e;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return l;default:throw new Error(`Unknown encoding: ${u}`)}}function d(u){return u instanceof Uint8Array}function c(u){try{return h(u),!0}catch{return!1}}function f(u,x,F){const p=new Uint8Array(u);return x!==void 0&&t.fill(p,x,0,p.byteLength,F),p}function y(u){return new Uint8Array(u)}function L(u){return new Uint8Array(u)}function v(u,x){return h(x).byteLength(u)}function T(u,x){if(u===x)return 0;const F=Math.min(u.byteLength,x.byteLength);u=new DataView(u.buffer,u.byteOffset,u.byteLength),x=new DataView(x.buffer,x.byteOffset,x.byteLength);let p=0;for(let O=F-F%4;p<O;p+=4){const R=u.getUint32(p,s),N=x.getUint32(p,s);if(R!==N)break}for(;p<F;p++){const O=u.getUint8(p),R=x.getUint8(p);if(O<R)return-1;if(O>R)return 1}return u.byteLength>x.byteLength?1:u.byteLength<x.byteLength?-1:0}function B(u,x){x===void 0&&(x=u.reduce((O,R)=>O+R.byteLength,0));const F=new Uint8Array(x);let p=0;for(const O of u){if(p+O.byteLength>F.byteLength){const R=O.subarray(0,F.byteLength-p);return F.set(R,p),F}F.set(O,p),p+=O.byteLength}return F}function E(u,x,F=0,p=0,O=u.byteLength){if(O>0&&O<p||O===p||u.byteLength===0||x.byteLength===0)return 0;if(F<0)throw new RangeError("targetStart is out of range");if(p<0||p>=u.byteLength)throw new RangeError("sourceStart is out of range");if(O<0)throw new RangeError("sourceEnd is out of range");F>=x.byteLength&&(F=x.byteLength),O>u.byteLength&&(O=u.byteLength),x.byteLength-F<O-p&&(O=x.length-F+p);const R=O-p;return u===x?x.copyWithin(F,p,O):x.set(u.subarray(p,O),F),R}function A(u,x){if(u===x)return!0;if(u.byteLength!==x.byteLength)return!1;const F=u.byteLength;u=new DataView(u.buffer,u.byteOffset,u.byteLength),x=new DataView(x.buffer,x.byteOffset,x.byteLength);let p=0;for(let O=F-F%4;p<O;p+=4)if(u.getUint32(p,s)!==x.getUint32(p,s))return!1;for(;p<F;p++)if(u.getUint8(p)!==x.getUint8(p))return!1;return!0}function G(u,x,F,p,O){if(typeof x=="string"?typeof F=="string"?(O=F,F=0,p=u.byteLength):typeof p=="string"&&(O=p,p=u.byteLength):typeof x=="number"?x=x&255:typeof x=="boolean"&&(x=+x),F<0||u.byteLength<F||u.byteLength<p)throw new RangeError("Out of range index");if(F===void 0&&(F=0),p===void 0&&(p=u.byteLength),p<=F)return u;if(x||(x=0),typeof x=="number")for(let R=F;R<p;++R)u[R]=x;else{x=d(x)?x:P(x,O);const R=x.byteLength;for(let N=0;N<p-F;++N)u[N+F]=x[N%R]}return u}function P(u,x,F){return typeof u=="string"?U(u,x):Array.isArray(u)?I(u):ArrayBuffer.isView(u)?_(u):b(u,x,F)}function U(u,x){const F=h(x),p=new Uint8Array(F.byteLength(u));return F.write(p,u,0,p.byteLength),p}function I(u){const x=new Uint8Array(u.length);return x.set(u),x}function _(u){const x=new Uint8Array(u.byteLength);return x.set(u),x}function b(u,x,F){return new Uint8Array(u,x,F)}function $(u,x,F,p){return j(u,x,F,p)!==-1}function K(u,x,F,p,O){if(u.byteLength===0)return-1;if(typeof F=="string"?(p=F,F=0):F===void 0?F=O?0:u.length-1:F<0&&(F+=u.byteLength),F>=u.byteLength){if(O)return-1;F=u.byteLength-1}else if(F<0)if(O)F=0;else return-1;if(typeof x=="string")x=P(x,p);else if(typeof x=="number")return x=x&255,O?u.indexOf(x,F):u.lastIndexOf(x,F);if(x.byteLength===0)return-1;if(O){let R=-1;for(let N=F;N<u.byteLength;N++)if(u[N]===x[R===-1?0:N-R]){if(R===-1&&(R=N),N-R+1===x.byteLength)return R}else R!==-1&&(N-=N-R),R=-1}else{F+x.byteLength>u.byteLength&&(F=u.byteLength-x.byteLength);for(let R=F;R>=0;R--){let N=!0;for(let H=0;H<x.byteLength;H++)if(u[R+H]!==x[H]){N=!1;break}if(N)return R}}return-1}function j(u,x,F,p){return K(u,x,F,p,!0)}function M(u,x,F,p){return K(u,x,F,p,!1)}function S(u,x,F){const p=u[x];u[x]=u[F],u[F]=p}function z(u){const x=u.byteLength;if(x%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let F=0;F<x;F+=2)S(u,F,F+1);return u}function q(u){const x=u.byteLength;if(x%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let F=0;F<x;F+=4)S(u,F,F+3),S(u,F+1,F+2);return u}function Z(u){const x=u.byteLength;if(x%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let F=0;F<x;F+=8)S(u,F,F+7),S(u,F+1,F+6),S(u,F+2,F+5),S(u,F+3,F+4);return u}function Y(u){return u}function V(u,x,F=0,p=u.byteLength){const O=u.byteLength;return F>=O||p<=F?"":(F<0&&(F=0),p>O&&(p=O),(F!==0||p<O)&&(u=u.subarray(F,p)),h(x).toString(u))}function nt(u,x,F,p,O){return F===void 0?O="utf8":p===void 0&&typeof F=="string"?(O=F,F=void 0):O===void 0&&typeof p=="string"&&(O=p,p=void 0),h(O).write(u,x,F,p)}function Q(u,x,F){return F===void 0&&(F=0),new DataView(u.buffer,u.byteOffset,u.byteLength).setFloat64(F,x,!0),F+8}function it(u,x,F){return F===void 0&&(F=0),new DataView(u.buffer,u.byteOffset,u.byteLength).setFloat32(F,x,!0),F+4}function X(u,x,F){return F===void 0&&(F=0),new DataView(u.buffer,u.byteOffset,u.byteLength).setUint32(F,x,!0),F+4}function k(u,x,F){return F===void 0&&(F=0),new DataView(u.buffer,u.byteOffset,u.byteLength).setInt32(F,x,!0),F+4}function J(u,x){return x===void 0&&(x=0),new DataView(u.buffer,u.byteOffset,u.byteLength).getFloat64(x,!0)}function m(u,x){return x===void 0&&(x=0),new DataView(u.buffer,u.byteOffset,u.byteLength).getFloat32(x,!0)}function r(u,x){return x===void 0&&(x=0),new DataView(u.buffer,u.byteOffset,u.byteLength).getUint32(x,!0)}function C(u,x){return x===void 0&&(x=0),new DataView(u.buffer,u.byteOffset,u.byteLength).getInt32(x,!0)}o.exports=t={isBuffer:d,isEncoding:c,alloc:f,allocUnsafe:y,allocUnsafeSlow:L,byteLength:v,compare:T,concat:B,copy:E,equals:A,fill:G,from:P,includes:$,indexOf:j,lastIndexOf:M,swap16:z,swap32:q,swap64:Z,toBuffer:Y,toString:V,write:nt,writeDoubleLE:Q,writeFloatLE:it,writeUInt32LE:X,writeInt32LE:k,readDoubleLE:J,readFloatLE:m,readUInt32LE:r,readInt32LE:C}})(Vi,Vi.exports);var yi,no;function Zl(){if(no)return yi;no=1;var o=(e,l)=>function(){return l||(0,e[Object.keys(e)[0]])((l={exports:{}}).exports,l),l.exports},t=(()=>{for(var e=new Uint8Array(128),l=0;l<64;l++)e[l<26?l+65:l<52?l+71:l<62?l-4:l*4-205]=l;return s=>{for(var h=s.length,d=new Uint8Array((h-(s[h-1]=="=")-(s[h-2]=="="))*3/4|0),c=0,f=0;c<h;){var y=e[s.charCodeAt(c++)],L=e[s.charCodeAt(c++)],v=e[s.charCodeAt(c++)],T=e[s.charCodeAt(c++)];d[f++]=y<<2|L>>4,d[f++]=L<<4|v>>2,d[f++]=v<<6|T}return d}})(),n=o({"wasm-binary:./blake2b.wat"(e,l){l.exports=t("AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMKvz8EwAIAIABCADcDACAAQgA3AwggAEIANwMQIABCADcDGCAAQgA3AyAgAEIANwMoIABCADcDMCAAQgA3AzggAEIANwNAIABCADcDSCAAQgA3A1AgAEIANwNYIABCADcDYCAAQgA3A2ggAEIANwNwIABCADcDeCAAQoiS853/zPmE6gBBACkDAIU3A4ABIABCu86qptjQ67O7f0EIKQMAhTcDiAEgAEKr8NP0r+68tzxBECkDAIU3A5ABIABC8e30+KWn/aelf0EYKQMAhTcDmAEgAELRhZrv+s+Uh9EAQSApAwCFNwOgASAAQp/Y+dnCkdqCm39BKCkDAIU3A6gBIABC6/qG2r+19sEfQTApAwCFNwOwASAAQvnC+JuRo7Pw2wBBOCkDAIU3A7gBIABCADcDwAEgAEIANwPIASAAQgA3A9ABC20BA38gAEHAAWohAyAAQcgBaiEEIAQpAwCnIQUCQANAIAEgAkYNASAFQYABRgRAIAMgAykDACAFrXw3AwBBACEFIAAQAwsgACAFaiABLQAAOgAAIAVBAWohBSABQQFqIQEMAAsLIAQgBa03AwALYQEDfyAAQcABaiEBIABByAFqIQIgASABKQMAIAIpAwB8NwMAIABCfzcD0AEgAikDAKchAwJAA0AgA0GAAUYNASAAIANqQQA6AAAgA0EBaiEDDAALCyACIAOtNwMAIAAQAwuqOwIgfgl/IABBgAFqISEgAEGIAWohIiAAQZABaiEjIABBmAFqISQgAEGgAWohJSAAQagBaiEmIABBsAFqIScgAEG4AWohKCAhKQMAIQEgIikDACECICMpAwAhAyAkKQMAIQQgJSkDACEFICYpAwAhBiAnKQMAIQcgKCkDACEIQoiS853/zPmE6gAhCUK7zqqm2NDrs7t/IQpCq/DT9K/uvLc8IQtC8e30+KWn/aelfyEMQtGFmu/6z5SH0QAhDUKf2PnZwpHagpt/IQ5C6/qG2r+19sEfIQ9C+cL4m5Gjs/DbACEQIAApAwAhESAAKQMIIRIgACkDECETIAApAxghFCAAKQMgIRUgACkDKCEWIAApAzAhFyAAKQM4IRggACkDQCEZIAApA0ghGiAAKQNQIRsgACkDWCEcIAApA2AhHSAAKQNoIR4gACkDcCEfIAApA3ghICANIAApA8ABhSENIA8gACkD0AGFIQ8gASAFIBF8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSASfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgE3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBR8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAVfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFnx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBd8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAYfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgGXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBp8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAbfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgHHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIB18fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAefHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgH3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFICB8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAffHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgG3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBV8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAZfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHICB8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAefHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggF3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBJ8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAdfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgEXx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBN8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAcfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggGHx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBZ8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAUfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHHx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBl8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAdfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgEXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBZ8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByATfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggIHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIB58fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAbfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgH3x8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBR8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAXfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBJ8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAafHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFXx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBh8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAafHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFHx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBJ8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAefHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHXx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBx8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAffHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgE3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBd8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAWfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgG3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBV8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCARfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgIHx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBl8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAafHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEXx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBZ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAYfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgE3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBV8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAbfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggIHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIB98fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiASfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgHHx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB18fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAXfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggGXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBR8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAefHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgE3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIB18fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAXfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgG3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBF8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAcfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggGXx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBR8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAVfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBh8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAWfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggIHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB98fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSASfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgGnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB18fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAWfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgEnx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGICB8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAffHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHnx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBV8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAbfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBh8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAXfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBp8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCATfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGXx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBx8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAefHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgHHx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBh8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAffHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBJ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAUfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBZ8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiARfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgIHx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBV8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAZfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggF3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBN8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAbfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgF3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFICB8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAffHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGnx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBx8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAUfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggEXx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBl8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAdfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgE3x8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIB58fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAYfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggEnx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBV8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAbfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBt8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSATfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgGXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBV8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAYfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgF3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBJ8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAWfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgIHx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBx8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAafHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgH3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBR8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAdfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgHnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBF8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgISAhKQMAIAEgCYWFNwMAICIgIikDACACIAqFhTcDACAjICMpAwAgAyALhYU3AwAgJCAkKQMAIAQgDIWFNwMAICUgJSkDACAFIA2FhTcDACAmICYpAwAgBiAOhYU3AwAgJyAnKQMAIAcgD4WFNwMAICggKCkDACAIIBCFhTcDAAs=")}}),a=n(),i=WebAssembly.compile(a);return yi=async e=>(await WebAssembly.instantiate(await i,e)).exports,yi}var pn=Ul,Wl=Vi.exports,On=null,ao=typeof WebAssembly<"u"&&Zl()().then(o=>{On=o}),Pn=64,Ha=[];Tt.exports=dn;var io=Tt.exports.BYTES_MIN=16,eo=Tt.exports.BYTES_MAX=64;Tt.exports.BYTES=32;var oo=Tt.exports.KEYBYTES_MIN=16,so=Tt.exports.KEYBYTES_MAX=64;Tt.exports.KEYBYTES=32;var co=Tt.exports.SALTBYTES=16,lo=Tt.exports.PERSONALBYTES=16;function dn(o,t,n,a,i){if(!(this instanceof dn))return new dn(o,t,n,a,i);if(!On)throw new Error("WASM not loaded. Wait for Blake2b.ready(cb)");o||(o=32),i!==!0&&(pn(o>=io,"digestLength must be at least "+io+", was given "+o),pn(o<=eo,"digestLength must be at most "+eo+", was given "+o),t!=null&&(pn(t instanceof Uint8Array,"key must be Uint8Array or Buffer"),pn(t.length>=oo,"key must be at least "+oo+", was given "+t.length),pn(t.length<=so,"key must be at least "+so+", was given "+t.length)),n!=null&&(pn(n instanceof Uint8Array,"salt must be Uint8Array or Buffer"),pn(n.length===co,"salt must be exactly "+co+", was given "+n.length)),a!=null&&(pn(a instanceof Uint8Array,"personal must be Uint8Array or Buffer"),pn(a.length===lo,"personal must be exactly "+lo+", was given "+a.length))),Ha.length||(Ha.push(Pn),Pn+=216),this.digestLength=o,this.finalized=!1,this.pointer=Ha.pop(),this._memory=new Uint8Array(On.memory.buffer),this._memory.fill(0,0,64),this._memory[0]=this.digestLength,this._memory[1]=t?t.length:0,this._memory[2]=1,this._memory[3]=1,n&&this._memory.set(n,32),a&&this._memory.set(a,48),this.pointer+216>this._memory.length&&this._realloc(this.pointer+216),On.blake2b_init(this.pointer,this.digestLength),t&&(this.update(t),this._memory.fill(0,Pn,Pn+t.length),this._memory[this.pointer+200]=128)}dn.prototype._realloc=function(o){On.memory.grow(Math.max(0,Math.ceil(Math.abs(o-this._memory.length)/65536))),this._memory=new Uint8Array(On.memory.buffer)};dn.prototype.update=function(o){return pn(this.finalized===!1,"Hash instance finalized"),pn(o instanceof Uint8Array,"input must be Uint8Array or Buffer"),Pn+o.length>this._memory.length&&this._realloc(Pn+o.length),this._memory.set(o,Pn),On.blake2b_update(this.pointer,Pn,Pn+o.length),this};dn.prototype.digest=function(o){if(pn(this.finalized===!1,"Hash instance finalized"),this.finalized=!0,Ha.push(this.pointer),On.blake2b_final(this.pointer),!o||o==="binary")return this._memory.slice(this.pointer+128,this.pointer+128+this.digestLength);if(typeof o=="string")return Wl.toString(this._memory,o,this.pointer+128,this.pointer+128+this.digestLength);pn(o instanceof Uint8Array&&o.length>=this.digestLength,"input must be Uint8Array or Buffer");for(var t=0;t<this.digestLength;t++)o[t]=this._memory[this.pointer+128+t];return o};dn.prototype.final=dn.prototype.digest;dn.WASM=On;dn.SUPPORTED=typeof WebAssembly<"u";dn.ready=function(o){return o||(o=Yl),ao?ao.then(()=>o(),o):o(new Error("WebAssembly not supported"))};dn.prototype.ready=dn.ready;dn.prototype.getPartialHash=function(){return this._memory.slice(this.pointer,this.pointer+216)};dn.prototype.setPartialHash=function(o){this._memory.set(o,this.pointer)};function Yl(){}function Vn(o){return((o&4294901760)!==0?(o&=4294901760,16):0)|((o&4278255360)!==0?(o&=4278255360,8):0)|((o&4042322160)!==0?(o&=4042322160,4):0)|((o&3435973836)!==0?(o&=3435973836,2):0)|(o&2863311530)!==0}function nn(o,t){const n=new DataView(o.buffer,o.byteOffset,o.byteLength);let a="";for(let i=0;i<4;i++){i>0&&(a+=`
`),a+="		";for(let e=0;e<4;e++)e>0&&(a+=" "),a+=n.getUint32(i*16+e*4).toString(16).padStart(8,"0")}return t&&(a=t+`
`+a),a}function kn(o,t){if(o.byteLength!=t.byteLength)return!1;for(var n=new Int8Array(o),a=new Int8Array(t),i=0;i!=o.byteLength;i++)if(n[i]!=a[i])return!1;return!0}function Xl(o){const t=o.getPartialHash(),n=Tt.exports(64);return n.setPartialHash(t),n}async function hs(o,t,n,a,i){return o.G1.isZero(t)||o.G1.isZero(n)||o.G2.isZero(a)||o.G2.isZero(i)?!1:await o.pairingEq(t,i,o.G1.neg(n),a)}function Jl(){return window.prompt("Enter a random text. (Entropy): ","")}function ca(o){let t=new Uint8Array(o);return globalThis.crypto.getRandomValues(t),t}async function tr(o){{const t=await globalThis.crypto.subtle.digest("SHA-256",o.buffer);return new Uint8Array(t)}}function Xa(o,t){return new DataView(o.buffer).getUint32(t,!1)}async function ci(o){for(;!o;)o=await Jl();const t=Tt.exports(64);t.update(ca(64));const n=new TextEncoder;t.update(n.encode(o));const a=t.digest(),i=[];for(let l=0;l<8;l++)i[l]=Xa(a,l*4);return new Jn(i)}async function pe(o,t){let n,a;t<32?(n=1<<t>>>0,a=1):(n=4294967296,a=1<<t-32>>>0);let i=o;for(let h=0;h<a;h++)for(let d=0;d<n;d++)i=await tr(i);const e=new DataView(i.buffer,i.byteOffset,i.byteLength),l=[];for(let h=0;h<8;h++)l[h]=e.getUint32(h*4,!1);return new Jn(l)}function _s(o){return o instanceof Uint8Array?o:(o.slice(0,2)=="0x"&&(o=o.slice(2)),new Uint8Array(o.match(/[\da-f]{2}/gi).map(function(t){return parseInt(t,16)})))}function gs(o){return Array.prototype.map.call(o,function(t){return("0"+(t&255).toString(16)).slice(-2)}).join("")}function Ja(o,t){if(t instanceof Uint8Array)return o.toString(t);if(Array.isArray(t))return t.map(Ja.bind(null,o));if(typeof t=="object"){const n={};return Object.keys(t).forEach(i=>{n[i]=Ja(o,t[i])}),n}else return typeof t=="bigint"||t.eq!==void 0?t.toString(10):t}const ro=1,nr=1,ar=2,Qa=10,ir=3,er=17,Zi=2,ti=3,Wi=4,Yi=5,Xi=6,Fa=7,Ba=8,Sa=9,xa=10,va=11,Ga=12,Pa=13,Ta=14,Ji=15,ni=16,te=17;async function we(o,t){await Rt(o,1),await o.writeULE32(1),await kt(o);const n=await hn(t.q);await Rt(o,2);const a=n.q,i=(Math.floor((Ft.bitLength(a)-1)/64)+1)*8,e=n.r,l=(Math.floor((Ft.bitLength(e)-1)/64)+1)*8;await o.writeULE32(i),await An(o,a,i),await o.writeULE32(l),await An(o,e,l),await o.writeULE32(t.nVars),await o.writeULE32(t.nPublic),await o.writeULE32(t.domainSize),await la(o,n,t.vk_alpha_1),await la(o,n,t.vk_beta_1),await Ka(o,n,t.vk_beta_2),await Ka(o,n,t.vk_gamma_2),await la(o,n,t.vk_delta_1),await Ka(o,n,t.vk_delta_2),await kt(o)}async function la(o,t,n){const a=new Uint8Array(t.G1.F.n8*2);t.G1.toRprLEM(a,0,n),await o.write(a)}async function Ka(o,t,n){const a=new Uint8Array(t.G2.F.n8*2);t.G2.toRprLEM(a,0,n),await o.write(a)}async function en(o,t,n){const a=await o.read(t.G1.F.n8*2),i=t.G1.fromRprLEM(a,0);return n?t.G1.toObject(i):i}async function Xn(o,t,n){const a=await o.read(t.G2.F.n8*2),i=t.G2.fromRprLEM(a,0);return n?t.G2.toObject(i):i}async function yn(o,t,n,a){await Zt(o,t,1);const i=await o.readULE32();if(await Wt(o),i===nr)return await or(o,t,n,a);if(i===ar)return await sr(o,t,n,a);if(i===Qa)return await cr(o,t,n,a);throw new Error("Protocol not supported: ")}async function or(o,t,n,a){const i={};i.protocol="groth16",await Zt(o,t,2);const e=await o.readULE32();i.n8q=e,i.q=await Bn(o,e);const l=await o.readULE32();return i.n8r=l,i.r=await Bn(o,l),i.curve=await hn(i.q,a),i.nVars=await o.readULE32(),i.nPublic=await o.readULE32(),i.domainSize=await o.readULE32(),i.power=Vn(i.domainSize),i.vk_alpha_1=await en(o,i.curve,n),i.vk_beta_1=await en(o,i.curve,n),i.vk_beta_2=await Xn(o,i.curve,n),i.vk_gamma_2=await Xn(o,i.curve,n),i.vk_delta_1=await en(o,i.curve,n),i.vk_delta_2=await Xn(o,i.curve,n),await Wt(o),i}async function sr(o,t,n,a){const i={};i.protocol="plonk",await Zt(o,t,2);const e=await o.readULE32();i.n8q=e,i.q=await Bn(o,e);const l=await o.readULE32();return i.n8r=l,i.r=await Bn(o,l),i.curve=await hn(i.q,a),i.nVars=await o.readULE32(),i.nPublic=await o.readULE32(),i.domainSize=await o.readULE32(),i.power=Vn(i.domainSize),i.nAdditions=await o.readULE32(),i.nConstraints=await o.readULE32(),i.k1=await o.read(l),i.k2=await o.read(l),i.Qm=await en(o,i.curve,n),i.Ql=await en(o,i.curve,n),i.Qr=await en(o,i.curve,n),i.Qo=await en(o,i.curve,n),i.Qc=await en(o,i.curve,n),i.S1=await en(o,i.curve,n),i.S2=await en(o,i.curve,n),i.S3=await en(o,i.curve,n),i.X_2=await Xn(o,i.curve,n),await Wt(o),i}async function cr(o,t,n,a){const i={};i.protocol="fflonk",i.protocolId=Qa,await Zt(o,t,Zi);const e=await o.readULE32();i.n8q=e,i.q=await Bn(o,e),i.curve=await hn(i.q,a);const l=await o.readULE32();return i.n8r=l,i.r=await Bn(o,l),i.nVars=await o.readULE32(),i.nPublic=await o.readULE32(),i.domainSize=await o.readULE32(),i.power=Vn(i.domainSize),i.nAdditions=await o.readULE32(),i.nConstraints=await o.readULE32(),i.k1=await o.read(l),i.k2=await o.read(l),i.w3=await o.read(l),i.w4=await o.read(l),i.w8=await o.read(l),i.wr=await o.read(l),i.X_2=await Xn(o,i.curve,n),i.C0=await en(o,i.curve,n),await Wt(o),i}async function lr(o,t){const{fd:n,sections:a}=await Kt(o,"zkey",1),i=await yn(n,a,t),e=new re(i.r),l=Ft.mod(Ft.shl(1,i.n8r*8),i.r),s=e.inv(l),h=e.mul(s,s);let d=await hn(i.q);await Zt(n,a,3),i.IC=[];for(let y=0;y<=i.nPublic;y++){const L=await en(n,d,t);i.IC.push(L)}await Wt(n),await Zt(n,a,4);const c=await n.readULE32();i.ccoefs=[];for(let y=0;y<c;y++){const L=await n.readULE32(),v=await n.readULE32(),T=await n.readULE32(),B=await f();i.ccoefs.push({matrix:L,constraint:v,signal:T,value:B})}await Wt(n),await Zt(n,a,5),i.A=[];for(let y=0;y<i.nVars;y++){const L=await en(n,d,t);i.A[y]=L}await Wt(n),await Zt(n,a,6),i.B1=[];for(let y=0;y<i.nVars;y++){const L=await en(n,d,t);i.B1[y]=L}await Wt(n),await Zt(n,a,7),i.B2=[];for(let y=0;y<i.nVars;y++){const L=await Xn(n,d,t);i.B2[y]=L}await Wt(n),await Zt(n,a,8),i.C=[];for(let y=i.nPublic+1;y<i.nVars;y++){const L=await en(n,d,t);i.C[y]=L}await Wt(n),await Zt(n,a,9),i.hExps=[];for(let y=0;y<i.domainSize;y++){const L=await en(n,d,t);i.hExps.push(L)}return await Wt(n),await n.close(),i;async function f(){const y=await Bn(n,i.n8r);return e.mul(y,h)}}async function rr(o,t,n){const a={delta:{}};a.deltaAfter=await en(o,t,n),a.delta.g1_s=await en(o,t,n),a.delta.g1_sx=await en(o,t,n),a.delta.g2_spx=await Xn(o,t,n),a.transcript=await o.read(64),a.type=await o.readULE32();const i=await o.readULE32(),e=o.pos;let l=0;for(;o.pos-e<i;){const s=await o.read(1);if(s[0]<=l)throw new Error("Parameters in the contribution must be sorted");if(l=s[0],s[0]==1){const h=await o.read(1),d=await o.read(h[0]);a.name=new TextDecoder().decode(d)}else if(s[0]==2){const h=await o.read(1);a.numIterationsExp=h[0]}else if(s[0]==3){const h=await o.read(1);a.beaconHash=await o.read(h[0])}else throw new Error("Parameter not recognized")}if(o.pos!=e+i)throw new Error("Parameters do not match");return a}async function fa(o,t,n){await Zt(o,n,10);const a={contributions:[]};a.csHash=await o.read(64);const i=await o.readULE32();for(let e=0;e<i;e++){const l=await rr(o,t);a.contributions.push(l)}return await Wt(o),a}async function dr(o,t,n){await la(o,t,n.deltaAfter),await la(o,t,n.delta.g1_s),await la(o,t,n.delta.g1_sx),await Ka(o,t,n.delta.g2_spx),await o.write(n.transcript),await o.writeULE32(n.type||0);const a=[];if(n.name){a.push(1);const i=new TextEncoder("utf-8").encode(n.name.substring(0,64));a.push(i.byteLength);for(let e=0;e<i.byteLength;e++)a.push(i[e])}if(n.type==1){a.push(2),a.push(n.numIterationsExp),a.push(3),a.push(n.beaconHash.byteLength);for(let i=0;i<n.beaconHash.byteLength;i++)a.push(n.beaconHash[i])}if(a.length>0){const i=new Uint8Array(a);await o.writeULE32(i.byteLength),await o.write(i)}else await o.writeULE32(0)}async function Le(o,t,n){await Rt(o,10),await o.write(n.csHash),await o.writeULE32(n.contributions.length);for(let a=0;a<n.contributions.length;a++)await dr(o,t,n.contributions[a]);await kt(o)}function bn(o,t,n){const a=new Uint8Array(t.G1.F.n8*2);t.G1.toRprUncompressed(a,0,n),o.update(a)}function ur(o,t,n){const a=new Uint8Array(t.G2.F.n8*2);t.G2.toRprUncompressed(a,0,n),o.update(a)}function $n(o,t,n){bn(o,t,n.deltaAfter),bn(o,t,n.delta.g1_s),bn(o,t,n.delta.g1_sx),ur(o,t,n.delta.g2_spx),o.update(n.transcript)}async function fr(o,t,n){await Rt(o,1);const a=(Math.floor((Ft.bitLength(n)-1)/64)+1)*8;await o.writeULE32(a),await An(o,n,a),await o.writeULE32(t.length),await kt(o),await Rt(o,2);for(let i=0;i<t.length;i++)await An(o,t[i],a);await kt(o)}async function hr(o,t,n){await Rt(o,1);const a=(Math.floor((Ft.bitLength(n)-1)/64)+1)*8;if(await o.writeULE32(a),await An(o,n,a),t.byteLength%a!=0)throw new Error("Invalid witness length");await o.writeULE32(t.byteLength/a),await kt(o),await Rt(o,2),await o.write(t),await kt(o)}async function Ra(o,t){await Zt(o,t,1);const n=await o.readULE32(),a=await Bn(o,n),i=await o.readULE32();return await Wt(o),{n8:n,q:a,nWitness:i}}async function _r(o){const{fd:t,sections:n}=await Kt(o,"wtns",2),{n8:a,nWitness:i}=await Ra(t,n);await Zt(t,n,2);const e=[];for(let l=0;l<i;l++){const s=await Bn(t,a);e.push(s)}return await Wt(t),await t.close(),e}const{stringifyBigInts:uo}=cn;async function ps(o,t,n,a){const{fd:i,sections:e}=await Kt(t,"wtns",2),l=await Ra(i,e),{fd:s,sections:h}=await Kt(o,"zkey",2),d=await yn(s,h,void 0,a);if(d.protocol!="groth16")throw new Error("zkey file is not groth16");if(!Ft.eq(d.r,l.q))throw new Error("Curve of the witness does not match the curve of the proving key");if(l.nWitness!=d.nVars)throw new Error(`Invalid witness length. Circuit: ${d.nVars}, witness: ${l.nWitness}`);const c=d.curve,f=c.Fr,y=c.G1,L=c.G2,v=Vn(d.domainSize);n&&n.debug("Reading Wtns");const T=await Vt(i,e,2);n&&n.debug("Reading Coeffs");const B=await Vt(s,h,4);n&&n.debug("Building ABC");const[E,A,G]=await gr(c,d,T,B,n),P=v==f.s?c.Fr.shift:c.Fr.w[v+1],U=await f.ifft(E,"","",n,"IFFT_A"),I=await f.batchApplyKey(U,f.e(1),P),_=await f.fft(I,"","",n,"FFT_A"),b=await f.ifft(A,"","",n,"IFFT_B"),$=await f.batchApplyKey(b,f.e(1),P),K=await f.fft($,"","",n,"FFT_B"),j=await f.ifft(G,"","",n,"IFFT_C"),M=await f.batchApplyKey(j,f.e(1),P),S=await f.fft(M,"","",n,"FFT_C");n&&n.debug("Join ABC");const z=await pr(c,d,_,K,S,n);let q={};n&&n.debug("Reading A Points");const Z=await Vt(s,h,5);q.pi_a=await c.G1.multiExpAffine(Z,T,n,"multiexp A"),n&&n.debug("Reading B1 Points");const Y=await Vt(s,h,6);let V=await c.G1.multiExpAffine(Y,T,n,"multiexp B1");n&&n.debug("Reading B2 Points");const nt=await Vt(s,h,7);q.pi_b=await c.G2.multiExpAffine(nt,T,n,"multiexp B2"),n&&n.debug("Reading C Points");const Q=await Vt(s,h,8);q.pi_c=await c.G1.multiExpAffine(Q,T.slice((d.nPublic+1)*c.Fr.n8),n,"multiexp C"),n&&n.debug("Reading H Points");const it=await Vt(s,h,9),X=await c.G1.multiExpAffine(it,z,n,"multiexp H"),k=c.Fr.random(),J=c.Fr.random();q.pi_a=y.add(q.pi_a,d.vk_alpha_1),q.pi_a=y.add(q.pi_a,y.timesFr(d.vk_delta_1,k)),q.pi_b=L.add(q.pi_b,d.vk_beta_2),q.pi_b=L.add(q.pi_b,L.timesFr(d.vk_delta_2,J)),V=y.add(V,d.vk_beta_1),V=y.add(V,y.timesFr(d.vk_delta_1,J)),q.pi_c=y.add(q.pi_c,X),q.pi_c=y.add(q.pi_c,y.timesFr(q.pi_a,J)),q.pi_c=y.add(q.pi_c,y.timesFr(V,k)),q.pi_c=y.add(q.pi_c,y.timesFr(d.vk_delta_1,f.neg(f.mul(k,J))));let m=[];for(let r=1;r<=d.nPublic;r++){const C=T.slice(r*f.n8,r*f.n8+f.n8);m.push(Ft.fromRprLE(C))}return q.pi_a=y.toObject(y.toAffine(q.pi_a)),q.pi_b=L.toObject(L.toAffine(q.pi_b)),q.pi_c=y.toObject(y.toAffine(q.pi_c)),q.protocol="groth16",q.curve=c.name,await s.close(),await i.close(),q=uo(q),m=uo(m),{proof:q,publicSignals:m}}async function gr(o,t,n,a,i){const e=o.Fr.n8,l=12+t.n8r,s=(a.byteLength-4)/l,h=new ft(t.domainSize*e),d=new ft(t.domainSize*e),c=new ft(t.domainSize*e),f=[h,d];for(let y=0;y<s;y++){i&&y%1e6==0&&i.debug(`QAP AB: ${y}/${s}`);const L=a.slice(4+y*l,4+y*l+l),v=new DataView(L.buffer),T=v.getUint32(0,!0),B=v.getUint32(4,!0),E=v.getUint32(8,!0),A=L.slice(12,12+e);f[T].set(o.Fr.add(f[T].slice(B*e,B*e+e),o.Fr.mul(A,n.slice(E*e,E*e+e))),B*e)}for(let y=0;y<t.domainSize;y++)i&&y%1e6==0&&i.debug(`QAP C: ${y}/${t.domainSize}`),c.set(o.Fr.mul(h.slice(y*e,y*e+e),d.slice(y*e,y*e+e)),y*e);return[h,d,c]}async function pr(o,t,n,a,i,e){const s=o.Fr.n8,h=Math.floor(n.byteLength/o.Fr.n8),d=[];for(let L=0;L<h;L+=4194304){e&&e.debug(`JoinABC: ${L}/${h}`);const v=Math.min(h-L,4194304),T=[],B=n.slice(L*s,(L+v)*s),E=a.slice(L*s,(L+v)*s),A=i.slice(L*s,(L+v)*s);T.push({cmd:"ALLOCSET",var:0,buff:B}),T.push({cmd:"ALLOCSET",var:1,buff:E}),T.push({cmd:"ALLOCSET",var:2,buff:A}),T.push({cmd:"ALLOC",var:3,len:v*s}),T.push({cmd:"CALL",fnName:"qap_joinABC",params:[{var:0},{var:1},{var:2},{val:v},{var:3}]}),T.push({cmd:"CALL",fnName:"frm_batchFromMontgomery",params:[{var:3},{val:v},{var:3}]}),T.push({cmd:"GET",out:0,var:3,len:v*s}),d.push(o.tm.queueAction(T))}const c=await Promise.all(d);let f;n instanceof ft?f=new ft(n.byteLength):f=new Uint8Array(n.byteLength);let y=0;for(let L=0;L<c.length;L++)f.set(c[L][0],y),y+=c[L][0].byteLength;return f}function ws(o){let t=[];return n(t,o),t;function n(a,i){if(Array.isArray(i))for(let e=0;e<i.length;e++)n(a,i[e]);else a.push(i)}}function wr(o,t){let n=BigInt(o)%t;return n<0&&(n+=t),n}function Ls(o){const t=BigInt(2)**BigInt(64);let n=BigInt("0xCBF29CE484222325");for(let e=0;e<o.length;e++)n^=BigInt(o[e].charCodeAt(0)),n*=BigInt(1099511628211),n%=t;let a=n.toString(16),i=16-a.length;return a="0".repeat(i).concat(a),a}function Lr(o,t){const n=[];let a=BigInt(o);const i=BigInt(4294967296);for(;a;)n.unshift(Number(a%i)),a=a/i;if(t){let e=t-n.length;for(;e>0;)n.unshift(0),e--}return n}async function ms(o,t){let n,a,i;t=t||{};let e=1,l=0,s=0,h=!1;if(o instanceof WebAssembly.Instance)n=o,h=!0;else{let y=32767;if(t.memorySize&&(y=parseInt(t.memorySize),y<0))throw new Error("Invalid memory size");let L=!1;for(;!L;)try{i=new WebAssembly.Memory({initial:y}),L=!0}catch(E){if(y<=1)throw E;console.warn("Could not allocate "+y*1024*64+" bytes. This may cause severe instability. Trying with "+y*1024*64/2+" bytes"),y=Math.floor(y/2)}const v=await WebAssembly.compile(o);let T="",B="";n=await WebAssembly.instantiate(v,{env:{memory:i},runtime:{printDebug:function(E){console.log("printDebug:",E)},exceptionHandler:function(E){let A;throw E===1?A="Signal not found. ":E===2?A="Too many signals set. ":E===3?A="Signal already set. ":E===4?A="Assert Failed. ":E===5?A="Not enough memory. ":E===6?A="Input signal array access exceeds the size. ":A="Unknown error. ",console.error("ERROR: ",E,T),new Error(A+T)},printErrorMessage:function(){T+=c()+`
`},writeBufferMessage:function(){const E=c();E===`
`?(console.log(B),B=""):(B!==""&&(B+=" "),B+=E)},showSharedRWMemory:function(){const E=n.exports.getFieldNumLen32(),A=new Uint32Array(E);for(let G=0;G<E;G++)A[E-1-G]=n.exports.readSharedRWMemory(G);if(e>=2&&(l>=1||s>=7)){B!==""&&(B+=" ");const G=Ft.fromArray(A,4294967296).toString();B+=G}else console.log(Ft.fromArray(A,4294967296))},error:function(E,A,G,P,U,I){let _;throw E===7?_=f(A)+" "+a.getFr(P).toString()+" != "+a.getFr(U).toString()+" "+f(I):E===9?_=f(A)+" "+a.getFr(P).toString()+" "+f(U):E===5&&t.sym?_=f(A)+" "+t.sym.labelIdx2Name[U]:_=f(A)+" "+G+" "+P+" "+U+" "+I,console.log("ERROR: ",E,_),new Error(_)},log:function(E){console.log(a.getFr(E).toString())},logGetSignal:function(E,A){t.logGetSignal&&t.logGetSignal(E,a.getFr(A))},logSetSignal:function(E,A){t.logSetSignal&&t.logSetSignal(E,a.getFr(A))},logStartComponent:function(E){t.logStartComponent&&t.logStartComponent(E)},logFinishComponent:function(E){t.logFinishComponent&&t.logFinishComponent(E)}}})}typeof n.exports.getVersion=="function"&&(e=n.exports.getVersion()),typeof n.exports.getMinorVersion=="function"&&(l=n.exports.getMinorVersion()),typeof n.exports.getPatchVersion=="function"&&(s=n.exports.getPatchVersion());const d=t&&(t.sanityCheck||t.logGetSignal||t.logSetSignal||t.logStartComponent||t.logFinishComponent);if(e===2)a=new br(n,d);else if(e===1){if(h)throw new Error("Loading code from WebAssembly instance is not supported for circom version 1");a=new mr(i,n,d)}else throw new Error(`Unsupported circom version: ${e}`);return a;function c(){let y="",L=n.exports.getMessageChar();for(;L!==0;)y+=String.fromCharCode(L),L=n.exports.getMessageChar();return y}function f(y){const L=new Uint8Array(i.buffer),v=[];for(let T=0;L[y+T]>0;T++)v.push(L[y+T]);return String.fromCharCode.apply(null,v)}}class mr{constructor(t,n,a){this.memory=t,this.i32=new Uint32Array(t.buffer),this.instance=n,this.n32=(this.instance.exports.getFrLen()>>2)-2;const i=this.instance.exports.getPRawPrime(),e=new Array(this.n32);for(let l=0;l<this.n32;l++)e[this.n32-1-l]=this.i32[(i>>2)+l];this.prime=Ft.fromArray(e,4294967296),this.Fr=new re(this.prime),this.mask32=Ft.fromString("FFFFFFFF",16),this.NVars=this.instance.exports.getNVars(),this.n64=Math.floor((this.Fr.bitLength-1)/64)+1,this.R=this.Fr.e(Ft.shiftLeft(1,this.n64*64)),this.RInv=this.Fr.inv(this.R),this.sanityCheck=a}circom_version(){return 1}async _doCalculateWitness(t,n){this.instance.exports.init(this.sanityCheck||n?1:0);const a=this.allocInt(),i=this.allocFr();Object.keys(t).forEach(l=>{const s=Ls(l),h=parseInt(s.slice(0,8),16),d=parseInt(s.slice(8,16),16);try{this.instance.exports.getSignalOffset32(a,0,h,d)}catch{throw new Error(`Signal ${l} is not an input of the circuit.`)}const c=this.getInt(a),f=ws(t[l]);for(let y=0;y<f.length;y++)this.setFr(i,f[y]),this.instance.exports.setSignal(0,0,c+y,i)})}async calculateWitness(t,n){const a=this,i=a.i32[0],e=[];await a._doCalculateWitness(t,n);for(let l=0;l<a.NVars;l++){const s=a.instance.exports.getPWitness(l);e.push(a.getFr(s))}return a.i32[0]=i,e}async calculateBinWitness(t,n){const a=this,i=a.i32[0];await a._doCalculateWitness(t,n);const e=a.instance.exports.getWitnessBuffer();a.i32[0]=i;const l=a.memory.buffer.slice(e,e+a.NVars*a.n64*8);return new Uint8Array(l)}allocInt(){const t=this.i32[0];return this.i32[0]=t+8,t}allocFr(){const t=this.i32[0];return this.i32[0]=t+this.n32*4+8,t}getInt(t){return this.i32[t>>2]}setInt(t,n){this.i32[t>>2]=n}getFr(t){const n=this,a=t>>2;if(n.i32[a+1]&2147483648){const e=new Array(n.n32);for(let s=0;s<n.n32;s++)e[n.n32-1-s]=n.i32[a+2+s];const l=n.Fr.e(Ft.fromArray(e,4294967296));return n.i32[a+1]&1073741824?i(l):l}else return n.i32[a]&2147483648?n.Fr.e(n.i32[a]-4294967296):n.Fr.e(n.i32[a]);function i(e){return n.Fr.mul(n.RInv,e)}}setFr(t,n){const a=this;n=a.Fr.e(n);const i=a.Fr.neg(a.Fr.e("80000000",16)),e=a.Fr.e("7FFFFFFF",16);if(a.Fr.geq(n,i)&&a.Fr.leq(n,e)){let s;a.Fr.geq(n,a.Fr.zero)?s=Ft.toNumber(n):(s=Ft.toNumber(a.Fr.sub(n,i)),s=s-2147483648,s=4294967296+s),a.i32[t>>2]=s,a.i32[(t>>2)+1]=0;return}a.i32[t>>2]=0,a.i32[(t>>2)+1]=2147483648;const l=Ft.toArray(n,4294967296);for(let s=0;s<a.n32;s++){const h=l.length-1-s;h>=0?a.i32[(t>>2)+2+s]=l[h]:a.i32[(t>>2)+2+s]=0}}}class br{constructor(t,n){this.instance=t,this.version=this.instance.exports.getVersion(),this.n32=this.instance.exports.getFieldNumLen32(),this.instance.exports.getRawPrime();const a=new Uint32Array(this.n32);for(let i=0;i<this.n32;i++)a[this.n32-1-i]=this.instance.exports.readSharedRWMemory(i);this.prime=Ft.fromArray(a,4294967296),this.witnessSize=this.instance.exports.getWitnessSize(),this.sanityCheck=n}circom_version(){return this.instance.exports.getVersion()}async _doCalculateWitness(t,n){this.instance.exports.init(this.sanityCheck||n?1:0);const a=Object.keys(t);let i=0;if(a.forEach(e=>{const l=Ls(e),s=parseInt(l.slice(0,8),16),h=parseInt(l.slice(8,16),16),d=ws(t[e]);if(typeof this.instance.exports.getInputSignalSize=="function"){let c=this.instance.exports.getInputSignalSize(s,h);if(c<0)throw new Error(`Signal ${e} not found
`);if(d.length<c)throw new Error(`Not enough values for input signal ${e}
`);if(d.length>c)throw new Error(`Too many values for input signal ${e}
`)}for(let c=0;c<d.length;c++){const f=Lr(wr(d[c],this.prime),this.n32);for(let y=0;y<this.n32;y++)this.instance.exports.writeSharedRWMemory(y,f[this.n32-1-y]);try{this.instance.exports.setInputSignal(s,h,c),i++}catch(y){throw new Error(y)}}}),i<this.instance.exports.getInputSize())throw new Error(`Not all inputs have been set. Only ${i} out of ${this.instance.exports.getInputSize()}`)}async calculateWitness(t,n){const a=[];await this._doCalculateWitness(t,n);for(let i=0;i<this.witnessSize;i++){this.instance.exports.getWitness(i);const e=new Uint32Array(this.n32);for(let l=0;l<this.n32;l++)e[this.n32-1-l]=this.instance.exports.readSharedRWMemory(l);a.push(Ft.fromArray(e,4294967296))}return a}async calculateWTNSBin(t,n){const a=new Uint32Array(this.witnessSize*this.n32+this.n32+11),i=new Uint8Array(a.buffer);await this._doCalculateWitness(t,n),i[0]=119,i[1]=116,i[2]=110,i[3]=115,a[1]=2,a[2]=2,a[3]=1;const e=this.n32*4,s=(8+e).toString(16);a[4]=parseInt(s.slice(0,8),16),a[5]=parseInt(s.slice(8,16),16),a[6]=e,this.instance.exports.getRawPrime();let h=7;for(let f=0;f<this.n32;f++)a[h+f]=this.instance.exports.readSharedRWMemory(f);h+=this.n32,a[h]=this.witnessSize,h++,a[h]=2,h++;const c=(e*this.witnessSize).toString(16);a[h]=parseInt(c.slice(0,8),16),a[h+1]=parseInt(c.slice(8,16),16),h+=2;for(let f=0;f<this.witnessSize;f++){this.instance.exports.getWitness(f);for(let y=0;y<this.n32;y++)a[h+y]=this.instance.exports.readSharedRWMemory(y);h+=this.n32}return i}}const{unstringifyBigInts:Ar}=cn;async function li(o,t,n,a){const i=Ar(o),e=await Dn(t),l=await e.read(e.totalSize);await e.close();const s=await ms(l,a);if(s.circom_version()===1){const h=await s.calculateBinWitness(i),d=await fn(n,"wtns",2,2);await hr(d,h,s.prime),await d.close()}else{const h=await _a(n),d=await s.calculateWTNSBin(i);await h.write(d),await h.close()}}const{unstringifyBigInts:yr}=cn;async function Cr(o,t,n,a,i,e){const l=yr(o),s={type:"mem"};return await li(l,t,s,i),await ps(n,s,a,e)}const{unstringifyBigInts:Ci}=cn;async function Ir(o,t,n,a){const i=Ci(o),e=Ci(n),l=Ci(t),s=await ta(i.curve),h=s.G1.fromObject(i.IC[0]),d=new Uint8Array(s.G1.F.n8*2*l.length),c=new Uint8Array(s.Fr.n8*l.length);if(!Fr(s,l))return a&&a.error("Public inputs are not valid."),!1;for(let P=0;P<l.length;P++){const U=s.G1.fromObject(i.IC[P+1]);d.set(U,P*s.G1.F.n8*2),Ft.toRprLE(c,s.Fr.n8*P,l[P],s.Fr.n8)}let f=await s.G1.multiExpAffine(d,c);f=s.G1.add(f,h);const y=s.G1.fromObject(e.pi_a),L=s.G2.fromObject(e.pi_b),v=s.G1.fromObject(e.pi_c);if(!Er(s,{pi_a:y,pi_b:L,pi_c:v}))return a&&a.error("Proof commitments are not valid."),!1;const T=s.G2.fromObject(i.vk_gamma_2),B=s.G2.fromObject(i.vk_delta_2),E=s.G1.fromObject(i.vk_alpha_1),A=s.G2.fromObject(i.vk_beta_2);return await s.pairingEq(s.G1.neg(y),L,f,T,v,B,E,A)?(a&&a.info("OK!"),!0):(a&&a.error("Invalid proof"),!1)}function Er(o,t){const n=o.G1,a=o.G2;return n.isValid(t.pi_a)&&a.isValid(t.pi_b)&&n.isValid(t.pi_c)}function Fr(o,t){for(let n=0;n<t.length;n++)if(!Ft.lt(t[n],o.r))return!1;return!0}const{unstringifyBigInts:fo}=cn;function vn(o){let t=o.toString(16);for(;t.length<64;)t="0"+t;return t=`"0x${t}"`,t}async function Br(o,t){const n=fo(o),a=fo(t);let i="";for(let l=0;l<a.length;l++)i!=""&&(i=i+","),i=i+vn(a[l]);let e;return e=`[${vn(n.pi_a[0])}, ${vn(n.pi_a[1])}],[[${vn(n.pi_b[0][1])}, ${vn(n.pi_b[0][0])}],[${vn(n.pi_b[1][1])}, ${vn(n.pi_b[1][0])}]],[${vn(n.pi_c[0])}, ${vn(n.pi_c[1])}],[${i}]`,e}var _u=Object.freeze({__proto__:null,fullProve:Cr,prove:ps,verify:Ir,exportSolidityCallData:Br});function ka(o,t){const n=new DataView(t.buffer,t.byteOffset,t.byteLength),a=[];for(let l=0;l<8;l++)a[l]=n.getUint32(l*4);const i=new Jn(a);return o.G2.fromRng(i)}function ja(o,t,n,a,i){const e=Tt.exports(64),l=new Uint8Array([t]);e.update(l),e.update(n);const s=o.G1.toUncompressed(a);e.update(s);const h=o.G1.toUncompressed(i);e.update(h);const d=e.digest();return ka(o,d)}function Ii(o,t,n,a,i){return o.g1_s=t.G1.toAffine(t.G1.fromRng(i)),o.g1_sx=t.G1.toAffine(t.G1.timesFr(o.g1_s,o.prvKey)),o.g2_sp=t.G2.toAffine(ja(t,n,a,o.g1_s,o.g1_sx)),o.g2_spx=t.G2.toAffine(t.G2.timesFr(o.g2_sp,o.prvKey)),o}function me(o,t,n){const a={tau:{},alpha:{},beta:{}};return a.tau.prvKey=o.Fr.fromRng(n),a.alpha.prvKey=o.Fr.fromRng(n),a.beta.prvKey=o.Fr.fromRng(n),Ii(a.tau,o,0,t,n),Ii(a.alpha,o,1,t,n),Ii(a.beta,o,2,t,n),a}async function na(o,t,n,a){a||(a=n),await o.writeULE32(1);const i=o.pos;await o.writeULE64(0),await o.writeULE32(t.F1.n64*8);const e=new Uint8Array(t.F1.n8);Ft.toRprLE(e,0,t.q,t.F1.n8),await o.write(e),await o.writeULE32(n),await o.writeULE32(a);const l=o.pos-i-8,s=o.pos;await o.writeULE64(l,i),o.pos=s}async function mn(o,t){if(!t[1])throw new Error(o.fileName+": File has no  header");if(t[1].length>1)throw new Error(o.fileName+": File has more than one header");o.pos=t[1][0].p;const n=await o.readULE32(),a=await o.read(n),i=Ft.fromRprLE(a),e=await hn(i);if(e.F1.n64*8!=n)throw new Error(o.fileName+": Invalid size");const l=await o.readULE32(),s=await o.readULE32();if(o.pos-t[1][0].p!=t[1][0].size)throw new Error("Invalid PTau header size");return{curve:e,power:l,ceremonyPower:s}}async function Sr(o,t,n){const a=await o.read(t.F1.n8*2*6+t.F2.n8*2*3);return bs(a,0,t,n)}function bs(o,t,n,a){const i={tau:{},alpha:{},beta:{}};return i.tau.g1_s=e(),i.tau.g1_sx=e(),i.alpha.g1_s=e(),i.alpha.g1_sx=e(),i.beta.g1_s=e(),i.beta.g1_sx=e(),i.tau.g2_spx=l(),i.alpha.g2_spx=l(),i.beta.g2_spx=l(),i;function e(){let s;return a?s=n.G1.fromRprLEM(o,t):s=n.G1.fromRprUncompressed(o,t),t+=n.G1.F.n8*2,s}function l(){let s;return a?s=n.G2.fromRprLEM(o,t):s=n.G2.fromRprUncompressed(o,t),t+=n.G2.F.n8*2,s}}function ga(o,t,n,a,i){e(a.tau.g1_s),e(a.tau.g1_sx),e(a.alpha.g1_s),e(a.alpha.g1_sx),e(a.beta.g1_s),e(a.beta.g1_sx),l(a.tau.g2_spx),l(a.alpha.g2_spx),l(a.beta.g2_spx);async function e(s){i?n.G1.toRprLEM(o,t,s):n.G1.toRprUncompressed(o,t,s),t+=n.F1.n8*2}async function l(s){i?n.G2.toRprLEM(o,t,s):n.G2.toRprUncompressed(o,t,s),t+=n.F2.n8*2}return o}async function xr(o,t,n,a){const i=new Uint8Array(t.F1.n8*2*6+t.F2.n8*2*3);ga(i,0,t,n,a),await o.write(i)}async function vr(o,t){const n={};n.tauG1=await h(),n.tauG2=await d(),n.alphaG1=await h(),n.betaG1=await h(),n.betaG2=await d(),n.key=await Sr(o,t,!0),n.partialHash=await o.read(216),n.nextChallenge=await o.read(64),n.type=await o.readULE32();const a=new Uint8Array(t.G1.F.n8*2*6+t.G2.F.n8*2*3);ga(a,0,t,n.key,!1);const i=Tt.exports(64);i.setPartialHash(n.partialHash),i.update(a),n.responseHash=i.digest();const e=await o.readULE32(),l=o.pos;let s=0;for(;o.pos-l<e;){const f=await c(1);if(f[0]<=s)throw new Error("Parameters in the contribution must be sorted");if(s=f[0],f[0]==1){const y=await c(1),L=await c(y[0]);n.name=new TextDecoder().decode(L)}else if(f[0]==2){const y=await c(1);n.numIterationsExp=y[0]}else if(f[0]==3){const y=await c(1);n.beaconHash=await c(y[0])}else throw new Error("Parameter not recognized")}if(o.pos!=l+e)throw new Error("Parameters do not match");return n;async function h(){const f=await o.read(t.G1.F.n8*2);return t.G1.fromRprLEM(f)}async function d(){const f=await o.read(t.G2.F.n8*2);return t.G2.fromRprLEM(f)}async function c(f){const y=await o.read(f);return new Uint8Array(y)}}async function pa(o,t,n){if(!n[7])throw new Error(o.fileName+": File has no  contributions");if(n[7][0].length>1)throw new Error(o.fileName+": File has more than one contributions section");o.pos=n[7][0].p;const a=await o.readULE32(),i=[];for(let e=0;e<a;e++){const l=await vr(o,t);l.id=e+1,i.push(l)}if(o.pos-n[7][0].p!=n[7][0].size)throw new Error("Invalid contribution section size");return i}async function Gr(o,t,n){const a=new Uint8Array(t.F1.n8*2),i=new Uint8Array(t.F2.n8*2);await l(n.tauG1),await s(n.tauG2),await l(n.alphaG1),await l(n.betaG1),await s(n.betaG2),await xr(o,t,n.key,!0),await o.write(n.partialHash),await o.write(n.nextChallenge),await o.writeULE32(n.type||0);const e=[];if(n.name){e.push(1);const h=new TextEncoder("utf-8").encode(n.name.substring(0,64));e.push(h.byteLength);for(let d=0;d<h.byteLength;d++)e.push(h[d])}if(n.type==1){e.push(2),e.push(n.numIterationsExp),e.push(3),e.push(n.beaconHash.byteLength);for(let h=0;h<n.beaconHash.byteLength;h++)e.push(n.beaconHash[h])}if(e.length>0){const h=new Uint8Array(e);await o.writeULE32(h.byteLength),await o.write(h)}else await o.writeULE32(0);async function l(h){t.G1.toRprLEM(a,0,h),await o.write(a)}async function s(h){t.G2.toRprLEM(i,0,h),await o.write(i)}}async function be(o,t,n){await o.writeULE32(7);const a=o.pos;await o.writeULE64(0),await o.writeULE32(n.length);for(let l=0;l<n.length;l++)await Gr(o,t,n[l]);const i=o.pos-a-8,e=o.pos;await o.writeULE64(i,a),o.pos=e}function wa(o,t,n){n&&n.debug("Calculating First Challenge Hash");const a=new Tt.exports(64),i=new Uint8Array(o.G1.F.n8*2),e=new Uint8Array(o.G2.F.n8*2);o.G1.toRprUncompressed(i,0,o.G1.g),o.G2.toRprUncompressed(e,0,o.G2.g),a.update(Tt.exports(64).digest());let l;return l=2**t*2-1,n&&n.debug("Calculate Initial Hash: tauG1"),s(i,l),l=2**t,n&&n.debug("Calculate Initial Hash: tauG2"),s(e,l),n&&n.debug("Calculate Initial Hash: alphaTauG1"),s(i,l),n&&n.debug("Calculate Initial Hash: betaTauG1"),s(i,l),a.update(e),a.digest();function s(h,d){const f=Math.floor(d/341e3),y=d%341e3,L=new Uint8Array(341e3*h.byteLength);for(let v=0;v<341e3;v++)L.set(h,v*h.byteLength);for(let v=0;v<f;v++)a.update(L),n&&n.debug("Initial hash: "+v*341e3);for(let v=0;v<y;v++)a.update(h)}}async function As(o,t,n,a){const i=await pe(n,a);return me(o,t,i)}async function Pr(o,t,n,a){await Tt.exports.ready();const i=await fn(n,"ptau",1,7);await na(i,o,t,0);const e=o.G1.oneAffine,l=o.G2.oneAffine;await Rt(i,2);const s=2**t*2-1;for(let y=0;y<s;y++)await i.write(e),a&&y%1e5==0&&y&&a.log("tauG1: "+y);await kt(i),await Rt(i,3);const h=2**t;for(let y=0;y<h;y++)await i.write(l),a&&y%1e5==0&&y&&a.log("tauG2: "+y);await kt(i),await Rt(i,4);const d=2**t;for(let y=0;y<d;y++)await i.write(e),a&&y%1e5==0&&y&&a.log("alphaTauG1: "+y);await kt(i),await Rt(i,5);const c=2**t;for(let y=0;y<c;y++)await i.write(e),a&&y%1e5==0&&y&&a.log("betaTauG1: "+y);await kt(i),await Rt(i,6),await i.write(l),await kt(i),await Rt(i,7),await i.writeULE32(0),await kt(i),await i.close();const f=wa(o,t,a);return a&&a.debug(nn(Tt.exports(64).digest(),"Blank Contribution Hash:")),a&&a.info(nn(f,"First Contribution Hash:")),f}async function Tr(o,t,n){await Tt.exports.ready();const{fd:a,sections:i}=await Kt(o,"ptau",1),{curve:e,power:l}=await mn(a,i),s=await pa(a,e,i);let h,d;s.length==0?(h=Tt.exports(64).digest(),d=wa(e,l)):(h=s[s.length-1].responseHash,d=s[s.length-1].nextChallenge),n&&n.info(nn(h,"Last Response Hash: ")),n&&n.info(nn(d,"New Challenge Hash: "));const c=await _a(t),f=Tt.exports(64);await c.write(h),f.update(h),await L(2,"G1",2**l*2-1,"tauG1"),await L(3,"G2",2**l,"tauG2"),await L(4,"G1",2**l,"alphaTauG1"),await L(5,"G1",2**l,"betaTauG1"),await L(6,"G2",1,"betaG2"),await a.close(),await c.close();const y=f.digest();if(!kn(d,y))throw n&&n.info(nn(y,"Calc Curret Challenge Hash: ")),n&&n.error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one"),new Error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one");return d;async function L(v,T,B,E){const A=e[T],G=A.F.n8*2,P=Math.floor((1<<24)/G);await Zt(a,i,v);for(let U=0;U<B;U+=P){n&&n.debug(`Exporting ${E}: ${U}/${B}`);const I=Math.min(B-U,P);let _;_=await a.read(I*G),_=await A.batchLEMtoU(_),await c.write(_),f.update(_)}await Wt(a)}}async function Or(o,t,n,a,i,e){await Tt.exports.ready();const l=new Uint8Array(64);for(let z=0;z<64;z++)l[z]=255;const{fd:s,sections:h}=await Kt(o,"ptau",1),{curve:d,power:c}=await mn(s,h),f=await pa(s,d,h),y={};a&&(y.name=a);const L=d.F1.n8*2,v=d.F1.n8,T=d.F2.n8*2,B=d.F2.n8,E=await Dn(t);if(E.totalSize!=64+(2**c*2-1)*v+2**c*B+2**c*v+2**c*v+B+L*6+T*3)throw new Error("Size of the contribution is invalid");let A;f.length>0?A=f[f.length-1].nextChallenge:A=wa(d,c,e);const G=await fn(n,"ptau",1,i?7:2);await na(G,d,c);const P=await E.read(64);if(kn(l,A)&&(A=P,f[f.length-1].nextChallenge=A),!kn(P,A))throw new Error("Wrong contribution. This contribution is not based on the previous hash");const U=new Tt.exports(64);U.update(P);const I=[];let _;_=await K(E,G,"G1",2,2**c*2-1,[1],"tauG1"),y.tauG1=_[0],_=await K(E,G,"G2",3,2**c,[1],"tauG2"),y.tauG2=_[0],_=await K(E,G,"G1",4,2**c,[0],"alphaG1"),y.alphaG1=_[0],_=await K(E,G,"G1",5,2**c,[0],"betaG1"),y.betaG1=_[0],_=await K(E,G,"G2",6,1,[0],"betaG2"),y.betaG2=_[0],y.partialHash=U.getPartialHash();const b=await E.read(d.F1.n8*2*6+d.F2.n8*2*3);y.key=bs(b,0,d,!1),U.update(new Uint8Array(b));const $=U.digest();if(e&&e.info(nn($,"Contribution Response Hash imported: ")),i){const z=new Tt.exports(64);z.update($),await S(z,G,"G1",2,2**c*2-1,"tauG1",e),await S(z,G,"G2",3,2**c,"tauG2",e),await S(z,G,"G1",4,2**c,"alphaTauG1",e),await S(z,G,"G1",5,2**c,"betaTauG1",e),await S(z,G,"G2",6,1,"betaG2",e),y.nextChallenge=z.digest(),e&&e.info(nn(y.nextChallenge,"Next Challenge Hash: "))}else y.nextChallenge=l;return f.push(y),await be(G,d,f),await E.close(),await G.close(),await s.close(),y.nextChallenge;async function K(z,q,Z,Y,V,nt,Q){return i?await j(z,q,Z,Y,V,nt,Q):await M(z,q,Z,Y,V,nt,Q)}async function j(z,q,Z,Y,V,nt,Q){const it=d[Z],X=it.F.n8,k=it.F.n8*2,J=[];await Rt(q,Y);const m=Math.floor((1<<24)/k);I[Y]=q.pos;for(let r=0;r<V;r+=m){e&&e.debug(`Importing ${Q}: ${r}/${V}`);const C=Math.min(V-r,m),u=await z.read(C*X);U.update(u);const x=await it.batchCtoLEM(u);await q.write(x);for(let F=0;F<nt.length;F++){const p=nt[F];if(p>=r&&p<r+C){const O=it.fromRprLEM(x,(p-r)*k);J.push(O)}}}return await kt(q),J}async function M(z,q,Z,Y,V,nt,Q){const it=d[Z],X=it.F.n8,k=[],J=Math.floor((1<<24)/X);for(let m=0;m<V;m+=J){e&&e.debug(`Importing ${Q}: ${m}/${V}`);const r=Math.min(V-m,J),C=await z.read(r*X);U.update(C);for(let u=0;u<nt.length;u++){const x=nt[u];if(x>=m&&x<m+r){const F=it.fromRprCompressed(C,(x-m)*X);k.push(F)}}}return k}async function S(z,q,Z,Y,V,nt,Q){const it=d[Z],X=it.F.n8*2,k=Math.floor((1<<24)/X),J=q.pos;q.pos=I[Y];for(let m=0;m<V;m+=k){Q&&Q.debug(`Hashing ${nt}: ${m}/${V}`);const r=Math.min(V-m,k),C=await q.read(r*X),u=await it.batchLEMtoU(C);z.update(u)}q.pos=J}}const Ln=hs;async function ho(o,t,n,a){let i;if(t.type==1){const e=await As(o,n.nextChallenge,t.beaconHash,t.numIterationsExp);if(!o.G1.eq(t.key.tau.g1_s,e.tau.g1_s))return a&&a.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!o.G1.eq(t.key.tau.g1_sx,e.tau.g1_sx))return a&&a.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!o.G2.eq(t.key.tau.g2_spx,e.tau.g2_spx))return a&&a.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!o.G1.eq(t.key.alpha.g1_s,e.alpha.g1_s))return a&&a.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!o.G1.eq(t.key.alpha.g1_sx,e.alpha.g1_sx))return a&&a.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!o.G2.eq(t.key.alpha.g2_spx,e.alpha.g2_spx))return a&&a.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!o.G1.eq(t.key.beta.g1_s,e.beta.g1_s))return a&&a.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!o.G1.eq(t.key.beta.g1_sx,e.beta.g1_sx))return a&&a.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!o.G2.eq(t.key.beta.g2_spx,e.beta.g2_spx))return a&&a.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1}return t.key.tau.g2_sp=o.G2.toAffine(ja(o,0,n.nextChallenge,t.key.tau.g1_s,t.key.tau.g1_sx)),t.key.alpha.g2_sp=o.G2.toAffine(ja(o,1,n.nextChallenge,t.key.alpha.g1_s,t.key.alpha.g1_sx)),t.key.beta.g2_sp=o.G2.toAffine(ja(o,2,n.nextChallenge,t.key.beta.g1_s,t.key.beta.g1_sx)),i=await Ln(o,t.key.tau.g1_s,t.key.tau.g1_sx,t.key.tau.g2_sp,t.key.tau.g2_spx),i!==!0?(a&&a.error("INVALID key (tau) in challenge #"+t.id),!1):(i=await Ln(o,t.key.alpha.g1_s,t.key.alpha.g1_sx,t.key.alpha.g2_sp,t.key.alpha.g2_spx),i!==!0?(a&&a.error("INVALID key (alpha) in challenge #"+t.id),!1):(i=await Ln(o,t.key.beta.g1_s,t.key.beta.g1_sx,t.key.beta.g2_sp,t.key.beta.g2_spx),i!==!0?(a&&a.error("INVALID key (beta) in challenge #"+t.id),!1):(i=await Ln(o,n.tauG1,t.tauG1,t.key.tau.g2_sp,t.key.tau.g2_spx),i!==!0?(a&&a.error("INVALID tau*G1. challenge #"+t.id+" It does not follow the previous contribution"),!1):(i=await Ln(o,t.key.tau.g1_s,t.key.tau.g1_sx,n.tauG2,t.tauG2),i!==!0?(a&&a.error("INVALID tau*G2. challenge #"+t.id+" It does not follow the previous contribution"),!1):(i=await Ln(o,n.alphaG1,t.alphaG1,t.key.alpha.g2_sp,t.key.alpha.g2_spx),i!==!0?(a&&a.error("INVALID alpha*G1. challenge #"+t.id+" It does not follow the previous contribution"),!1):(i=await Ln(o,n.betaG1,t.betaG1,t.key.beta.g2_sp,t.key.beta.g2_spx),i!==!0?(a&&a.error("INVALID beta*G1. challenge #"+t.id+" It does not follow the previous contribution"),!1):(i=await Ln(o,t.key.beta.g1_s,t.key.beta.g1_sx,n.betaG2,t.betaG2),i!==!0?(a&&a.error("INVALID beta*G2. challenge #"+t.id+"It does not follow the previous contribution"),!1):(a&&a.info("Powers Of tau file OK!"),!0))))))))}async function Ur(o,t){let n;await Tt.exports.ready();const{fd:a,sections:i}=await Kt(o,"ptau",1),{curve:e,power:l,ceremonyPower:s}=await mn(a,i),h=await pa(a,e,i);t&&t.debug("power: 2**"+l),t&&t.debug("Computing initial contribution hash");const d={tauG1:e.G1.g,tauG2:e.G2.g,alphaG1:e.G1.g,betaG1:e.G1.g,betaG2:e.G2.g,nextChallenge:wa(e,s,t),responseHash:Tt.exports(64).digest()};if(h.length==0)return t&&t.error("This file has no contribution! It cannot be used in production"),!1;let c;h.length>1?c=h[h.length-2]:c=d;const f=h[h.length-1];if(t&&t.debug("Validating contribution #"+h[h.length-1].id),!await ho(e,f,c,t))return!1;const L=Tt.exports(64);L.update(f.responseHash),t&&t.debug("Verifying powers in tau*G1 section");const v=await I(2,"G1","tauG1",2**l*2-1,[0,1],t);if(n=await Ln(e,v.R1,v.R2,e.G2.g,f.tauG2),n!==!0)return t&&t.error("tauG1 section. Powers do not match"),!1;if(!e.G1.eq(e.G1.g,v.singularPoints[0]))return t&&t.error("First element of tau*G1 section must be the generator"),!1;if(!e.G1.eq(f.tauG1,v.singularPoints[1]))return t&&t.error("Second element of tau*G1 section does not match the one in the contribution section"),!1;t&&t.debug("Verifying powers in tau*G2 section");const T=await I(3,"G2","tauG2",2**l,[0,1],t);if(n=await Ln(e,e.G1.g,f.tauG1,T.R1,T.R2),n!==!0)return t&&t.error("tauG2 section. Powers do not match"),!1;if(!e.G2.eq(e.G2.g,T.singularPoints[0]))return t&&t.error("First element of tau*G2 section must be the generator"),!1;if(!e.G2.eq(f.tauG2,T.singularPoints[1]))return t&&t.error("Second element of tau*G2 section does not match the one in the contribution section"),!1;t&&t.debug("Verifying powers in alpha*tau*G1 section");const B=await I(4,"G1","alphatauG1",2**l,[0],t);if(n=await Ln(e,B.R1,B.R2,e.G2.g,f.tauG2),n!==!0)return t&&t.error("alphaTauG1 section. Powers do not match"),!1;if(!e.G1.eq(f.alphaG1,B.singularPoints[0]))return t&&t.error("First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section"),!1;t&&t.debug("Verifying powers in beta*tau*G1 section");const E=await I(5,"G1","betatauG1",2**l,[0],t);if(n=await Ln(e,E.R1,E.R2,e.G2.g,f.tauG2),n!==!0)return t&&t.error("betaTauG1 section. Powers do not match"),!1;if(!e.G1.eq(f.betaG1,E.singularPoints[0]))return t&&t.error("First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section"),!1;const A=await U(t);if(!e.G2.eq(f.betaG2,A))return t&&t.error("betaG2 element in betaG2 section does not match the one in the contribution section"),!1;const G=L.digest();if(l==s&&!kn(G,f.nextChallenge))return t&&t.error("Hash of the values does not match the next challenge of the last contributor in the contributions section"),!1;t&&t.info(nn(G,"Next challenge hash: ")),P(f,c);for(let b=h.length-2;b>=0;b--){const $=h[b],K=b>0?h[b-1]:d;if(!await ho(e,$,K,t))return!1;P($,K)}if(t&&t.info("-----------------------------------------------------"),!i[12]||!i[13]||!i[14]||!i[15])t&&t.warn(`this file does not contain phase2 precalculated values. Please run: 
   snarkjs "powersoftau preparephase2" to prepare this file to be used in the phase2 ceremony.`);else{let b;if(b=await _("G1",2,12,"tauG1",t),!b||(b=await _("G2",3,13,"tauG2",t),!b)||(b=await _("G1",4,14,"alphaTauG1",t),!b)||(b=await _("G1",5,15,"betaTauG1",t),!b))return!1}return await a.close(),t&&t.info("Powers of Tau Ok!"),!0;function P(b,$){if(!t)return;t.info("-----------------------------------------------------"),t.info(`Contribution #${b.id}: ${b.name||""}`),t.info(nn(b.nextChallenge,"Next Challenge: "));const K=new Uint8Array(e.G1.F.n8*2*6+e.G2.F.n8*2*3);ga(K,0,e,b.key,!1);const j=Tt.exports(64);j.setPartialHash(b.partialHash),j.update(K);const M=j.digest();t.info(nn(M,"Response Hash:")),t.info(nn($.nextChallenge,"Response Hash:")),b.type==1&&(t.info(`Beacon generator: ${gs(b.beaconHash)}`),t.info(`Beacon iterations Exp: ${b.numIterationsExp}`))}async function U(b){const $=e.G2,K=$.F.n8*2,j=new Uint8Array(K);if(!i[6])throw b.error("File has no BetaG2 section"),new Error("File has no BetaG2 section");if(i[6].length>1)throw b.error("File has no BetaG2 section"),new Error("File has more than one GetaG2 section");a.pos=i[6][0].p;const M=await a.read(K),S=$.fromRprLEM(M);return $.toRprUncompressed(j,0,S),L.update(j),S}async function I(b,$,K,j,M,S){const q=e[$],Z=q.F.n8*2;await Zt(a,i,b);const Y=[];let V=q.zero,nt=q.zero,Q=q.zero;for(let it=0;it<j;it+=65536){S&&S.debug(`points relations: ${K}: ${it}/${j} `);const X=Math.min(j-it,65536),k=await a.read(X*Z),J=await q.batchLEMtoU(k);L.update(J);const m=ca(4*(X-1));if(it>0){const u=q.fromRprLEM(k,0),x=Xa(ca(4),0);V=q.add(V,q.timesScalar(Q,x)),nt=q.add(nt,q.timesScalar(u,x))}const r=await q.multiExpAffine(k.slice(0,(X-1)*Z),m),C=await q.multiExpAffine(k.slice(Z),m);V=q.add(V,r),nt=q.add(nt,C),Q=q.fromRprLEM(k,(X-1)*Z);for(let u=0;u<M.length;u++){const x=M[u];if(x>=it&&x<it+X){const F=q.fromRprLEM(k,(x-it)*Z);Y.push(F)}}}return await Wt(a),{R1:V,R2:nt,singularPoints:Y}}async function _(b,$,K,j,M){M&&M.debug(`Verifying phase2 calculated values ${j}...`);const S=e[b],z=S.F.n8*2,q=new Array(8);for(let Y=0;Y<8;Y++)q[Y]=Xa(ca(4),0);for(let Y=0;Y<=l;Y++)if(!await Z(Y))return!1;if($==2&&!await Z(l+1))return!1;return!0;async function Z(Y){M&&M.debug(`Power ${Y}...`);const V=e.Fr.n8,nt=2**Y;let Q=new Uint32Array(nt),it,X=new Jn(q);M&&M.debug(`Creating random numbers Powers${Y}...`);for(let C=0;C<nt;C++)Y==l+1&&C==nt-1?Q[C]=0:Q[C]=X.nextU32();Q=new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength),M&&M.debug(`reading points Powers${Y}...`),await Zt(a,i,$),it=new ft(nt*z),Y==l+1?(await a.readToBuffer(it,0,(nt-1)*z),it.set(e.G1.zeroAffine,(nt-1)*z)):await a.readToBuffer(it,0,nt*z),await Wt(a,!0);const k=await S.multiExpAffine(it,Q,M,j+"_"+Y);Q=new ft(nt*V),X=new Jn(q);const J=new Uint8Array(4),m=new DataView(J.buffer);M&&M.debug(`Creating random numbers Powers${Y}...`);for(let C=0;C<nt;C++)(C!=nt-1||Y!=l+1)&&(m.setUint32(0,X.nextU32(),!0),Q.set(J,C*V));M&&M.debug(`batchToMontgomery ${Y}...`),Q=await e.Fr.batchToMontgomery(Q),M&&M.debug(`fft ${Y}...`),Q=await e.Fr.fft(Q),M&&M.debug(`batchFromMontgomery ${Y}...`),Q=await e.Fr.batchFromMontgomery(Q),M&&M.debug(`reading points Lagrange${Y}...`),await Zt(a,i,K),a.pos+=z*(2**Y-1),await a.readToBuffer(it,0,nt*z),await Wt(a,!0);const r=await S.multiExpAffine(it,Q,M,j+"_"+Y+"_transformed");return S.eq(k,r)?!0:(M&&M.error("Phase2 caclutation does not match with powers of tau"),!1)}}}async function ai(o,t,n,a,i,e,l,s,h,d){const f=i[e],y=f.F.n8*2,L=t[a][0].size/y;await Zt(o,t,a),await Rt(n,a);let v=l;for(let T=0;T<L;T+=65536){d&&d.debug(`Applying key: ${h}: ${T}/${L}`);const B=Math.min(L-T,65536);let E;E=await o.read(B*y),E=await f.batchApplyKey(E,v,s),await n.write(E),v=i.Fr.mul(v,i.Fr.exp(s,B))}await kt(n),await Wt(o)}async function Zn(o,t,n,a,i,e,l,s,h,d,c){const f=a[i],y=f.F.n8*2,L=Math.floor((1<<20)/y);let v=l;for(let T=0;T<e;T+=L){c&&c.debug(`Applying key ${d}: ${T}/${e}`);const B=Math.min(e-T,L),E=await o.read(B*y),A=await f.batchUtoLEM(E),G=await f.batchApplyKey(A,v,s);let P;h=="COMPRESSED"?P=await f.batchLEMtoC(G):P=await f.batchLEMtoU(G),n&&n.update(P),await t.write(P),v=a.Fr.mul(v,a.Fr.exp(s,B))}}async function Mr(o,t,n,a,i){await Tt.exports.ready();const e=await Dn(t),l=o.F1.n64*8*2,s=o.F2.n64*8*2,h=(e.totalSize+l-64-s)/(4*l+s);let d=h,c=0;for(;d>1;)d=d/2,c+=1;if(2**c!=h)throw new Error("Invalid file size");i&&i.debug("Power to tau size: "+c);const f=await ci(a),y=await _a(n),L=Tt.exports(64);for(let P=0;P<e.totalSize;P+=e.pageSize){i&&i.debug(`Hashing challenge ${P}/${e.totalSize}`);const U=Math.min(e.totalSize-P,e.pageSize),I=await e.read(U);L.update(I)}const v=await e.read(64,0);i&&i.info(nn(v,"Claimed Previous Response Hash: "));const T=L.digest();i&&i.info(nn(T,"Current Challenge Hash: "));const B=me(o,T,f);i&&["tau","alpha","beta"].forEach(P=>{i.debug(P+".g1_s: "+o.G1.toString(B[P].g1_s,16)),i.debug(P+".g1_sx: "+o.G1.toString(B[P].g1_sx,16)),i.debug(P+".g2_sp: "+o.G2.toString(B[P].g2_sp,16)),i.debug(P+".g2_spx: "+o.G2.toString(B[P].g2_spx,16)),i.debug("")});const E=Tt.exports(64);await y.write(T),E.update(T),await Zn(e,y,E,o,"G1",2**c*2-1,o.Fr.one,B.tau.prvKey,"COMPRESSED","tauG1",i),await Zn(e,y,E,o,"G2",2**c,o.Fr.one,B.tau.prvKey,"COMPRESSED","tauG2",i),await Zn(e,y,E,o,"G1",2**c,B.alpha.prvKey,B.tau.prvKey,"COMPRESSED","alphaTauG1",i),await Zn(e,y,E,o,"G1",2**c,B.beta.prvKey,B.tau.prvKey,"COMPRESSED","betaTauG1",i),await Zn(e,y,E,o,"G2",1,B.beta.prvKey,B.tau.prvKey,"COMPRESSED","betaTauG2",i);const A=new Uint8Array(o.F1.n8*2*6+o.F2.n8*2*3);ga(A,0,o,B,!1),await y.write(A),E.update(A);const G=E.digest();i&&i.info(nn(G,"Contribution Response Hash: ")),await y.close(),await e.close()}async function zr(o,t,n,a,i,e){const l=_s(a);if(l.byteLength==0||l.byteLength*2!=a.length)return e&&e.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(l.length>=256)return e&&e.error("Maximum length of beacon hash is 255 bytes"),!1;if(i=parseInt(i),i<10||i>63)return e&&e.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;await Tt.exports.ready();const{fd:s,sections:h}=await Kt(o,"ptau",1),{curve:d,power:c,ceremonyPower:f}=await mn(s,h);if(c!=f)return e&&e.error("This file has been reduced. You cannot contribute into a reduced file."),!1;h[12]&&e&&e.warn("Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");const y=await pa(s,d,h),L={name:n,type:1,numIterationsExp:i,beaconHash:l};let v;y.length>0?v=y[y.length-1].nextChallenge:v=wa(d,c,e),L.key=await As(d,v,l,i);const T=new Tt.exports(64);T.update(v);const B=await fn(t,"ptau",1,7);await na(B,d,c);const E=[];let A;A=await I(2,"G1",2**c*2-1,d.Fr.e(1),L.key.tau.prvKey,"tauG1",e),L.tauG1=A[1],A=await I(3,"G2",2**c,d.Fr.e(1),L.key.tau.prvKey,"tauG2",e),L.tauG2=A[1],A=await I(4,"G1",2**c,L.key.alpha.prvKey,L.key.tau.prvKey,"alphaTauG1",e),L.alphaG1=A[0],A=await I(5,"G1",2**c,L.key.beta.prvKey,L.key.tau.prvKey,"betaTauG1",e),L.betaG1=A[0],A=await I(6,"G2",1,L.key.beta.prvKey,L.key.tau.prvKey,"betaTauG2",e),L.betaG2=A[0],L.partialHash=T.getPartialHash();const G=new Uint8Array(d.F1.n8*2*6+d.F2.n8*2*3);ga(G,0,d,L.key,!1),T.update(new Uint8Array(G));const P=T.digest();e&&e.info(nn(P,"Contribution Response Hash imported: "));const U=new Tt.exports(64);return U.update(P),await _(B,"G1",2,2**c*2-1,"tauG1",e),await _(B,"G2",3,2**c,"tauG2",e),await _(B,"G1",4,2**c,"alphaTauG1",e),await _(B,"G1",5,2**c,"betaTauG1",e),await _(B,"G2",6,1,"betaG2",e),L.nextChallenge=U.digest(),e&&e.info(nn(L.nextChallenge,"Next Challenge Hash: ")),y.push(L),await be(B,d,y),await s.close(),await B.close(),P;async function I(b,$,K,j,M,S,z){const q=[];s.pos=h[b][0].p,await Rt(B,b),E[b]=B.pos;const Z=d[$],Y=Z.F.n8*2,V=Math.floor((1<<20)/Y);let nt=j;for(let Q=0;Q<K;Q+=V){z&&z.debug(`applying key${S}: ${Q}/${K}`);const it=Math.min(K-Q,V),X=await s.read(it*Y),k=await Z.batchApplyKey(X,nt,M),J=B.write(k),m=await Z.batchLEMtoC(k);if(T.update(m),await J,Q==0)for(let r=0;r<Math.min(2,K);r++)q.push(Z.fromRprLEM(k,r*Y));nt=d.Fr.mul(nt,d.Fr.exp(M,it))}return await kt(B),q}async function _(b,$,K,j,M,S){const z=d[$],q=z.F.n8*2,Z=Math.floor((1<<24)/q),Y=b.pos;b.pos=E[K];for(let V=0;V<j;V+=Z){S&&S.debug(`Hashing ${M}: ${V}/${j}`);const nt=Math.min(j-V,Z),Q=await b.read(nt*q),it=await z.batchLEMtoU(Q);U.update(it)}b.pos=Y}}async function qr(o,t,n,a,i){await Tt.exports.ready();const{fd:e,sections:l}=await Kt(o,"ptau",1),{curve:s,power:h,ceremonyPower:d}=await mn(e,l);if(h!=d)throw i&&i.error("This file has been reduced. You cannot contribute into a reduced file."),new Error("This file has been reduced. You cannot contribute into a reduced file.");l[12]&&i&&i.warn("WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");const c=await pa(e,s,l),f={name:n,type:0};let y;const L=await ci(a);c.length>0?y=c[c.length-1].nextChallenge:y=wa(s,h,i),f.key=me(s,y,L);const v=new Tt.exports(64);v.update(y);const T=await fn(t,"ptau",1,7);await na(T,s,h);const B=[];let E;E=await U(2,"G1",2**h*2-1,s.Fr.e(1),f.key.tau.prvKey,"tauG1"),f.tauG1=E[1],E=await U(3,"G2",2**h,s.Fr.e(1),f.key.tau.prvKey,"tauG2"),f.tauG2=E[1],E=await U(4,"G1",2**h,f.key.alpha.prvKey,f.key.tau.prvKey,"alphaTauG1"),f.alphaG1=E[0],E=await U(5,"G1",2**h,f.key.beta.prvKey,f.key.tau.prvKey,"betaTauG1"),f.betaG1=E[0],E=await U(6,"G2",1,f.key.beta.prvKey,f.key.tau.prvKey,"betaTauG2"),f.betaG2=E[0],f.partialHash=v.getPartialHash();const A=new Uint8Array(s.F1.n8*2*6+s.F2.n8*2*3);ga(A,0,s,f.key,!1),v.update(new Uint8Array(A));const G=v.digest();i&&i.info(nn(G,"Contribution Response Hash imported: "));const P=new Tt.exports(64);return P.update(G),await I(T,"G1",2,2**h*2-1,"tauG1"),await I(T,"G2",3,2**h,"tauG2"),await I(T,"G1",4,2**h,"alphaTauG1"),await I(T,"G1",5,2**h,"betaTauG1"),await I(T,"G2",6,1,"betaG2"),f.nextChallenge=P.digest(),i&&i.info(nn(f.nextChallenge,"Next Challenge Hash: ")),c.push(f),await be(T,s,c),await e.close(),await T.close(),G;async function U(_,b,$,K,j,M){const S=[];e.pos=l[_][0].p,await Rt(T,_),B[_]=T.pos;const z=s[b],q=z.F.n8*2,Z=Math.floor((1<<20)/q);let Y=K;for(let V=0;V<$;V+=Z){i&&i.debug(`processing: ${M}: ${V}/${$}`);const nt=Math.min($-V,Z),Q=await e.read(nt*q),it=await z.batchApplyKey(Q,Y,j),X=T.write(it),k=await z.batchLEMtoC(it);if(v.update(k),await X,V==0)for(let J=0;J<Math.min(2,$);J++)S.push(z.fromRprLEM(it,J*q));Y=s.Fr.mul(Y,s.Fr.exp(j,nt))}return await kt(T),S}async function I(_,b,$,K,j){const M=s[b],S=M.F.n8*2,z=Math.floor((1<<24)/S),q=_.pos;_.pos=B[$];for(let Z=0;Z<K;Z+=z){i&&Z&&i.debug(`Hashing ${j}: `+Z);const Y=Math.min(K-Z,z),V=await _.read(Y*S),nt=await M.batchLEMtoU(V);P.update(nt)}_.pos=q}}async function Qr(o,t,n){const{fd:a,sections:i}=await Kt(o,"ptau",1),{curve:e,power:l}=await mn(a,i),s=await fn(t,"ptau",1,11);await na(s,e,l),await Nt(a,i,s,2),await Nt(a,i,s,3),await Nt(a,i,s,4),await Nt(a,i,s,5),await Nt(a,i,s,6),await Nt(a,i,s,7),await h(2,12,"G1","tauG1"),await h(3,13,"G2","tauG2"),await h(4,14,"G1","alphaTauG1"),await h(5,15,"G1","betaTauG1"),await a.close(),await s.close();return;async function h(d,c,f,y){n&&n.debug("Starting section: "+y),await Rt(s,c);for(let v=0;v<=l;v++)await L(v);d==2&&await L(l+1),await kt(s);async function L(v){const T=2**v,B=e[f],E=B.F.n8*2;let A;A=new ft(T*E),await Zt(a,i,d),d==2&&v==l+1?(await a.readToBuffer(A,0,(T-1)*E),A.set(e.G1.zeroAffine,(T-1)*E)):await a.readToBuffer(A,0,T*E),await Wt(a,!0),A=await B.lagrangeEvaluations(A,"affine","affine",n,y),await s.write(A)}}}async function Rr(o,t,n){const{fd:a,sections:i}=await Kt(o,"ptau",1),{curve:e,power:l,ceremonyPower:s}=await mn(a,i),h=e.G1.F.n8*2,d=e.G2.F.n8*2;for(let f=1;f<l;f++)await c(f);return await a.close(),!0;async function c(f){let y=f.toString();for(;y.length<2;)y="0"+y;n&&n.debug("Writing Power: "+y);const L=await fn(t+y+".ptau","ptau",1,11);await na(L,e,f,s),await Nt(a,i,L,2,(2**f*2-1)*h),await Nt(a,i,L,3,2**f*d),await Nt(a,i,L,4,2**f*h),await Nt(a,i,L,5,2**f*h),await Nt(a,i,L,6,d),await Nt(a,i,L,7),await Nt(a,i,L,12,(2**(f+1)*2-1)*h),await Nt(a,i,L,13,(2**f*2-1)*d),await Nt(a,i,L,14,(2**f*2-1)*h),await Nt(a,i,L,15,(2**f*2-1)*h),await L.close()}}async function kr(o,t,n){const{fd:a,sections:i}=await Kt(o,"ptau",1),{curve:e,power:l}=await mn(a,i),s=await fn(t,"ptau",1,11);await na(s,e,l),await Nt(a,i,s,2),await Nt(a,i,s,3),await Nt(a,i,s,4),await Nt(a,i,s,5),await Nt(a,i,s,6),await Nt(a,i,s,7),await h(2,12,"G1","tauG1"),await Nt(a,i,s,13),await Nt(a,i,s,14),await Nt(a,i,s,15),await a.close(),await s.close();return;async function h(d,c,f,y){n&&n.debug("Starting section: "+y),await Rt(s,c);const L=i[c][0].size,v=a.pageSize;await Zt(a,i,c);for(let B=0;B<L;B+=v){const E=Math.min(L-B,v),A=await a.read(E);await s.write(A)}await Wt(a),await T(l+1),await kt(s);async function T(B){const E=2**B,A=e[f],G=A.F.n8*2;let P;P=new ft(E*G),await Zt(a,i,d),B==l+1?(await a.readToBuffer(P,0,(E-1)*G),P.set(e.G1.zeroAffine,(E-1)*G)):await a.readToBuffer(P,0,E*G),await Wt(a,!0),P=await A.lagrangeEvaluations(P,"affine","affine",n,y),await s.write(P)}}}async function $r(o,t){const{fd:n,sections:a}=await Kt(o,"ptau",1),{curve:i,power:e}=await mn(n,a),l={};return l.q=i.q,l.power=e,l.contributions=await pa(n,i,a),l.tauG1=await s(2,"G1",2**e*2-1,"tauG1"),l.tauG2=await s(3,"G2",2**e,"tauG2"),l.alphaTauG1=await s(4,"G1",2**e,"alphaTauG1"),l.betaTauG1=await s(5,"G1",2**e,"betaTauG1"),l.betaG2=await s(6,"G2",1,"betaG2"),l.lTauG1=await h(12,"G1","lTauG1"),l.lTauG2=await h(13,"G2","lTauG2"),l.lAlphaTauG1=await h(14,"G1","lAlphaTauG2"),l.lBetaTauG1=await h(15,"G1","lBetaTauG2"),await n.close(),Ja(i.Fr,l);async function s(d,c,f,y){const L=i[c],v=L.F.n8*2,T=[];await Zt(n,a,d);for(let B=0;B<f;B++){t&&B&&B%1e4==0&&console.log(`${y}: `+B);const E=await n.read(v);T.push(L.fromRprLEM(E,0))}return await Wt(n),T}async function h(d,c,f){const y=i[c],L=y.F.n8*2,v=[];await Zt(n,a,d);for(let T=0;T<=e;T++){t&&console.log(`${f}: Power: ${T}`),v[T]=[];const B=2**T;for(let E=0;E<B;E++){t&&E&&E%1e4==0&&console.log(`${f}: ${E}/${B}`);const A=await n.read(L);v[T].push(y.fromRprLEM(A,0))}}return await Wt(n,!0),v}}var gu=Object.freeze({__proto__:null,newAccumulator:Pr,exportChallenge:Tr,importResponse:Or,verify:Ur,challengeContribute:Mr,beacon:zr,contribute:qr,preparePhase2:Qr,truncate:Rr,convert:kr,exportJson:$r});function Nr(o,t,n){for(let i=0;i<o.constraints.length;i++)a(o.constraints[i]);function a(i){const e=s=>{let h="";return Object.keys(s).forEach(c=>{let f=t.varIdx2Name[c];f=="one"&&(f="1");let y=o.curve.Fr.toString(s[c]);y=="1"&&(y=""),y=="-1"&&(y="-"),h!=""&&y[0]!="-"&&(y="+"+y),h!=""&&(y=" "+y),h=h+y+f}),h},l=`[ ${e(i[0])} ] * [ ${e(i[1])} ] - [ ${e(i[2])} ] = 0`;n&&n.info(l)}}const In=262144,Dr={get:function(o,t){return isNaN(t)?o[t]:o.getElement(t)},set:function(o,t,n){return isNaN(t)?(o[t]=n,!0):o.setElement(t,n)}};class Vr{constructor(t){this.length=t||0,this.arr=new Array(In);for(let n=0;n<t;n+=In)this.arr[n/In]=new Array(Math.min(In,t-n));return this}push(){for(let t=0;t<arguments.length;t++)this.setElement(this.length,arguments[t])}slice(t,n){const a=new Array(n-t);for(let i=t;i<n;i++)a[i-t]=this.getElement(i);return a}getElement(t){t=parseInt(t);const n=Math.floor(t/In),a=t%In;return this.arr[n]?this.arr[n][a]:void 0}setElement(t,n){t=parseInt(t);const a=Math.floor(t/In);this.arr[a]||(this.arr[a]=new Array(In));const i=t%In;return this.arr[a][i]=n,t>=this.length&&(this.length=t+1),!0}getKeys(){const t=new ys;for(let n=0;n<this.arr.length;n++)if(this.arr[n])for(let a=0;a<this.arr[n].length;a++)typeof this.arr[n][a]<"u"&&t.push(n*In+a);return t}}class ys{constructor(t){const n=new Vr(t);return new Proxy(n,Dr)}}var Ae=ys;const ne=4,ae=5;async function Cs(o,t,n){let a;typeof n=="object"?a=n:typeof n>"u"?a={singleThread:!1}:a={singleThread:n};const i={};if(await Zt(o,t,1),i.n8=await o.readULE32(),i.prime=await Bn(o,i.n8),a.F){if(a.F.p!=i.prime)throw new Error("Different Prime");i.F=a.F}else if(a.getFieldFromPrime)i.F=await a.getFieldFromPrime(i.prime,a.singleThread);else if(a.getCurveFromPrime)i.curve=await a.getCurveFromPrime(i.prime,a.singleThread),i.F=i.curve.Fr;else try{i.curve=await Ll(i.prime,a.singleThread),i.F=i.curve.Fr}catch{i.F=new re(i.prime)}return i.nVars=await o.readULE32(),i.nOutputs=await o.readULE32(),i.nPubInputs=await o.readULE32(),i.nPrvInputs=await o.readULE32(),i.nLabels=await o.readULE64(),i.nConstraints=await o.readULE32(),i.useCustomGates=typeof t[ne]<"u"&&t[ne]!==null&&typeof t[ae]<"u"&&t[ae]!==null,await Wt(o),i}async function Hr(o,t,n,a,i){let e;typeof a=="object"?e=a:typeof a>"u"?e={}:e={logger:a,loggerCtx:i};const l=await Vt(o,t,2);let s=0,h;n.nConstraints>1<<20?h=new Ae:h=[];for(let f=0;f<n.nConstraints;f++){e.logger&&f%1e5==0&&e.logger.info(`${e.loggerCtx}: Loading constraints: ${f}/${n.nConstraints}`);const y=d();h.push(y)}return h;function d(){const f=[];return f[0]=c(),f[1]=c(),f[2]=c(),f}function c(){const f={},y=l.slice(s,s+4);s+=4;const v=new DataView(y.buffer).getUint32(0,!0),T=l.slice(s,s+(4+n.n8)*v);s+=(4+n.n8)*v;const B=new DataView(T.buffer);for(let E=0;E<v;E++){const A=B.getUint32(E*(4+n.n8),!0),G=n.F.fromRprLE(T,E*(4+n.n8)+4);f[A]=G}return f}}async function Kr(o,t,n,a,i){let e;typeof a=="object"?e=a:typeof a>"u"?e={}:e={logger:a,loggerCtx:i};const l=await Vt(o,t,3);let s=0,h;n.nVars>1<<20?h=new Ae:h=[];for(let c=0;c<n.nVars;c++){e.logger&&c%1e4==0&&e.logger.info(`${e.loggerCtx}: Loading map: ${c}/${n.nVars}`);const f=d();h.push(f)}return h;function d(){const c=l.slice(s,s+8);s+=8;const f=new DataView(c.buffer),y=f.getUint32(0,!0);return f.getUint32(4,!0)*4294967296+y}}async function ri(o,t,n){if(typeof n!="object")throw new Error("readR1csFd: options must be an object");n.loadConstraints="loadConstraints"in n?n.loadConstraints:!0,n.loadMap="loadMap"in n?n.loadMap:!1,n.loadCustomGates="loadCustomGates"in n?n.loadCustomGates:!0;const a=await Cs(o,t,n);return n.loadConstraints&&(a.constraints=await Hr(o,t,a,n)),n.loadMap&&(a.map=await Kr(o,t,a,n)),n.loadCustomGates&&(a.useCustomGates?(a.customGates=await jr(o,t,a),a.customGatesUses=await Zr(o,t,n)):(a.customGates=[],a.customGatesUses=[])),a}async function Is(o,t,n,a,i,e){let l;typeof t=="object"?l=t:typeof t>"u"?l={loadConstraints:!0,loadMap:!1,loadCustomGates:!0}:l={loadConstraints:t,loadMap:n,singleThread:a,logger:i,loggerCtx:e};const{fd:s,sections:h}=await Kt(o,"r1cs",1),d=await ri(s,h,l);return await s.close(),d}async function jr(o,t,n){await Zt(o,t,ne);let a=await o.readULE32(),i=[];for(let e=0;e<a;e++){let l={};l.templateName=await o.readString();let s=await o.readULE32();l.parameters=Array(s);let h=await o.read(n.n8*s);for(let d=0;d<s;d++)l.parameters[d]=n.F.fromRprLE(h,d*n.n8,n.n8);i.push(l)}return await Wt(o),i}async function Zr(o,t,n){const a=await Vt(o,t,ae),i=new Uint32Array(a.buffer,a.byteOffset,a.byteLength/4),e=i[0];let l=1,s;e>1<<20?s=new Ae:s=[];for(let h=0;h<e;h++){n.logger&&h%1e5==0&&n.logger.info(`${n.loggerCtx}: Loading custom gate uses: ${h}/${e}`);let d={};d.id=i[l++];let c=i[l++];d.signals=[];for(let f=0;f<c;f++){const y=i[l++],L=i[l++];d.signals.push(L*4294967296+y)}s.push(d)}return s}const Wr=Ft.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),Yr=Ft.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");async function Xr(o,t){const n=await Is(o);return Ft.eq(n.prime,Yr)?t&&t.info("Curve: bn-128"):Ft.eq(n.prime,Wr)?t&&t.info("Curve: bls12-381"):t&&t.info(`Unknown Curve. Prime: ${Ft.toString(n.prime)}`),t&&t.info(`# of Wires: ${n.nVars}`),t&&t.info(`# of Constraints: ${n.nConstraints}`),t&&t.info(`# of Private Inputs: ${n.nPrvInputs}`),t&&t.info(`# of Public Inputs: ${n.nPubInputs}`),t&&t.info(`# of Labels: ${n.nLabels}`),t&&t.info(`# of Outputs: ${n.nOutputs}`),n}async function Jr(o,t){const n=await Is(o,!0,!0,!0,t),a=n.curve.Fr;return delete n.curve,delete n.F,Ja(a,n)}var pu=Object.freeze({__proto__:null,print:Nr,info:Xr,exportJson:Jr});async function Va(o){const t={labelIdx2Name:["one"],varIdx2Name:["one"],componentIdx2Name:[]},n=await Dn(o),a=await n.read(n.totalSize),e=new TextDecoder("utf-8").decode(a).split(`
`);for(let s=0;s<e.length;s++){const h=e[s].split(",");h.length==4&&(t.varIdx2Name[h[1]]?t.varIdx2Name[h[1]]+="|"+h[3]:t.varIdx2Name[h[1]]=h[3],t.labelIdx2Name[h[0]]=h[3],t.componentIdx2Name[h[2]]||(t.componentIdx2Name[h[2]]=l(h[3])))}return await n.close(),t;function l(s){const h=s.split(".");return h.pop(),h.join(".")}}const{unstringifyBigInts:td}=cn;async function nd(o,t,n,a,i,e){const l=td(o),s=await Dn(t),h=await s.read(s.totalSize);await s.close();const d={...i,sanityCheck:!0};let c=await Va(a);i.set&&(c||(c=await Va(a)),d.logSetSignal=function(v,T){e&&e.info("SET "+c.labelIdx2Name[v]+" <-- "+T.toString())}),i.get&&(c||(c=await Va(a)),d.logGetSignal=function(v,T){e&&e.info("GET "+c.labelIdx2Name[v]+" --> "+T.toString())}),i.trigger&&(c||(c=await Va(a)),d.logStartComponent=function(v){e&&e.info("START: "+c.componentIdx2Name[v])},d.logFinishComponent=function(v){e&&e.info("FINISH: "+c.componentIdx2Name[v])}),d.sym=c;const f=await ms(h,d),y=await f.calculateWitness(l,!0),L=await fn(n,"wtns",2,2);await fr(L,y,f.prime),await L.close()}async function ad(o){return await _r(o)}async function id(o,t,n){n&&n.info("WITNESS CHECKING STARTED"),n&&n.info("> Reading r1cs file");const{fd:a,sections:i}=await Kt(o,"r1cs",1),e=await ri(a,i,{loadConstraints:!1,loadCustomGates:!1});n&&n.info("> Reading witness file");const{fd:l,sections:s}=await Kt(t,"wtns",2),h=await Ra(l,s);if(!Ft.eq(e.prime,h.q))throw new Error("Curve of the witness does not match the curve of the proving key");const d=await Vt(l,s,2);await l.close();const f=(await ss(e.prime)).Fr,y=f.n8,L=await Vt(a,i,2);n&&(n.info("----------------------------"),n.info("  WITNESS CHECK"),n.info(`  Curve:          ${e.curve.name}`),n.info(`  Vars (wires):   ${e.nVars}`),n.info(`  Outputs:        ${e.nOutputs}`),n.info(`  Public Inputs:  ${e.nPubInputs}`),n.info(`  Private Inputs: ${e.nPrvInputs}`),n.info(`  Labels:         ${e.nLabels}`),n.info(`  Constraints:    ${e.nConstraints}`),n.info(`  Custom Gates:   ${e.useCustomGates}`),n.info("----------------------------")),n&&n.info("> Checking witness correctness");let v=0,T=!0;for(let G=0;G<e.nConstraints;G++){n&&G!==0&&G%5e5===0&&n.info(` processing r1cs constraints ${G}/${e.nConstraints}`);const P=E(),U=E(),I=E(),_=B(P),b=B(U),$=B(I);if(!f.eq(f.sub(f.mul(_,b),$),f.zero)){n.warn(" aborting checking process at constraint "+G),T=!1;break}}return a.close(),n&&(T?(n.info("WITNESS IS CORRECT"),n.info("WITNESS CHECKING FINISHED SUCCESSFULLY")):(n.warn("WITNESS IS NOT CORRECT"),n.warn("WITNESS CHECKING FINISHED UNSUCCESSFULLY"))),T;function B(G){let P=f.zero;return Object.keys(G).forEach(I=>{const _=A(I),b=G[I];P=f.add(P,f.mul(_,b))}),P}function E(){const G={},P=L.slice(v,v+4);v+=4;const I=new DataView(P.buffer).getUint32(0,!0),_=L.slice(v,v+(4+e.n8)*I);v+=(4+e.n8)*I;const b=new DataView(_.buffer);for(let $=0;$<I;$++){const K=b.getUint32($*(4+e.n8),!0),j=e.F.fromRprLE(_,$*(4+e.n8)+4);G[K]=j}return G}function A(G){return f.fromRprLE(d.slice(G*y,G*y+y))}}var wu=Object.freeze({__proto__:null,calculate:li,debug:nd,exportJson:ad,check:id});const En=262144,ed={get:function(o,t){return isNaN(t)?o[t]:o.getElement(t)},set:function(o,t,n){return isNaN(t)?(o[t]=n,!0):o.setElement(t,n)}};class od{constructor(t){this.length=t||0,this.arr=new Array(En);for(let n=0;n<t;n+=En)this.arr[n/En]=new Array(Math.min(En,t-n));return this}push(){for(let t=0;t<arguments.length;t++)this.setElement(this.length,arguments[t])}slice(t,n){const a=new Array(n-t);for(let i=t;i<n;i++)a[i-t]=this.getElement(i);return a}getElement(t){t=parseInt(t);const n=Math.floor(t/En),a=t%En;return this.arr[n]?this.arr[n][a]:void 0}setElement(t,n){t=parseInt(t);const a=Math.floor(t/En);this.arr[a]||(this.arr[a]=new Array(En));const i=t%En;return this.arr[a][i]=n,t>=this.length&&(this.length=t+1),!0}getKeys(){const t=new Es;for(let n=0;n<this.arr.length;n++)if(this.arr[n])for(let a=0;a<this.arr[n].length;a++)typeof this.arr[n][a]<"u"&&t.push(n*En+a);return t}}class Es{constructor(t){const n=new od(t);return new Proxy(n,ed)}}var wn=Es;async function Fs(o,t,n,a){await Tt.exports.ready();const h=Tt.exports(64),{fd:d,sections:c}=await Kt(t,"ptau",1),{curve:f,power:y}=await mn(d,c),{fd:L,sections:v}=await Kt(o,"r1cs",1),T=await Cs(L,v,!1),B=await fn(n,"zkey",1,10,1<<22,1<<24),E=f.G1.F.n8*2,A=f.G2.F.n8*2;if(T.prime!=f.r)return a&&a.error("r1cs curve does not match powers of tau ceremony curve"),-1;const G=Vn(T.nConstraints+T.nPubInputs+T.nOutputs+1-1)+1;if(G>y)return a&&a.error(`circuit too big for this power of tau ceremony. ${T.nConstraints}*2 > 2**${y}`),-1;if(!c[12])return a&&a.error("Powers of tau is not prepared."),-1;const P=T.nOutputs+T.nPubInputs,U=2**G;await Rt(B,1),await B.writeULE32(1),await kt(B),await Rt(B,2);const I=f.q,_=(Math.floor((Ft.bitLength(I)-1)/64)+1)*8,b=f.r,$=(Math.floor((Ft.bitLength(b)-1)/64)+1)*8,K=Ft.mod(Ft.shl(1,$*8),b),j=f.Fr.e(Ft.mod(Ft.mul(K,K),b));await B.writeULE32(_),await An(B,I,_),await B.writeULE32($),await An(B,b,$),await B.writeULE32(T.nVars),await B.writeULE32(P),await B.writeULE32(U);let M;M=await d.read(E,c[4][0].p),await B.write(M),M=await f.G1.batchLEMtoU(M),h.update(M);let S;S=await d.read(E,c[5][0].p),await B.write(S),S=await f.G1.batchLEMtoU(S),h.update(S);let z;z=await d.read(A,c[6][0].p),await B.write(z),z=await f.G2.batchLEMtoU(z),h.update(z);const q=new Uint8Array(E);f.G1.toRprLEM(q,0,f.G1.g);const Z=new Uint8Array(A);f.G2.toRprLEM(Z,0,f.G2.g);const Y=new Uint8Array(E);f.G1.toRprUncompressed(Y,0,f.G1.g);const V=new Uint8Array(A);f.G2.toRprUncompressed(V,0,f.G2.g),await B.write(Z),await B.write(q),await B.write(Z),h.update(V),h.update(Y),h.update(V),await kt(B),a&&a.info("Reading r1cs");let nt=await Vt(L,v,2);const Q=new wn(T.nVars),it=new wn(T.nVars),X=new wn(T.nVars),k=new wn(T.nVars-P-1),J=new Array(P+1);a&&a.info("Reading tauG1");let m=await Vt(d,c,12,(U-1)*E,U*E);a&&a.info("Reading tauG2");let r=await Vt(d,c,13,(U-1)*A,U*A);a&&a.info("Reading alphatauG1");let C=await Vt(d,c,14,(U-1)*E,U*E);a&&a.info("Reading betatauG1");let u=await Vt(d,c,15,(U-1)*E,U*E);await p(),await O(3,"G1",J,"IC"),await F(),await N(),await O(8,"G1",k,"C"),await O(5,"G1",Q,"A"),await O(6,"G1",it,"B1"),await O(7,"G2",X,"B2");const x=h.digest();return await Rt(B,10),await B.write(x),await B.writeULE32(0),await kt(B),a&&a.info(nn(x,"Circuit hash: ")),await B.close(),await L.close(),await d.close(),x;async function F(){await Rt(B,9);const pt=new ft(U*E);if(G<f.Fr.s){let ut=await Vt(d,c,12,(U*2-1)*E,U*2*E);for(let st=0;st<U;st++){a&&st%1e4==0&&a.debug(`splitting buffer: ${st}/${U}`);const ct=ut.slice((st*2+1)*E,(st*2+1)*E+E);pt.set(ct,st*E)}}else if(G==f.Fr.s){const ut=c[12][0].p+(2**(G+1)-1)*E;await d.readToBuffer(pt,0,U*E,ut+U*E)}else throw a&&a.error("Circuit too big"),new Error("Circuit too big for this curve");await B.write(pt),await kt(B)}async function p(){const pt=new Uint8Array(12+f.Fr.n8),ut=new DataView(pt.buffer),st=new Uint8Array(f.Fr.n8);f.Fr.toRprLE(st,0,f.Fr.e(1));let ct=0;function Lt(){const bt=nt.slice(ct,ct+4);return ct+=4,new DataView(bt.buffer).getUint32(0,!0)}const At=new wn;for(let bt=0;bt<T.nConstraints;bt++){a&&bt%1e4==0&&a.debug(`processing constraints: ${bt}/${T.nConstraints}`);const qt=Lt();for(let ot=0;ot<qt;ot++){const g=Lt(),w=ct;ct+=f.Fr.n8;const W=0,at=E*bt,D=3,et=E*bt;typeof Q[g]>"u"&&(Q[g]=[]),Q[g].push([W,at,w]),g<=P?(typeof J[g]>"u"&&(J[g]=[]),J[g].push([D,et,w])):(typeof k[g-P-1]>"u"&&(k[g-P-1]=[]),k[g-P-1].push([D,et,w])),At.push([0,bt,g,w])}const Yt=Lt();for(let ot=0;ot<Yt;ot++){const g=Lt(),w=ct;ct+=f.Fr.n8;const W=0,at=E*bt,D=1,et=A*bt,tt=2,rt=E*bt;typeof it[g]>"u"&&(it[g]=[]),it[g].push([W,at,w]),typeof X[g]>"u"&&(X[g]=[]),X[g].push([D,et,w]),g<=P?(typeof J[g]>"u"&&(J[g]=[]),J[g].push([tt,rt,w])):(typeof k[g-P-1]>"u"&&(k[g-P-1]=[]),k[g-P-1].push([tt,rt,w])),At.push([1,bt,g,w])}const Ht=Lt();for(let ot=0;ot<Ht;ot++){const g=Lt(),w=ct;ct+=f.Fr.n8;const W=0,at=E*bt;g<=P?(typeof J[g]>"u"&&(J[g]=[]),J[g].push([W,at,w])):(typeof k[g-P-1]>"u"&&(k[g-P-1]=[]),k[g-P-1].push([W,at,w]))}}for(let bt=0;bt<=P;bt++){const Yt=E*(T.nConstraints+bt),Ht=3,ot=E*(T.nConstraints+bt);typeof Q[bt]>"u"&&(Q[bt]=[]),Q[bt].push([0,Yt,-1]),typeof J[bt]>"u"&&(J[bt]=[]),J[bt].push([Ht,ot,-1]),At.push([0,T.nConstraints+bt,bt,-1])}await Rt(B,4);const Bt=new ft(At.length*(12+f.Fr.n8)+4),Mt=new Uint8Array(4);new DataView(Mt.buffer).setUint32(0,At.length,!0),Bt.set(Mt);let Dt=4;for(let bt=0;bt<At.length;bt++)a&&bt%1e5==0&&a.debug(`writing coeffs: ${bt}/${At.length}`),vt(At[bt]);await B.write(Bt),await kt(B);function vt(bt){ut.setUint32(0,bt[0],!0),ut.setUint32(4,bt[1],!0),ut.setUint32(8,bt[2],!0);let qt;bt[3]>=0?qt=f.Fr.fromRprLE(nt.slice(bt[3],bt[3]+f.Fr.n8),0):qt=f.Fr.fromRprLE(st,0);const Yt=f.Fr.mul(qt,j);f.Fr.toRprLE(pt,12,Yt),Bt.set(pt,Dt),Dt+=pt.length}}async function O(pt,ut,st,ct){const At=f[ut];ht(st.length),await Rt(B,pt);let Bt=[],Mt=0;for(;Mt<st.length;){let $t=0;for(;Mt<st.length&&$t<f.tm.concurrency;){a&&a.debug(`Writing points start ${ct}: ${Mt}/${st.length}`);let vt=1,bt=st[Mt]?st[Mt].length:0;for(;Mt+vt<st.length&&bt+(st[Mt+vt]?st[Mt+vt].length:0)<32768&&vt<32768;)bt+=st[Mt+vt]?st[Mt+vt].length:0,vt++;const qt=st.slice(Mt,Mt+vt),Yt=Mt;Bt.push(R(ut,qt,a,ct).then(Ht=>(a&&a.debug(`Writing points end ${ct}: ${Yt}/${st.length}`),Ht))),Mt+=vt,$t++}const Dt=await Promise.all(Bt);for(let vt=0;vt<Dt.length;vt++){await B.write(Dt[vt][0]);const bt=await At.batchLEMtoU(Dt[vt][0]);h.update(bt)}Bt=[]}await kt(B)}async function R(pt,ut,st,ct){const Lt=f[pt],At=Lt.F.n8*2,Bt=Lt.F.n8*3,Mt=Lt.F.n8*2;let $t,Dt,vt,bt;if(pt=="G1")$t="g1m_timesScalarAffine",Dt="g1m_multiexpAffine",vt="g1m_batchToAffine",bt="g1m_zero";else if(pt=="G2")$t="g2m_timesScalarAffine",Dt="g2m_multiexpAffine",vt="g2m_batchToAffine",bt="g2m_zero";else throw new Error("Invalid group");let qt=0;for(let D=0;D<ut.length;D++)qt+=ut[D]?ut[D].length:0;let Yt,Ht;qt>32768?(Yt=new ft(qt*At),Ht=new ft(qt*f.Fr.n8)):(Yt=new Uint8Array(qt*At),Ht=new Uint8Array(qt*f.Fr.n8));let ot=0,g=0;const w=[m,r,C,u],W=new Uint8Array(f.Fr.n8);f.Fr.toRprLE(W,0,f.Fr.e(1));let at=0;for(let D=0;D<ut.length;D++)if(ut[D])for(let et=0;et<ut[D].length;et++)st&&et&&et%1e4==0&&st.debug(`Configuring big array ${ct}: ${et}/${ut[D].length}`),Yt.set(w[ut[D][et][0]].slice(ut[D][et][1],ut[D][et][1]+At),at*At),ut[D][et][2]>=0?Ht.set(nt.slice(ut[D][et][2],ut[D][et][2]+f.Fr.n8),at*f.Fr.n8):Ht.set(W,at*f.Fr.n8),at++;if(ut.length>1){const D=[];D.push({cmd:"ALLOCSET",var:0,buff:Yt}),D.push({cmd:"ALLOCSET",var:1,buff:Ht}),D.push({cmd:"ALLOC",var:2,len:ut.length*Bt}),ot=0,g=0;let et=0;for(let rt=0;rt<ut.length;rt++){if(!ut[rt]){D.push({cmd:"CALL",fnName:bt,params:[{var:2,offset:et}]}),et+=Bt;continue}ut[rt].length==1?D.push({cmd:"CALL",fnName:$t,params:[{var:0,offset:ot},{var:1,offset:g},{val:f.Fr.n8},{var:2,offset:et}]}):D.push({cmd:"CALL",fnName:Dt,params:[{var:0,offset:ot},{var:1,offset:g},{val:f.Fr.n8},{val:ut[rt].length},{var:2,offset:et}]}),ot+=At*ut[rt].length,g+=f.Fr.n8*ut[rt].length,et+=Bt}return D.push({cmd:"CALL",fnName:vt,params:[{var:2},{val:ut.length},{var:2}]}),D.push({cmd:"GET",out:0,var:2,len:ut.length*Mt}),await f.tm.queueAction(D)}else{let D=await Lt.multiExpAffine(Yt,Ht,st,ct);return D=[Lt.toAffine(D)],D}}async function N(){ht(U-1);for(let ut=0;ut<U-1;ut+=16384){a&&a.debug(`HashingHPoints: ${ut}/${U}`);const st=Math.min(U-1,16384);await H(ut,st)}}async function H(pt,ut){const st=await d.read(ut*E,c[2][0].p+(pt+U)*E),ct=await d.read(ut*E,c[2][0].p+pt*E),Lt=f.tm.concurrency,At=Math.floor(ut/Lt),Bt=[];for(let $t=0;$t<Lt;$t++){let Dt;if($t<Lt-1?Dt=At:Dt=ut-$t*At,Dt==0)continue;const vt=st.slice($t*At*E,($t*At+Dt)*E),bt=ct.slice($t*At*E,($t*At+Dt)*E);Bt.push(lt(vt,bt))}const Mt=await Promise.all(Bt);for(let $t=0;$t<Mt.length;$t++)h.update(Mt[$t][0])}async function lt(pt,ut){const st=pt.byteLength/E,ct=f.G1.F.n8*3,Lt=[];Lt.push({cmd:"ALLOCSET",var:0,buff:pt}),Lt.push({cmd:"ALLOCSET",var:1,buff:ut}),Lt.push({cmd:"ALLOC",var:2,len:st*ct});for(let Bt=0;Bt<st;Bt++)Lt.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:Bt*E},{var:1,offset:Bt*E},{var:2,offset:Bt*ct}]});return Lt.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:st},{var:2}]}),Lt.push({cmd:"CALL",fnName:"g1m_batchLEMtoU",params:[{var:2},{val:st},{var:2}]}),Lt.push({cmd:"GET",out:0,var:2,len:st*E}),await f.tm.queueAction(Lt)}function ht(pt){const ut=new Uint8Array(4);new DataView(ut.buffer,ut.byteOffset,ut.byteLength).setUint32(0,pt,!1),h.update(ut)}}async function sd(o,t,n){const{fd:a,sections:i}=await Kt(o,"zkey",2),e=await yn(a,i);if(e.protocol!="groth16")throw new Error("zkey file is not groth16");const l=await hn(e.q),s=l.G1.F.n8*2,h=l.G2.F.n8*2,d=await fa(a,l,i),c=await _a(t);await A(e.vk_alpha_1),await A(e.vk_beta_1),await G(e.vk_beta_2),await G(e.vk_gamma_2),await A(e.vk_delta_1),await G(e.vk_delta_2);let f;f=await Vt(a,i,3),f=await l.G1.batchLEMtoU(f),await P("G1",f);const y=await Vt(a,i,9);let L;L=await l.G1.fft(y,"affine","jacobian",n),L=await l.G1.batchApplyKey(L,l.Fr.neg(l.Fr.e(2)),l.Fr.w[e.power+1],"jacobian","affine",n),L=L.slice(0,L.byteLength-s),L=await l.G1.batchLEMtoU(L),await P("G1",L);let v;v=await Vt(a,i,8),v=await l.G1.batchLEMtoU(v),await P("G1",v);let T;T=await Vt(a,i,5),T=await l.G1.batchLEMtoU(T),await P("G1",T);let B;B=await Vt(a,i,6),B=await l.G1.batchLEMtoU(B),await P("G1",B);let E;E=await Vt(a,i,7),E=await l.G2.batchLEMtoU(E),await P("G2",E),await c.write(d.csHash),await U(d.contributions.length);for(let I=0;I<d.contributions.length;I++){const _=d.contributions[I];await A(_.deltaAfter),await A(_.delta.g1_s),await A(_.delta.g1_sx),await G(_.delta.g2_spx),await c.write(_.transcript)}await a.close(),await c.close();async function A(I){const _=new Uint8Array(s);l.G1.toRprUncompressed(_,0,I),await c.write(_)}async function G(I){const _=new Uint8Array(h);l.G2.toRprUncompressed(_,0,I),await c.write(_)}async function P(I,_){let b;I=="G1"?b=s:b=h;const $=new Uint8Array(4);new DataView($.buffer,$.byteOffset,$.byteLength).setUint32(0,_.byteLength/b,!1),await c.write($),await c.write(_)}async function U(I){const _=new Uint8Array(4);new DataView(_.buffer,_.byteOffset,_.byteLength).setUint32(0,I,!1),await c.write(_)}}async function cd(o,t,n,a,i){const{fd:e,sections:l}=await Kt(o,"zkey",2),s=await yn(e,l,!1);if(s.protocol!="groth16")throw new Error("zkey file is not groth16");const h=await hn(s.q),d=h.G1.F.n8*2,c=h.G2.F.n8*2,f=await fa(e,h,l),y={},L=await Dn(t);L.pos=d*3+c*3+8+d*s.nVars+4+d*(s.domainSize-1)+4+d*s.nVars+4+d*s.nVars+4+c*s.nVars,y.csHash=await L.read(64);const v=await L.readUBE32();y.contributions=[];for(let q=0;q<v;q++){const Z={delta:{}};Z.deltaAfter=await M(L),Z.delta.g1_s=await M(L),Z.delta.g1_sx=await M(L),Z.delta.g2_spx=await S(L),Z.transcript=await L.read(64),q<f.contributions.length&&(Z.type=f.contributions[q].type,Z.type==1&&(Z.beaconHash=f.contributions[q].beaconHash,Z.numIterationsExp=f.contributions[q].numIterationsExp),f.contributions[q].name&&(Z.name=f.contributions[q].name)),y.contributions.push(Z)}if(!kn(y.csHash,f.csHash))return i&&i.error("Hash of the original circuit does not match with the MPC one"),!1;if(f.contributions.length>y.contributions.length)return i&&i.error("The impoerted file does not include new contributions"),!1;for(let q=0;q<f.contributions.length;q++)if(!z(f.contributions[q],y.contributions[q]))return i&&i.error(`Previous contribution ${q} does not match`),!1;if(a)for(let q=f.contributions.length;q<y.contributions.length;q++)y.contributions[q].name=a;const T=await fn(n,"zkey",1,10);if(L.pos=0,L.pos+=d,L.pos+=d,L.pos+=c,L.pos+=c,s.vk_delta_1=await M(L),s.vk_delta_2=await S(L),await we(T,s),await L.readUBE32()!=s.nPublic+1)return i&&i.error("Invalid number of points in IC"),await T.discard(),!1;if(L.pos+=d*(s.nPublic+1),await Nt(e,l,T,3),await Nt(e,l,T,4),await L.readUBE32()!=s.domainSize-1)return i&&i.error("Invalid number of points in H"),await T.discard(),!1;let A;const G=await L.read(d*(s.domainSize-1)),P=await h.G1.batchUtoLEM(G);A=new Uint8Array(s.domainSize*d),A.set(P),h.G1.toRprLEM(A,d*(s.domainSize-1),h.G1.zeroAffine);const U=h.Fr.neg(h.Fr.inv(h.Fr.e(2))),I=h.Fr.inv(h.Fr.w[s.power+1]);if(A=await h.G1.batchApplyKey(A,U,I,"affine","jacobian",i),A=await h.G1.ifft(A,"jacobian","affine",i),await Rt(T,9),await T.write(A),await kt(T),await L.readUBE32()!=s.nVars-s.nPublic-1)return i&&i.error("Invalid number of points in L"),await T.discard(),!1;let b;if(b=await L.read(d*(s.nVars-s.nPublic-1)),b=await h.G1.batchUtoLEM(b),await Rt(T,8),await T.write(b),await kt(T),await L.readUBE32()!=s.nVars)return i&&i.error("Invalid number of points in A"),await T.discard(),!1;if(L.pos+=d*s.nVars,await Nt(e,l,T,5),await L.readUBE32()!=s.nVars)return i&&i.error("Invalid number of points in B1"),await T.discard(),!1;if(L.pos+=d*s.nVars,await Nt(e,l,T,6),await L.readUBE32()!=s.nVars)return i&&i.error("Invalid number of points in B2"),await T.discard(),!1;return L.pos+=c*s.nVars,await Nt(e,l,T,7),await Le(T,h,y),await L.close(),await T.close(),await e.close(),!0;async function M(q){const Z=await q.read(h.G1.F.n8*2);return h.G1.fromRprUncompressed(Z,0)}async function S(q){const Z=await q.read(h.G2.F.n8*2);return h.G2.fromRprUncompressed(Z,0)}function z(q,Z){return!(!h.G1.eq(q.deltaAfter,Z.deltaAfter)||!h.G1.eq(q.delta.g1_s,Z.delta.g1_s)||!h.G1.eq(q.delta.g1_sx,Z.delta.g1_sx)||!h.G2.eq(q.delta.g2_spx,Z.delta.g2_spx)||!kn(q.transcript,Z.transcript))}}const Ia=hs;async function Bs(o,t,n,a){let i;await Tt.exports.ready();const{fd:e,sections:l}=await Kt(n,"zkey",2),s=await yn(e,l,!1);if(s.protocol!="groth16")throw new Error("zkey file is not groth16");const h=await hn(s.q),d=h.G1.F.n8*2,c=await fa(e,h,l),f=Tt.exports(64);f.update(c.csHash);let y=h.G1.g;for(let I=0;I<c.contributions.length;I++){const _=c.contributions[I],b=Xl(f);if(bn(b,h,_.delta.g1_s),bn(b,h,_.delta.g1_sx),!kn(b.digest(),_.transcript))return console.log(`INVALID(${I}): Inconsistent transcript `),!1;const $=ka(h,_.transcript);if(i=await Ia(h,_.delta.g1_s,_.delta.g1_sx,$,_.delta.g2_spx),i!==!0)return console.log(`INVALID(${I}): public key G1 and G2 do not have the same ration `),!1;if(i=await Ia(h,y,_.deltaAfter,$,_.delta.g2_spx),i!==!0)return console.log(`INVALID(${I}): deltaAfter does not fillow the public key `),!1;if(_.type==1){const j=await pe(_.beaconHash,_.numIterationsExp),M=h.Fr.fromRng(j),S=h.G1.toAffine(h.G1.fromRng(j)),z=h.G1.toAffine(h.G1.timesFr(S,M));if(h.G1.eq(S,_.delta.g1_s)!==!0)return console.log(`INVALID(${I}): Key of the beacon does not match. g1_s `),!1;if(h.G1.eq(z,_.delta.g1_sx)!==!0)return console.log(`INVALID(${I}): Key of the beacon does not match. g1_sx `),!1}$n(f,h,_);const K=Tt.exports(64);$n(K,h,_),_.contributionHash=K.digest(),y=_.deltaAfter}const{fd:L,sections:v}=await Kt(o,"zkey",2),T=await yn(L,v,!1);if(T.protocol!="groth16")throw new Error("zkeyinit file is not groth16");if(!Ft.eq(T.q,s.q)||!Ft.eq(T.r,s.r)||T.n8q!=s.n8q||T.n8r!=s.n8r)return a&&a.error("INVALID:  Different curves"),!1;if(T.nVars!=s.nVars||T.nPublic!=s.nPublic||T.domainSize!=s.domainSize)return a&&a.error("INVALID:  Different circuit parameters"),!1;if(!h.G1.eq(s.vk_alpha_1,T.vk_alpha_1))return a&&a.error("INVALID:  Invalid alpha1"),!1;if(!h.G1.eq(s.vk_beta_1,T.vk_beta_1))return a&&a.error("INVALID:  Invalid beta1"),!1;if(!h.G2.eq(s.vk_beta_2,T.vk_beta_2))return a&&a.error("INVALID:  Invalid beta2"),!1;if(!h.G2.eq(s.vk_gamma_2,T.vk_gamma_2))return a&&a.error("INVALID:  Invalid gamma2"),!1;if(!h.G1.eq(s.vk_delta_1,y))return a&&a.error("INVALID:  Invalid delta1"),!1;if(i=await Ia(h,h.G1.g,y,h.G2.g,s.vk_delta_2),i!==!0)return a&&a.error("INVALID:  Invalid delta2"),!1;const B=await fa(L,h,v);if(!kn(c.csHash,B.csHash))return a&&a.error("INVALID:  Circuit does not match"),!1;if(l[8][0].size!=d*(s.nVars-s.nPublic-1))return a&&a.error("INVALID:  Invalid L section size"),!1;if(l[9][0].size!=d*s.domainSize)return a&&a.error("INVALID:  Invalid H section size"),!1;let E;if(E=await Ca(e,l,L,v,3),!E)return a&&a.error("INVALID:  IC section is not identical"),!1;if(E=await Ca(e,l,L,v,4),!E)return a&&a.error("Coeffs section is not identical"),!1;if(E=await Ca(e,l,L,v,5),!E)return a&&a.error("A section is not identical"),!1;if(E=await Ca(e,l,L,v,6),!E)return a&&a.error("B1 section is not identical"),!1;if(E=await Ca(e,l,L,v,7),!E)return a&&a.error("B2 section is not identical"),!1;if(i=await A("G1",L,v,e,l,8,s.vk_delta_2,T.vk_delta_2,"L section"),i!==!0)return a&&a.error("L section does not match"),!1;if(i=await G(),i!==!0)return a&&a.error("H section does not match"),!1;a&&a.info(nn(c.csHash,"Circuit Hash: ")),await e.close(),await L.close();for(let I=c.contributions.length-1;I>=0;I--){const _=c.contributions[I];a&&a.info("-------------------------"),a&&a.info(nn(_.contributionHash,`contribution #${I+1} ${_.name?_.name:""}:`)),_.type==1&&(a&&a.info(`Beacon generator: ${gs(_.beaconHash)}`),a&&a.info(`Beacon iterations Exp: ${_.numIterationsExp}`))}return a&&a.info("-------------------------"),a&&a.info("ZKey Ok!"),!0;async function A(I,_,b,$,K,j,M,S,z){const Z=h[I],Y=Z.F.n8*2;await Zt(_,b,j),await Zt($,K,j);let V=Z.zero,nt=Z.zero;const Q=b[j][0].size/Y;for(let it=0;it<Q;it+=1048576){a&&a.debug(`Same ratio check ${z}:  ${it}/${Q}`);const X=Math.min(Q-it,1048576),k=await _.read(X*Y),J=await $.read(X*Y),m=ca(4*X),r=await Z.multiExpAffine(k,m),C=await Z.multiExpAffine(J,m);V=Z.add(V,r),nt=Z.add(nt,C)}return await Wt(_),await Wt($),Q==0?!0:(i=await Ia(h,V,nt,M,S),i===!0)}async function G(){const _=h.G1,b=h.Fr,$=_.F.n8*2,{fd:K,sections:j}=await Kt(t,"ptau",1);let M=new ft(s.domainSize*s.n8r);const S=new Array(8);for(let nt=0;nt<8;nt++)S[nt]=Xa(ca(4),0);const z=new Jn(S);for(let nt=0;nt<s.domainSize-1;nt++){const Q=b.fromRng(z);b.toRprLE(M,nt*s.n8r,Q)}b.toRprLE(M,(s.domainSize-1)*s.n8r,b.zero);let q=_.zero;for(let nt=0;nt<s.domainSize;nt+=1048576){a&&a.debug(`H Verification(tau):  ${nt}/${s.domainSize}`);const Q=Math.min(s.domainSize-nt,1048576),it=await K.read($*Q,j[2][0].p+s.domainSize*$+nt*$),X=await K.read($*Q,j[2][0].p+nt*$),k=await P(it,X),J=M.slice(nt*s.n8r,(nt+Q)*s.n8r),m=await _.multiExpAffine(k,J);q=_.add(q,m)}M=await b.batchToMontgomery(M);let Z;if(s.power<b.s)Z=b.neg(b.e(2));else{const nt=2**b.s,Q=b.exp(b.shift,nt);Z=b.sub(Q,b.one)}const Y=s.power<b.s?b.w[s.power+1]:b.shift;M=await b.batchApplyKey(M,Z,Y),M=await b.fft(M),M=await b.batchFromMontgomery(M),await Zt(e,l,9);let V=_.zero;for(let nt=0;nt<s.domainSize;nt+=1048576){a&&a.debug(`H Verification(lagrange):  ${nt}/${s.domainSize}`);const Q=Math.min(s.domainSize-nt,1048576),it=await e.read($*Q),X=M.slice(nt*s.n8r,(nt+Q)*s.n8r),k=await _.multiExpAffine(it,X);V=_.add(V,k)}return await Wt(e),i=await Ia(h,q,V,s.vk_delta_2,T.vk_delta_2),i===!0}async function P(I,_){const b=h.G1.F.n8*2,$=I.byteLength/b,K=h.tm.concurrency,j=Math.floor($/K),M=[];for(let Z=0;Z<K;Z++){let Y;if(Z<K-1?Y=j:Y=$-Z*j,Y==0)continue;const V=I.slice(Z*j*d,(Z*j+Y)*d),nt=_.slice(Z*j*d,(Z*j+Y)*d);M.push(U(V,nt))}const S=await Promise.all(M),z=new Uint8Array($*b);let q=0;for(let Z=0;Z<S.length;Z++)z.set(S[Z][0],q),q+=S[Z][0].byteLength;return z}async function U(I,_){const b=h.G1.F.n8*2,$=h.G1.F.n8*3,K=I.byteLength/b,j=[];j.push({cmd:"ALLOCSET",var:0,buff:I}),j.push({cmd:"ALLOCSET",var:1,buff:_}),j.push({cmd:"ALLOC",var:2,len:K*$});for(let S=0;S<K;S++)j.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:S*b},{var:1,offset:S*b},{var:2,offset:S*$}]});return j.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:K},{var:2}]}),j.push({cmd:"GET",out:0,var:2,len:K*b}),await h.tm.queueAction(j)}}async function ld(o,t,n,a){const i={type:"bigMem"};return await Fs(o,t,i,a),await Bs(i,t,n,a)}async function rd(o,t,n,a,i){await Tt.exports.ready();const{fd:e,sections:l}=await Kt(o,"zkey",2),s=await yn(e,l);if(s.protocol!="groth16")throw new Error("zkey file is not groth16");const h=await hn(s.q),d=await fa(e,h,l),c=await fn(t,"zkey",1,10),f=await ci(a),y=Tt.exports(64);y.update(d.csHash);for(let E=0;E<d.contributions.length;E++)$n(y,h,d.contributions[E]);const L={};L.delta={},L.delta.prvKey=h.Fr.fromRng(f),L.delta.g1_s=h.G1.toAffine(h.G1.fromRng(f)),L.delta.g1_sx=h.G1.toAffine(h.G1.timesFr(L.delta.g1_s,L.delta.prvKey)),bn(y,h,L.delta.g1_s),bn(y,h,L.delta.g1_sx),L.transcript=y.digest(),L.delta.g2_sp=ka(h,L.transcript),L.delta.g2_spx=h.G2.toAffine(h.G2.timesFr(L.delta.g2_sp,L.delta.prvKey)),s.vk_delta_1=h.G1.timesFr(s.vk_delta_1,L.delta.prvKey),s.vk_delta_2=h.G2.timesFr(s.vk_delta_2,L.delta.prvKey),L.deltaAfter=s.vk_delta_1,L.type=0,n&&(L.name=n),d.contributions.push(L),await we(c,s),await Nt(e,l,c,3),await Nt(e,l,c,4),await Nt(e,l,c,5),await Nt(e,l,c,6),await Nt(e,l,c,7);const v=h.Fr.inv(L.delta.prvKey);await ai(e,l,c,8,h,"G1",v,h.Fr.e(1),"L Section",i),await ai(e,l,c,9,h,"G1",v,h.Fr.e(1),"H Section",i),await Le(c,h,d),await e.close(),await c.close();const T=Tt.exports(64);$n(T,h,L);const B=T.digest();return i&&i.info(nn(d.csHash,"Circuit Hash: ")),i&&i.info(nn(B,"Contribution Hash: ")),B}async function dd(o,t,n,a,i,e){await Tt.exports.ready();const l=_s(a);if(l.byteLength==0||l.byteLength*2!=a.length)return e&&e.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(l.length>=256)return e&&e.error("Maximum length of beacon hash is 255 bytes"),!1;if(i=parseInt(i),i<10||i>63)return e&&e.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;const{fd:s,sections:h}=await Kt(o,"zkey",2),d=await yn(s,h);if(d.protocol!="groth16")throw new Error("zkey file is not groth16");const c=await hn(d.q),f=await fa(s,c,h),y=await fn(t,"zkey",1,10),L=await pe(l,i),v=Tt.exports(64);v.update(f.csHash);for(let G=0;G<f.contributions.length;G++)$n(v,c,f.contributions[G]);const T={};T.delta={},T.delta.prvKey=c.Fr.fromRng(L),T.delta.g1_s=c.G1.toAffine(c.G1.fromRng(L)),T.delta.g1_sx=c.G1.toAffine(c.G1.timesFr(T.delta.g1_s,T.delta.prvKey)),bn(v,c,T.delta.g1_s),bn(v,c,T.delta.g1_sx),T.transcript=v.digest(),T.delta.g2_sp=ka(c,T.transcript),T.delta.g2_spx=c.G2.toAffine(c.G2.timesFr(T.delta.g2_sp,T.delta.prvKey)),d.vk_delta_1=c.G1.timesFr(d.vk_delta_1,T.delta.prvKey),d.vk_delta_2=c.G2.timesFr(d.vk_delta_2,T.delta.prvKey),T.deltaAfter=d.vk_delta_1,T.type=1,T.numIterationsExp=i,T.beaconHash=l,n&&(T.name=n),f.contributions.push(T),await we(y,d),await Nt(s,h,y,3),await Nt(s,h,y,4),await Nt(s,h,y,5),await Nt(s,h,y,6),await Nt(s,h,y,7);const B=c.Fr.inv(T.delta.prvKey);await ai(s,h,y,8,c,"G1",B,c.Fr.e(1),"L Section",e),await ai(s,h,y,9,c,"G1",B,c.Fr.e(1),"H Section",e),await Le(y,c,f),await s.close(),await y.close();const E=Tt.exports(64);$n(E,c,T);const A=E.digest();return e&&e.info(nn(A,"Contribution Hash: ")),A}async function ud(o){const t=await lr(o,!0);return delete t.curve,delete t.F,cn.stringifyBigInts(t)}async function fd(o,t,n,a,i){await Tt.exports.ready();const e=await ci(a),l=o.Fr.fromRng(e),s=o.Fr.inv(l),h=o.G1.F.n8*2,d=o.G2.F.n8*2,c=await Dn(t),f=await _a(n);await M(h),await M(h),await M(d),await M(d);const y=await S(),L=o.G1.timesFr(y,l);await q(L);const v=await z(),T=o.G2.timesFr(v,l);await Z(T);const B=await c.readUBE32();await f.writeUBE32(B),await M(B*h);const E=await c.readUBE32();await f.writeUBE32(E),await Zn(c,f,null,o,"G1",E,s,o.Fr.e(1),"UNCOMPRESSED","H",i);const A=await c.readUBE32();await f.writeUBE32(A),await Zn(c,f,null,o,"G1",A,s,o.Fr.e(1),"UNCOMPRESSED","L",i);const G=await c.readUBE32();await f.writeUBE32(G),await M(G*h);const P=await c.readUBE32();await f.writeUBE32(P),await M(P*h);const U=await c.readUBE32();await f.writeUBE32(U),await M(U*d);const I=Tt.exports(64),_={};_.csHash=await c.read(64),I.update(_.csHash);const b=await c.readUBE32();_.contributions=[];for(let Y=0;Y<b;Y++){const V={delta:{}};V.deltaAfter=await S(),V.delta.g1_s=await S(),V.delta.g1_sx=await S(),V.delta.g2_spx=await z(),V.transcript=await c.read(64),_.contributions.push(V),$n(I,o,V)}const $={};$.delta={},$.delta.prvKey=l,$.delta.g1_s=o.G1.toAffine(o.G1.fromRng(e)),$.delta.g1_sx=o.G1.toAffine(o.G1.timesFr($.delta.g1_s,l)),bn(I,o,$.delta.g1_s),bn(I,o,$.delta.g1_sx),$.transcript=I.digest(),$.delta.g2_sp=ka(o,$.transcript),$.delta.g2_spx=o.G2.toAffine(o.G2.timesFr($.delta.g2_sp,l)),$.deltaAfter=L,$.type=0,_.contributions.push($),await f.write(_.csHash),await f.writeUBE32(_.contributions.length);for(let Y=0;Y<_.contributions.length;Y++){const V=_.contributions[Y];await q(V.deltaAfter),await q(V.delta.g1_s),await q(V.delta.g1_sx),await Z(V.delta.g2_spx),await f.write(V.transcript)}const K=Tt.exports(64);$n(K,o,$);const j=K.digest();return i&&i.info(nn(j,"Contribution Hash: ")),await f.close(),await c.close(),j;async function M(Y){const V=c.pageSize*2;for(let nt=0;nt<Y;nt+=V){const Q=Math.min(Y-nt,V),it=await c.read(Q);await f.write(it)}}async function S(){const Y=await c.read(o.G1.F.n8*2);return o.G1.fromRprUncompressed(Y,0)}async function z(){const Y=await c.read(o.G2.F.n8*2);return o.G2.fromRprUncompressed(Y,0)}async function q(Y){const V=new Uint8Array(h);o.G1.toRprUncompressed(V,0,Y),await f.write(V)}async function Z(Y){const V=new Uint8Array(d);o.G2.toRprUncompressed(V,0,Y),await f.write(V)}}const{stringifyBigInts:ye}=cn;async function Ss(o,t){t&&t.info("EXPORT VERIFICATION KEY STARTED");const{fd:n,sections:a}=await Kt(o,"zkey",2),i=await yn(n,a);t&&t.info("> Detected protocol: "+i.protocol);let e;if(i.protocol==="groth16")e=await hd(i,n,a);else if(i.protocol==="plonk")e=await _d(i);else if(i.protocolId&&i.protocolId===Qa)e=await gd(i);else throw new Error("zkey file protocol unrecognized");return await n.close(),t&&t.info("EXPORT VERIFICATION KEY FINISHED"),e}async function hd(o,t,n){const a=await hn(o.q),i=a.G1.F.n8*2,e=await a.pairing(o.vk_alpha_1,o.vk_beta_2);let l={protocol:o.protocol,curve:a.name,nPublic:o.nPublic,vk_alpha_1:a.G1.toObject(o.vk_alpha_1),vk_beta_2:a.G2.toObject(o.vk_beta_2),vk_gamma_2:a.G2.toObject(o.vk_gamma_2),vk_delta_2:a.G2.toObject(o.vk_delta_2),vk_alphabeta_12:a.Gt.toObject(e)};await Zt(t,n,3),l.IC=[];for(let s=0;s<=o.nPublic;s++){const h=await t.read(i),d=a.G1.toObject(h);l.IC.push(d)}return await Wt(t),l=ye(l),l}async function _d(o){const t=await hn(o.q);let n={protocol:o.protocol,curve:t.name,nPublic:o.nPublic,power:o.power,k1:t.Fr.toObject(o.k1),k2:t.Fr.toObject(o.k2),Qm:t.G1.toObject(o.Qm),Ql:t.G1.toObject(o.Ql),Qr:t.G1.toObject(o.Qr),Qo:t.G1.toObject(o.Qo),Qc:t.G1.toObject(o.Qc),S1:t.G1.toObject(o.S1),S2:t.G1.toObject(o.S2),S3:t.G1.toObject(o.S3),X_2:t.G2.toObject(o.X_2),w:t.Fr.toObject(t.Fr.w[o.power])};return n=ye(n),n}async function gd(o,t){const n=await hn(o.q);let a={protocol:o.protocol,curve:n.name,nPublic:o.nPublic,power:o.power,k1:n.Fr.toObject(o.k1),k2:n.Fr.toObject(o.k2),w:n.Fr.toObject(n.Fr.w[o.power]),w3:n.Fr.toObject(o.w3),w4:n.Fr.toObject(o.w4),w8:n.Fr.toObject(o.w8),wr:n.Fr.toObject(o.wr),X_2:n.G2.toObject(o.X_2),C0:n.G1.toObject(o.C0)};return ye(a)}var xs={};const{unstringifyBigInts:pd,stringifyBigInts:wd}=cn;async function vs(o,t,n){n&&n.info("FFLONK EXPORT SOLIDITY VERIFIER STARTED");const a=await ta(o.curve);let i=d(o.w3);o.w3_2=c(a.Fr.square(i));let e=d(o.w4);o.w4_2=c(a.Fr.square(e)),o.w4_3=c(a.Fr.mul(a.Fr.square(e),e));let l=d(o.w8),s=a.Fr.one;for(let f=1;f<8;f++)s=a.Fr.mul(s,l),o["w8_"+f]=c(s);let h=t[o.protocol];return n&&n.info("FFLONK EXPORT SOLIDITY VERIFIER FINISHED"),xs.render(h,o);function d(f){const y=pd(f);return a.Fr.fromObject(y)}function c(f){const y=a.Fr.toObject(f);return wd(y)}}async function Ld(o,t,n){const a=await Ss(o,n);if(a.protocol==="fflonk")return vs(a,t,n);let i=t[a.protocol];return xs.render(i,a)}var Lu=Object.freeze({__proto__:null,newZKey:Fs,exportBellman:sd,importBellman:cd,verifyFromR1cs:ld,verifyFromInit:Bs,contribute:rd,beacon:dd,exportJson:ud,bellmanContribute:fd,exportVerificationKey:Ss,exportSolidityVerifier:Ld});async function md(o,t,n,a){globalThis.gc&&globalThis.gc(),await Tt.exports.ready();const{fd:i,sections:e}=await Kt(t,"ptau",1),{curve:l,power:s}=await mn(i,e),{fd:h,sections:d}=await Kt(o,"r1cs",1),c=await ri(h,d,{loadConstraints:!0,loadCustomGates:!0}),f=l.G1.F.n8*2,y=l.G1,L=l.G2.F.n8*2,v=l.Fr,T=l.Fr.n8;a&&a.info("Reading r1cs"),await Vt(h,d,2);const B=new wn,E=new wn;let A=c.nVars;const G=c.nOutputs+c.nPubInputs;await S(l.Fr,c,a),globalThis.gc&&globalThis.gc();const P=await fn(n,"zkey",1,14,1<<22,1<<24);if(c.prime!=l.r)return a&&a.error("r1cs curve does not match powers of tau ceremony curve"),-1;let U=Vn(B.length-1)+1;U<3&&(U=3);const I=2**U;if(a&&a.info("Plonk constraints: "+B.length),U>s)return a&&a.error(`circuit too big for this power of tau ceremony. ${B.length} > 2**${s}`),-1;if(!e[12])return a&&a.error("Powers of tau is not prepared."),-1;const _=new ft(I*f),b=e[12][0].p+(2**U-1)*f;await i.readToBuffer(_,0,I*f,b);const[$,K]=it(),j={};await Y(3,"Additions"),globalThis.gc&&globalThis.gc(),await z(4,0,"Amap"),globalThis.gc&&globalThis.gc(),await z(5,1,"Bmap"),globalThis.gc&&globalThis.gc(),await z(6,2,"Cmap"),globalThis.gc&&globalThis.gc(),await q(7,3,"Qm"),globalThis.gc&&globalThis.gc(),await q(8,4,"Ql"),globalThis.gc&&globalThis.gc(),await q(9,5,"Qr"),globalThis.gc&&globalThis.gc(),await q(10,6,"Qo"),globalThis.gc&&globalThis.gc(),await q(11,7,"Qc"),globalThis.gc&&globalThis.gc(),await V(12,"sigma"),globalThis.gc&&globalThis.gc(),await nt(13,"lagrange polynomials"),globalThis.gc&&globalThis.gc(),await Rt(P,14);const M=new ft((I+6)*f);await i.readToBuffer(M,0,(I+6)*f,e[2][0].p),await P.write(M),await kt(P),globalThis.gc&&globalThis.gc(),await Q(),await P.close(),await h.close(),await i.close(),a&&a.info("Setup Finished");return;async function S(X,k,J){function m(O){const R=Object.keys(O);for(let N=0;N<R.length;N++)O[R[N]]==0n&&delete O[R[N]]}function r(O,R,N){const H={};for(let lt in O)typeof H[lt]>"u"?H[lt]=X.mul(R,O[lt]):H[lt]=X.add(H[lt],X.mul(R,O[lt]));for(let lt in N)typeof H[lt]>"u"?H[lt]=N[lt]:H[lt]=X.add(H[lt],N[lt]);return m(H),H}function C(O,R){const N={k:X.zero,s:[],coefs:[]},H=[];for(let lt in O)lt==0?N.k=X.add(N.k,O[lt]):O[lt]!=0n&&H.push([Number(lt),O[lt]]);for(;H.length>R;){const lt=H.shift(),ht=H.shift(),pt=lt[0],ut=ht[0],st=A++,ct=X.zero,Lt=X.neg(lt[1]),At=X.neg(ht[1]),Bt=X.one,Mt=X.zero;B.push([pt,ut,st,ct,Lt,At,Bt,Mt]),E.push([pt,ut,lt[1],ht[1]]),H.push([st,X.one])}for(let lt=0;lt<H.length;lt++)N.s[lt]=H[lt][0],N.coefs[lt]=H[lt][1];for(;N.coefs.length<R;)N.s.push(0),N.coefs.push(X.zero);return N}function u(O){const R=C(O,3),N=R.s[0],H=R.s[1],lt=R.s[2],ht=X.zero,pt=R.coefs[0],ut=R.coefs[1],st=R.coefs[2],ct=R.k;B.push([N,H,lt,ht,pt,ut,st,ct])}function x(O,R,N){const H=C(O,1),lt=C(R,1),ht=C(N,1),pt=H.s[0],ut=lt.s[0],st=ht.s[0],ct=X.mul(H.coefs[0],lt.coefs[0]),Lt=X.mul(H.coefs[0],lt.k),At=X.mul(H.k,lt.coefs[0]),Bt=X.neg(ht.coefs[0]),Mt=X.sub(X.mul(H.k,lt.k),ht.k);B.push([pt,ut,st,ct,Lt,At,Bt,Mt])}function F(O){let R=X.zero,N=0;const H=Object.keys(O);for(let lt=0;lt<H.length;lt++)O[H[lt]]==0n?delete O[H[lt]]:H[lt]==0?R=X.add(R,O[H[lt]]):N++;return N>0?N.toString():R!=X.zero?"k":"0"}function p(O,R,N){const H=F(O),lt=F(R);if(H==="0"||lt==="0")m(N),u(N);else if(H==="k"){const ht=r(R,O[0],N);u(ht)}else if(lt==="k"){const ht=r(O,R[0],N);u(ht)}else x(O,R,N)}for(let O=1;O<=G;O++){const R=O,N=0,H=0,lt=X.zero,ht=X.one,pt=X.zero,ut=X.zero,st=X.zero;B.push([R,N,H,lt,ht,pt,ut,st])}for(let O=0;O<k.constraints.length;O++)J&&O%1e4===0&&J.debug(`processing constraints: ${O}/${k.nConstraints}`),p(...k.constraints[O])}async function z(X,k,J){await Rt(P,X);for(let m=0;m<B.length;m++)await P.writeULE32(B[m][k]),a&&m%1e6==0&&a.debug(`writing ${J}: ${m}/${B.length}`);await kt(P)}async function q(X,k,J){let m=new ft(I*T);for(let r=0;r<B.length;r++)m.set(B[r][k],r*T),a&&r%1e6==0&&a.debug(`writing ${J}: ${r}/${B.length}`);await Rt(P,X),await Z(m),await kt(P),m=await v.batchFromMontgomery(m),j[J]=await l.G1.multiExpAffine(_,m,a,"multiexp "+J)}async function Z(X){const k=await v.ifft(X),J=new ft(I*T*4);J.set(k,0);const m=await v.fft(J);await P.write(k),await P.write(m)}async function Y(X,k){await Rt(P,X);const J=new Uint8Array(8+2*T),m=new DataView(J.buffer);for(let r=0;r<E.length;r++){const C=E[r];let u=0;m.setUint32(u,C[0],!0),u+=4,m.setUint32(u,C[1],!0),u+=4,J.set(C[2],u),u+=T,J.set(C[3],u),u+=T,await P.write(J),a&&r%1e6==0&&a.debug(`writing ${k}: ${r}/${E.length}`)}await kt(P)}async function V(X,k){const J=new ft(T*I*3),m=new wn(A),r=new wn(A);let C=v.one;for(let O=0;O<I;O++)O<B.length?(p(B[O][0],O),p(B[O][1],I+O),p(B[O][2],I*2+O)):(p(0,O),p(0,I+O),p(0,I*2+O)),C=v.mul(C,v.w[U]),a&&O%1e6==0&&a.debug(`writing ${k} phase1: ${O}/${B.length}`);for(let O=0;O<A;O++)typeof r[O]<"u"?J.set(m[O],r[O]*T):console.log("Variable not used"),a&&O%1e6==0&&a.debug(`writing ${k} phase2: ${O}/${A}`);globalThis.gc&&globalThis.gc(),await Rt(P,X);let u=J.slice(0,I*T);await Z(u),globalThis.gc&&globalThis.gc();let x=J.slice(I*T,I*T*2);await Z(x),globalThis.gc&&globalThis.gc();let F=J.slice(I*T*2,I*T*3);await Z(F),globalThis.gc&&globalThis.gc(),await kt(P),u=await v.batchFromMontgomery(u),x=await v.batchFromMontgomery(x),F=await v.batchFromMontgomery(F),j.S1=await l.G1.multiExpAffine(_,u,a,"multiexp S1"),globalThis.gc&&globalThis.gc(),j.S2=await l.G1.multiExpAffine(_,x,a,"multiexp S2"),globalThis.gc&&globalThis.gc(),j.S3=await l.G1.multiExpAffine(_,F,a,"multiexp S3"),globalThis.gc&&globalThis.gc();function p(O,R){typeof m[O]>"u"?r[O]=R:J.set(m[O],R*T);let N;R<I?N=C:R<2*I?N=v.mul(C,$):N=v.mul(C,K),m[O]=N}}async function nt(X,k){await Rt(P,X);const J=Math.max(G,1);for(let m=0;m<J;m++){let r=new ft(I*T);r.set(v.one,m*T),await Z(r),a&&a.debug(`writing ${k} ${m}/${J}`)}await kt(P)}async function Q(){await Rt(P,1),await P.writeULE32(2),await kt(P),await Rt(P,2);const X=l.q,k=(Math.floor((Ft.bitLength(X)-1)/64)+1)*8,J=l.r,m=(Math.floor((Ft.bitLength(J)-1)/64)+1)*8;await P.writeULE32(k),await An(P,X,k),await P.writeULE32(m),await An(P,J,m),await P.writeULE32(A),await P.writeULE32(G),await P.writeULE32(I),await P.writeULE32(E.length),await P.writeULE32(B.length),await P.write($),await P.write(K),await P.write(y.toAffine(j.Qm)),await P.write(y.toAffine(j.Ql)),await P.write(y.toAffine(j.Qr)),await P.write(y.toAffine(j.Qo)),await P.write(y.toAffine(j.Qc)),await P.write(y.toAffine(j.S1)),await P.write(y.toAffine(j.S2)),await P.write(y.toAffine(j.S3));let r;r=await i.read(L,e[3][0].p+L),await P.write(r),await kt(P)}function it(){let X=v.two;for(;J(X,[],U);)v.add(X,v.one);let k=v.add(X,v.one);for(;J(k,[X],U);)v.add(k,v.one);return[X,k];function J(m,r,C){const u=2**C;let x=v.one;for(let F=0;F<u;F++){if(v.eq(m,x))return!0;for(let p=0;p<r.length;p++)if(v.eq(m,v.mul(r[p],x)))return!0;x=v.mul(x,v.w[C])}return!1}}}class Ce{constructor(t,n){this.curve=t,this.logger=n,this.resetProof()}resetProof(){this.polynomials={},this.evaluations={}}addPolynomial(t,n){t in this.polynomials&&this.logger.warn(`proof: polynomial.${t} already exist in proof`),this.polynomials[t]=n}getPolynomial(t){return t in this.polynomials||this.logger.warn(`proof: polynomial ${t} does not exist in proof`),this.polynomials[t]}addEvaluation(t,n){t in this.evaluations&&this.logger.warn(`proof: evaluations.${t} already exist in proof`),this.evaluations[t]=n}getEvaluation(t){return t in this.evaluations||this.logger.warn(`proof: evaluation ${t} does not exist in proof`),this.evaluations[t]}toObjectProof(t=!0){let n=t?{polynomials:{},evaluations:{}}:{};return Object.keys(this.polynomials).forEach(a=>{const i=this.curve.G1.toObject(this.polynomials[a]);t?n.polynomials[a]=i:n[a]=i}),Object.keys(this.evaluations).forEach(a=>{const i=this.curve.Fr.toObject(this.evaluations[a]);t?n.evaluations[a]=i:n[a]=i}),n}fromObjectProof(t){this.resetProof(),Object.keys(t.polynomials).forEach(n=>{this.polynomials[n]=this.curve.G1.fromObject(t.polynomials[n])}),Object.keys(t.evaluations).forEach(n=>{this.evaluations[n]=this.curve.Fr.fromObject(t.evaluations[n])})}}var Gs={exports:{}};(function(o){(function(){var t="input is invalid type",n="finalize already called",a=typeof window=="object",i=a?window:{};i.JS_SHA3_NO_WINDOW&&(a=!1);var e=!a&&typeof self=="object",l=!i.JS_SHA3_NO_NODE_JS&&typeof di=="object"&&di.versions&&di.versions.node;l?i=Ol:e&&(i=self);var s=!i.JS_SHA3_NO_COMMON_JS&&!0&&o.exports,h=!i.JS_SHA3_NO_ARRAY_BUFFER&&typeof ArrayBuffer<"u",d="0123456789abcdef".split(""),c=[31,7936,2031616,520093696],f=[4,1024,262144,67108864],y=[1,256,65536,16777216],L=[6,1536,393216,100663296],v=[0,8,16,24],T=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648],B=[224,256,384,512],E=[128,256],A=["hex","buffer","arrayBuffer","array","digest"],G={128:168,256:136};(i.JS_SHA3_NO_NODE_JS||!Array.isArray)&&(Array.isArray=function(m){return Object.prototype.toString.call(m)==="[object Array]"}),h&&(i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW||!ArrayBuffer.isView)&&(ArrayBuffer.isView=function(m){return typeof m=="object"&&m.buffer&&m.buffer.constructor===ArrayBuffer});for(var P=function(m,r,C){return function(u){return new X(m,r,m).update(u)[C]()}},U=function(m,r,C){return function(u,x){return new X(m,r,x).update(u)[C]()}},I=function(m,r,C){return function(u,x,F,p){return z["cshake"+m].update(u,x,F,p)[C]()}},_=function(m,r,C){return function(u,x,F,p){return z["kmac"+m].update(u,x,F,p)[C]()}},b=function(m,r,C,u){for(var x=0;x<A.length;++x){var F=A[x];m[F]=r(C,u,F)}return m},$=function(m,r){var C=P(m,r,"hex");return C.create=function(){return new X(m,r,m)},C.update=function(u){return C.create().update(u)},b(C,P,m,r)},K=function(m,r){var C=U(m,r,"hex");return C.create=function(u){return new X(m,r,u)},C.update=function(u,x){return C.create(x).update(u)},b(C,U,m,r)},j=function(m,r){var C=G[m],u=I(m,r,"hex");return u.create=function(x,F,p){return!F&&!p?z["shake"+m].create(x):new X(m,r,x).bytepad([F,p],C)},u.update=function(x,F,p,O){return u.create(F,p,O).update(x)},b(u,I,m,r)},M=function(m,r){var C=G[m],u=_(m,r,"hex");return u.create=function(x,F,p){return new k(m,r,F).bytepad(["KMAC",p],C).bytepad([x],C)},u.update=function(x,F,p,O){return u.create(x,p,O).update(F)},b(u,_,m,r)},S=[{name:"keccak",padding:y,bits:B,createMethod:$},{name:"sha3",padding:L,bits:B,createMethod:$},{name:"shake",padding:c,bits:E,createMethod:K},{name:"cshake",padding:f,bits:E,createMethod:j},{name:"kmac",padding:f,bits:E,createMethod:M}],z={},q=[],Z=0;Z<S.length;++Z)for(var Y=S[Z],V=Y.bits,nt=0;nt<V.length;++nt){var Q=Y.name+"_"+V[nt];if(q.push(Q),z[Q]=Y.createMethod(V[nt],Y.padding),Y.name!=="sha3"){var it=Y.name+V[nt];q.push(it),z[it]=z[Q]}}function X(m,r,C){this.blocks=[],this.s=[],this.padding=r,this.outputBits=C,this.reset=!0,this.finalized=!1,this.block=0,this.start=0,this.blockCount=1600-(m<<1)>>5,this.byteCount=this.blockCount<<2,this.outputBlocks=C>>5,this.extraBytes=(C&31)>>3;for(var u=0;u<50;++u)this.s[u]=0}X.prototype.update=function(m){if(this.finalized)throw new Error(n);var r,C=typeof m;if(C!=="string"){if(C==="object"){if(m===null)throw new Error(t);if(h&&m.constructor===ArrayBuffer)m=new Uint8Array(m);else if(!Array.isArray(m)&&(!h||!ArrayBuffer.isView(m)))throw new Error(t)}else throw new Error(t);r=!0}for(var u=this.blocks,x=this.byteCount,F=m.length,p=this.blockCount,O=0,R=this.s,N,H;O<F;){if(this.reset)for(this.reset=!1,u[0]=this.block,N=1;N<p+1;++N)u[N]=0;if(r)for(N=this.start;O<F&&N<x;++O)u[N>>2]|=m[O]<<v[N++&3];else for(N=this.start;O<F&&N<x;++O)H=m.charCodeAt(O),H<128?u[N>>2]|=H<<v[N++&3]:H<2048?(u[N>>2]|=(192|H>>6)<<v[N++&3],u[N>>2]|=(128|H&63)<<v[N++&3]):H<55296||H>=57344?(u[N>>2]|=(224|H>>12)<<v[N++&3],u[N>>2]|=(128|H>>6&63)<<v[N++&3],u[N>>2]|=(128|H&63)<<v[N++&3]):(H=65536+((H&1023)<<10|m.charCodeAt(++O)&1023),u[N>>2]|=(240|H>>18)<<v[N++&3],u[N>>2]|=(128|H>>12&63)<<v[N++&3],u[N>>2]|=(128|H>>6&63)<<v[N++&3],u[N>>2]|=(128|H&63)<<v[N++&3]);if(this.lastByteIndex=N,N>=x){for(this.start=N-x,this.block=u[p],N=0;N<p;++N)R[N]^=u[N];J(R),this.reset=!0}else this.start=N}return this},X.prototype.encode=function(m,r){var C=m&255,u=1,x=[C];for(m=m>>8,C=m&255;C>0;)x.unshift(C),m=m>>8,C=m&255,++u;return r?x.push(u):x.unshift(u),this.update(x),x.length},X.prototype.encodeString=function(m){var r,C=typeof m;if(C!=="string"){if(C==="object"){if(m===null)throw new Error(t);if(h&&m.constructor===ArrayBuffer)m=new Uint8Array(m);else if(!Array.isArray(m)&&(!h||!ArrayBuffer.isView(m)))throw new Error(t)}else throw new Error(t);r=!0}var u=0,x=m.length;if(r)u=x;else for(var F=0;F<m.length;++F){var p=m.charCodeAt(F);p<128?u+=1:p<2048?u+=2:p<55296||p>=57344?u+=3:(p=65536+((p&1023)<<10|m.charCodeAt(++F)&1023),u+=4)}return u+=this.encode(u*8),this.update(m),u},X.prototype.bytepad=function(m,r){for(var C=this.encode(r),u=0;u<m.length;++u)C+=this.encodeString(m[u]);var x=r-C%r,F=[];return F.length=x,this.update(F),this},X.prototype.finalize=function(){if(!this.finalized){this.finalized=!0;var m=this.blocks,r=this.lastByteIndex,C=this.blockCount,u=this.s;if(m[r>>2]|=this.padding[r&3],this.lastByteIndex===this.byteCount)for(m[0]=m[C],r=1;r<C+1;++r)m[r]=0;for(m[C-1]|=2147483648,r=0;r<C;++r)u[r]^=m[r];J(u)}},X.prototype.toString=X.prototype.hex=function(){this.finalize();for(var m=this.blockCount,r=this.s,C=this.outputBlocks,u=this.extraBytes,x=0,F=0,p="",O;F<C;){for(x=0;x<m&&F<C;++x,++F)O=r[x],p+=d[O>>4&15]+d[O&15]+d[O>>12&15]+d[O>>8&15]+d[O>>20&15]+d[O>>16&15]+d[O>>28&15]+d[O>>24&15];F%m===0&&(J(r),x=0)}return u&&(O=r[x],p+=d[O>>4&15]+d[O&15],u>1&&(p+=d[O>>12&15]+d[O>>8&15]),u>2&&(p+=d[O>>20&15]+d[O>>16&15])),p},X.prototype.arrayBuffer=function(){this.finalize();var m=this.blockCount,r=this.s,C=this.outputBlocks,u=this.extraBytes,x=0,F=0,p=this.outputBits>>3,O;u?O=new ArrayBuffer(C+1<<2):O=new ArrayBuffer(p);for(var R=new Uint32Array(O);F<C;){for(x=0;x<m&&F<C;++x,++F)R[F]=r[x];F%m===0&&J(r)}return u&&(R[x]=r[x],O=O.slice(0,p)),O},X.prototype.buffer=X.prototype.arrayBuffer,X.prototype.digest=X.prototype.array=function(){this.finalize();for(var m=this.blockCount,r=this.s,C=this.outputBlocks,u=this.extraBytes,x=0,F=0,p=[],O,R;F<C;){for(x=0;x<m&&F<C;++x,++F)O=F<<2,R=r[x],p[O]=R&255,p[O+1]=R>>8&255,p[O+2]=R>>16&255,p[O+3]=R>>24&255;F%m===0&&J(r)}return u&&(O=F<<2,R=r[x],p[O]=R&255,u>1&&(p[O+1]=R>>8&255),u>2&&(p[O+2]=R>>16&255)),p};function k(m,r,C){X.call(this,m,r,C)}k.prototype=new X,k.prototype.finalize=function(){return this.encode(this.outputBits,!0),X.prototype.finalize.call(this)};var J=function(m){var r,C,u,x,F,p,O,R,N,H,lt,ht,pt,ut,st,ct,Lt,At,Bt,Mt,$t,Dt,vt,bt,qt,Yt,Ht,ot,g,w,W,at,D,et,tt,rt,_t,gt,dt,wt,It,Ct,mt,St,xt,Qt,Gt,Pt,Et,jt,ln,gn,aa,Un,Mn,ia,zn,qn,ea,Sn,Cn,Hn,$a;for(u=0;u<48;u+=2)x=m[0]^m[10]^m[20]^m[30]^m[40],F=m[1]^m[11]^m[21]^m[31]^m[41],p=m[2]^m[12]^m[22]^m[32]^m[42],O=m[3]^m[13]^m[23]^m[33]^m[43],R=m[4]^m[14]^m[24]^m[34]^m[44],N=m[5]^m[15]^m[25]^m[35]^m[45],H=m[6]^m[16]^m[26]^m[36]^m[46],lt=m[7]^m[17]^m[27]^m[37]^m[47],ht=m[8]^m[18]^m[28]^m[38]^m[48],pt=m[9]^m[19]^m[29]^m[39]^m[49],r=ht^(p<<1|O>>>31),C=pt^(O<<1|p>>>31),m[0]^=r,m[1]^=C,m[10]^=r,m[11]^=C,m[20]^=r,m[21]^=C,m[30]^=r,m[31]^=C,m[40]^=r,m[41]^=C,r=x^(R<<1|N>>>31),C=F^(N<<1|R>>>31),m[2]^=r,m[3]^=C,m[12]^=r,m[13]^=C,m[22]^=r,m[23]^=C,m[32]^=r,m[33]^=C,m[42]^=r,m[43]^=C,r=p^(H<<1|lt>>>31),C=O^(lt<<1|H>>>31),m[4]^=r,m[5]^=C,m[14]^=r,m[15]^=C,m[24]^=r,m[25]^=C,m[34]^=r,m[35]^=C,m[44]^=r,m[45]^=C,r=R^(ht<<1|pt>>>31),C=N^(pt<<1|ht>>>31),m[6]^=r,m[7]^=C,m[16]^=r,m[17]^=C,m[26]^=r,m[27]^=C,m[36]^=r,m[37]^=C,m[46]^=r,m[47]^=C,r=H^(x<<1|F>>>31),C=lt^(F<<1|x>>>31),m[8]^=r,m[9]^=C,m[18]^=r,m[19]^=C,m[28]^=r,m[29]^=C,m[38]^=r,m[39]^=C,m[48]^=r,m[49]^=C,ut=m[0],st=m[1],Qt=m[11]<<4|m[10]>>>28,Gt=m[10]<<4|m[11]>>>28,ot=m[20]<<3|m[21]>>>29,g=m[21]<<3|m[20]>>>29,Sn=m[31]<<9|m[30]>>>23,Cn=m[30]<<9|m[31]>>>23,Ct=m[40]<<18|m[41]>>>14,mt=m[41]<<18|m[40]>>>14,et=m[2]<<1|m[3]>>>31,tt=m[3]<<1|m[2]>>>31,ct=m[13]<<12|m[12]>>>20,Lt=m[12]<<12|m[13]>>>20,Pt=m[22]<<10|m[23]>>>22,Et=m[23]<<10|m[22]>>>22,w=m[33]<<13|m[32]>>>19,W=m[32]<<13|m[33]>>>19,Hn=m[42]<<2|m[43]>>>30,$a=m[43]<<2|m[42]>>>30,Un=m[5]<<30|m[4]>>>2,Mn=m[4]<<30|m[5]>>>2,rt=m[14]<<6|m[15]>>>26,_t=m[15]<<6|m[14]>>>26,At=m[25]<<11|m[24]>>>21,Bt=m[24]<<11|m[25]>>>21,jt=m[34]<<15|m[35]>>>17,ln=m[35]<<15|m[34]>>>17,at=m[45]<<29|m[44]>>>3,D=m[44]<<29|m[45]>>>3,bt=m[6]<<28|m[7]>>>4,qt=m[7]<<28|m[6]>>>4,ia=m[17]<<23|m[16]>>>9,zn=m[16]<<23|m[17]>>>9,gt=m[26]<<25|m[27]>>>7,dt=m[27]<<25|m[26]>>>7,Mt=m[36]<<21|m[37]>>>11,$t=m[37]<<21|m[36]>>>11,gn=m[47]<<24|m[46]>>>8,aa=m[46]<<24|m[47]>>>8,St=m[8]<<27|m[9]>>>5,xt=m[9]<<27|m[8]>>>5,Yt=m[18]<<20|m[19]>>>12,Ht=m[19]<<20|m[18]>>>12,qn=m[29]<<7|m[28]>>>25,ea=m[28]<<7|m[29]>>>25,wt=m[38]<<8|m[39]>>>24,It=m[39]<<8|m[38]>>>24,Dt=m[48]<<14|m[49]>>>18,vt=m[49]<<14|m[48]>>>18,m[0]=ut^~ct&At,m[1]=st^~Lt&Bt,m[10]=bt^~Yt&ot,m[11]=qt^~Ht&g,m[20]=et^~rt&gt,m[21]=tt^~_t&dt,m[30]=St^~Qt&Pt,m[31]=xt^~Gt&Et,m[40]=Un^~ia&qn,m[41]=Mn^~zn&ea,m[2]=ct^~At&Mt,m[3]=Lt^~Bt&$t,m[12]=Yt^~ot&w,m[13]=Ht^~g&W,m[22]=rt^~gt&wt,m[23]=_t^~dt&It,m[32]=Qt^~Pt&jt,m[33]=Gt^~Et&ln,m[42]=ia^~qn&Sn,m[43]=zn^~ea&Cn,m[4]=At^~Mt&Dt,m[5]=Bt^~$t&vt,m[14]=ot^~w&at,m[15]=g^~W&D,m[24]=gt^~wt&Ct,m[25]=dt^~It&mt,m[34]=Pt^~jt&gn,m[35]=Et^~ln&aa,m[44]=qn^~Sn&Hn,m[45]=ea^~Cn&$a,m[6]=Mt^~Dt&ut,m[7]=$t^~vt&st,m[16]=w^~at&bt,m[17]=W^~D&qt,m[26]=wt^~Ct&et,m[27]=It^~mt&tt,m[36]=jt^~gn&St,m[37]=ln^~aa&xt,m[46]=Sn^~Hn&Un,m[47]=Cn^~$a&Mn,m[8]=Dt^~ut&ct,m[9]=vt^~st&Lt,m[18]=at^~bt&Yt,m[19]=D^~qt&Ht,m[28]=Ct^~et&rt,m[29]=mt^~tt&_t,m[38]=gn^~St&Qt,m[39]=aa^~xt&Gt,m[48]=Hn^~Un&ia,m[49]=$a^~Mn&zn,m[0]^=T[u],m[1]^=T[u+1]};if(s)o.exports=z;else for(Z=0;Z<q.length;++Z)i[q[Z]]=z[q[Z]]})()})(Gs);var bd=Gs.exports;const{keccak256:Ad}=bd,Ei=0,yd=1;class Yn{constructor(t){this.G1=t.G1,this.Fr=t.Fr,this.reset()}reset(){this.data=[]}addPolCommitment(t){this.data.push({type:Ei,data:t})}addScalar(t){this.data.push({type:yd,data:t})}getChallenge(){if(this.data.length===0)throw new Error("Keccak256Transcript: No data to generate a transcript");let t=0,n=0;this.data.forEach(l=>Ei===l.type?t++:n++);let a=new Uint8Array(n*this.Fr.n8+t*this.G1.F.n8*2),i=0;for(let l=0;l<this.data.length;l++)Ei===this.data[l].type?(this.G1.toRprUncompressed(a,i,this.data[l].data),i+=this.G1.F.n8*2):(this.Fr.toRprBE(a,i,this.data[l].data),i+=this.Fr.n8);const e=Ft.fromRprBE(new Uint8Array(Ad.arrayBuffer(a)));return this.Fr.e(e)}}class Fi{static getZ1(t){return[t.zero,t.add(t.e(-1),t.w[2]),t.e(-2),t.sub(t.e(-1),t.w[2])]}static getZ2(t){return[t.zero,t.add(t.zero,t.mul(t.e(-2),t.w[2])),t.e(4),t.sub(t.zero,t.mul(t.e(-2),t.w[2]))]}static getZ3(t){return[t.zero,t.add(t.e(2),t.mul(t.e(2),t.w[2])),t.e(-8),t.sub(t.e(2),t.mul(t.e(2),t.w[2]))]}static mul2(t,n,a,i,e,l){const s=this.getZ1(l);let h,d;const c=l.mul(t,n),f=l.mul(t,i),y=l.mul(a,n),L=l.mul(a,i);h=c;let v=l.add(f,y),T=L;return d=v,e&&(d=l.add(d,l.mul(s[e],T))),[h,d]}static mul3(t,n,a,i,e,l,s,h){const d=this.getZ1(h),c=this.getZ2(h);let f,y;const L=h.mul(t,n),v=h.mul(t,e),T=h.mul(i,n),B=h.mul(i,e);f=h.mul(L,a);let E=h.mul(T,a);E=h.add(E,h.mul(v,a)),E=h.add(E,h.mul(L,l));let A=h.mul(B,a);if(A=h.add(A,h.mul(v,l)),A=h.add(A,h.mul(T,l)),y=E,s){const G=h.mul(B,l);y=h.add(y,h.mul(d[s],A)),y=h.add(y,h.mul(c[s],G))}return[f,y]}static mul4(t,n,a,i,e,l,s,h,d,c){const f=this.getZ1(c),y=this.getZ2(c),L=this.getZ3(c);let v,T;const B=c.mul(t,n),E=c.mul(t,l),A=c.mul(e,n),G=c.mul(e,l),P=c.mul(a,i),U=c.mul(a,h),I=c.mul(s,i),_=c.mul(s,h);v=c.mul(B,P);let b=c.mul(A,P);b=c.add(b,c.mul(E,P)),b=c.add(b,c.mul(B,I)),b=c.add(b,c.mul(B,U));let $=c.mul(G,P);$=c.add($,c.mul(A,I)),$=c.add($,c.mul(A,U)),$=c.add($,c.mul(E,I)),$=c.add($,c.mul(E,U)),$=c.add($,c.mul(B,_));let K=c.mul(E,_);K=c.add(K,c.mul(A,_)),K=c.add(K,c.mul(G,U)),K=c.add(K,c.mul(G,I));let j=c.mul(G,_);return T=b,d&&(T=c.add(T,c.mul(f[d],$)),T=c.add(T,c.mul(y[d],K)),T=c.add(T,c.mul(L[d],j))),[v,T]}}const _o=3,Cd=4,Id=5,Ed=6,Bi=7,Si=8,xi=9,vi=10,Gi=11,Kn=12,Fd=13,go=14;class yt{constructor(t,n,a){this.coef=t,this.curve=n,this.Fr=n.Fr,this.G1=n.G1,this.logger=a}static async fromEvaluations(t,n,a){let i=await n.Fr.ifft(t);return new yt(i,n,a)}static fromCoefficientsArray(t,n,a){const i=n.Fr;let e=t.length>32768?new ft(t.length*i.n8):new Uint8Array(t.length*i.n8);for(let l=0;l<t.length;l++)e.set(t[l],l*i.n8);return new yt(e,n,a)}static fromPolynomial(t,n,a){let i=t.length(),e=n.Fr,l=i>32768?new ft(i*e.n8):new Uint8Array(i*e.n8);return l.set(t.coef.slice(),0),new yt(l,n,a)}isEqual(t){const n=this.degree();if(n!==t.degree())return!1;for(let a=0;a<n+1;a++)if(!this.Fr.eq(this.getCoef(a),t.getCoef(a)))return!1;return!0}blindCoefficients(t){t=t||[];const n=this.length()+t.length>32768?new ft((this.length()+t.length)*this.Fr.n8):new Uint8Array((this.length()+t.length)*this.Fr.n8);n.set(this.coef,0);for(let a=0;a<t.length;a++)n.set(this.Fr.add(n.slice((this.length()+a)*this.Fr.n8,(this.length()+a+1)*this.Fr.n8),t[a]),(this.length()+a)*this.Fr.n8),n.set(this.Fr.sub(n.slice(a*this.Fr.n8,(a+1)*this.Fr.n8),t[a]),a*this.Fr.n8);this.coef=n}getCoef(t){const n=t*this.Fr.n8;return n+this.Fr.n8>this.coef.byteLength?this.Fr.zero:this.coef.slice(n,n+this.Fr.n8)}setCoef(t,n){if(t>this.length()-1)throw new Error("Coef index is not available");this.coef.set(n,t*this.Fr.n8)}static async to4T(t,n,a,i){a=a||[];let e=await i.ifft(t);const l=n*4>32768?new ft(n*4*i.n8):new Uint8Array(n*4*i.n8);l.set(e,0);const s=await i.fft(l);if(a.length===0)return[e,s];const h=n+a.length>32768?new ft((n+a.length)*i.n8):new Uint8Array((n+a.length)*i.n8);h.set(e,0);for(let d=0;d<a.length;d++)h.set(i.add(h.slice((n+d)*i.n8,(n+d+1)*i.n8),a[d]),(n+d)*i.n8),h.set(i.sub(h.slice(d*i.n8,(d+1)*i.n8),a[d]),d*i.n8);return[h,s]}length(){let t=this.coef.byteLength/this.Fr.n8;if(t!==Math.floor(this.coef.byteLength/this.Fr.n8))throw new Error("Polynomial coefficients buffer has incorrect size");return t===0&&this.logger&&this.logger.warn("Polynomial has length zero"),t}degree(){for(let t=this.length()-1;t>0;t--){const n=t*this.Fr.n8;if(!this.Fr.eq(this.Fr.zero,this.coef.slice(n,n+this.Fr.n8)))return t}return 0}evaluate(t){let n=this.Fr.zero;for(let a=this.degree()+1;a>0;a--){let i=a*this.Fr.n8;const e=this.coef.slice(i-this.Fr.n8,i);n=this.Fr.add(e,this.Fr.mul(n,t))}return n}fastEvaluate(t){const n=this.Fr;let a=3,i=this.degree()+1,e=parseInt(i/a),l=i-e*a,s=[],h=[];h[0]=n.one;for(let d=0;d<a;d++){s[d]=n.zero;let c=d===a-1?e+l:e;for(let f=c;f>0;f--)s[d]=n.add(this.getCoef(d*e+f-1),n.mul(s[d],t)),d===0&&(h[0]=n.mul(h[0],t))}for(let d=1;d<a;d++)s[0]=n.add(s[0],n.mul(h[d-1],s[d])),h[d]=n.mul(h[d-1],h[0]);return s[0]}add(t,n){let a=!1;t.length()>this.length()&&(a=!0);const i=this.length(),e=t.length();for(let l=0;l<Math.max(i,e);l++){const s=l*this.Fr.n8,h=l<i?this.coef.slice(s,s+this.Fr.n8):this.Fr.zero;let d=l<e?t.coef.slice(s,s+this.Fr.n8):this.Fr.zero;n!==void 0&&(d=this.Fr.mul(d,n)),a?t.coef.set(this.Fr.add(h,d),s):this.coef.set(this.Fr.add(h,d),s)}a&&(delete this.coef,this.coef=t.coef)}sub(t,n){let a=!1;t.length()>this.length()&&(a=!0);const i=this.length(),e=t.length();for(let l=0;l<Math.max(i,e);l++){const s=l*this.Fr.n8,h=l<i?this.coef.slice(s,s+this.Fr.n8):this.Fr.zero;let d=l<e?t.coef.slice(s,s+this.Fr.n8):this.Fr.zero;n!==void 0&&(d=this.Fr.mul(d,n)),a?t.coef.set(this.Fr.sub(h,d),s):this.coef.set(this.Fr.sub(h,d),s)}a&&(delete this.coef,this.coef=t.coef)}mulScalar(t){for(let n=0;n<this.length();n++){const a=n*this.Fr.n8;this.coef.set(this.Fr.mul(this.coef.slice(a,a+this.Fr.n8),t),a)}}addScalar(t){const n=this.length()===0?this.Fr.zero:this.coef.slice(0,this.Fr.n8);this.coef.set(this.Fr.add(n,t),0)}subScalar(t){const n=this.length()===0?this.Fr.zero:this.coef.slice(0,this.Fr.n8);this.coef.set(this.Fr.sub(n,t),0)}byXSubValue(t){const n=this.Fr,i=!n.eq(n.zero,this.getCoef(this.length()-1))?this.length()+1:this.length(),e=i>32768?new ft(i*n.n8):new Uint8Array(i*n.n8);let l=new yt(e,this.curve,this.logger);l.coef.set(this.coef.slice(0,(i-1)*n.n8),32),this.mulScalar(n.neg(t)),l.add(this),this.coef=l.coef}byXNSubValue(t,n){const a=this.Fr,e=!(this.length()-t-1>=this.degree())?this.length()+t:this.length(),l=e>32768?new ft(e*a.n8):new Uint8Array(e*a.n8);let s=new yt(l,this.curve,this.logger);s.coef.set(this.coef.slice(0,(this.degree()+1)*32),t*32),this.mulScalar(n),s.add(this),this.coef=s.coef}divBy(t){const n=this.Fr,a=this.degree(),i=t.degree();let e=new yt(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new ft(this.length()*n.n8):new Uint8Array(this.length()*n.n8);for(let l=a-i;l>=0;l--){this.setCoef(l,n.div(e.getCoef(l+i),t.getCoef(i)));for(let s=0;s<=i;s++)e.setCoef(l+s,n.sub(e.getCoef(l+s),n.mul(this.getCoef(l),t.getCoef(s))))}return e}divByMonic(t,n){const a=this.Fr;let i=this.degree(),e=this.length()>32768?new ft(this.length()*a.n8):new Uint8Array(this.length()*a.n8),l=new yt(e,this.curve,this.logger),s=[];for(let d=0;d<t;d++)l.setCoef(i-d-t,this.getCoef(i-d)),s[d]=this.getCoef(i-d);let h=t;for(let d=0;d<h;d++)for(let c=i-2*t-d;c>=0&&!(c<0);c=c-h){let f=d;s[f]=a.add(this.getCoef(c+t),a.mul(s[f],n)),l.setCoef(c,s[f])}this.coef=l.coef}divByVanishing(t,n){if(this.degree()<t)throw new Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");const a=this.Fr;let i=new yt(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new ft(this.length()*a.n8):new Uint8Array(this.length()*a.n8);for(let e=this.length()-1;e>=t;e--){let l=i.getCoef(e);a.eq(a.zero,l)||(i.setCoef(e,a.zero),i.setCoef(e-t,a.add(i.getCoef(e-t),a.mul(n,l))),this.setCoef(e-t,a.add(this.getCoef(e-t),l)))}return i}divByVanishing2(t,n){if(this.degree()<t)throw new Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");const a=this.Fr;let i=new yt(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new ft(this.length()*a.n8):new Uint8Array(this.length()*a.n8);let e=3,l=this.length()-t,s=Math.floor(l/e),h=l-(e-1)*s;console.log(l),console.log(s+"  "+h);for(let d=0;d<e;d++){console.log("> Thread "+d);for(let c=d===0?h:s;c>0;c--){let f=c-1;d!==0&&(f+=(d-1)*s+h);let y=f+t,L=i.getCoef(y);a.eq(a.zero,L)||(i.setCoef(y,a.zero),i.setCoef(f,a.add(i.getCoef(f),a.mul(n,L))),this.setCoef(f,a.add(this.getCoef(f),L)),console.log(f+" <-- "+y))}}return this.print(),i}fastDivByVanishing(t){const n=this.Fr;for(let a=0;a<t.length;a++){let i=t[a][0],e=t[a][1];if(this.degree()<i)throw new Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let l=5,s=this.length()-i,h=Math.floor(s/l/i),d=h*i,c=s-l*d,f=new yt(this.length()>32768?new ft(this.length()*n.n8):new Uint8Array(this.length()*n.n8),this.curve,this.logger),y=this.coef;this.coef=f.coef,f.coef=y;for(let A=0;A<l;A++){let G=(A+1)*d+c;for(let P=0;P<i;P++)this.setCoef(G+P-i,f.getCoef(G+P));for(let P=0;P<d-i;P++){let U=G-P-1,I=n.add(f.getCoef(U),n.mul(e,this.getCoef(U)));this.setCoef(U-i,I)}}let L=c,v=c;for(let A=0;A<i&&v;A++)this.setCoef(L-A-1,f.getCoef(L+i-A-1)),v--;for(let A=0;A<v;A++){let G=L-A-1,P=n.add(f.getCoef(G),n.mul(e,this.getCoef(G)));this.setCoef(G-i,P)}let T=[],B=n.one;for(let A=0;A<h;A++)B=n.mul(B,e);let E=n.one;for(let A=l;A>0;A--){let G=A-1,P=G*d+c;T[G]=[];for(let U=0;U<i;U++)T[G][U]=this.getCoef(P+U),A!==l&&(T[G][U]=n.add(T[G][U],n.mul(B,T[G+1][U])));E=n.mul(E,B)}for(let A=0;A<l;A++){let G=A*d+c,P=e,U=i-1,I=A===0?c:d;for(let _=0;_<I;_++){let b=G-_-1,$=n.add(this.getCoef(b),n.mul(P,T[A][U]));this.setCoef(b,$),U===0?(U=i-1,P=n.mul(P,e)):U--}}}}divByXSubValue(t){const n=this.length()>32768?new ft(this.length()*this.Fr.n8):new Uint8Array(this.length()*this.Fr.n8);n.set(this.Fr.zero,(this.length()-1)*this.Fr.n8),n.set(this.coef.slice((this.length()-1)*this.Fr.n8,this.length()*this.Fr.n8),(this.length()-2)*this.Fr.n8);for(let a=this.length()-3;a>=0;a--){let i=a*this.Fr.n8;n.set(this.Fr.add(this.coef.slice(i+this.Fr.n8,i+2*this.Fr.n8),this.Fr.mul(t,n.slice(i+this.Fr.n8,i+2*this.Fr.n8))),a*this.Fr.n8)}if(!this.Fr.eq(this.coef.slice(0,this.Fr.n8),this.Fr.mul(this.Fr.neg(t),n.slice(0,this.Fr.n8))))throw new Error("Polynomial does not divide");this.coef=n}divZh(t,n=4){for(let i=0;i<t;i++){const e=i*this.Fr.n8;this.coef.set(this.Fr.neg(this.coef.slice(e,e+this.Fr.n8)),e)}const a=this.coef.byteLength/this.Fr.n8;for(let i=t;i<a;i++){const e=i*this.Fr.n8,l=this.Fr.sub(this.coef.slice((i-t)*this.Fr.n8,(i-t)*this.Fr.n8+this.Fr.n8),this.coef.slice(e,e+this.Fr.n8));if(this.coef.set(l,e),i>t*(n-1)-n&&!this.Fr.isZero(l))throw new Error("Polynomial is not divisible")}return this}divByZerofier(t,n){let a=this.Fr;const i=a.inv(n),e=a.neg(i);let l=a.eq(a.one,e),s=a.eq(a.negone,e);if(!l)for(let h=0;h<t;h++){const d=h*this.Fr.n8;let c;s?c=a.neg(this.coef.slice(d,d+this.Fr.n8)):c=a.mul(e,this.coef.slice(d,d+this.Fr.n8)),this.coef.set(c,d)}l=a.eq(a.one,i),s=a.eq(a.negone,i);for(let h=t;h<this.length();h++){const d=h*this.Fr.n8,c=(h-t)*this.Fr.n8;let f=this.Fr.sub(this.coef.slice(c,c+this.Fr.n8),this.coef.slice(d,d+this.Fr.n8));if(l||(s?f=a.neg(f):f=a.mul(i,f)),this.coef.set(f,d),h>this.length()-t-1&&!this.Fr.isZero(f))throw new Error("Polynomial is not divisible")}return this}byX(){const t=this.length()+1>32768?new ft(this.coef.byteLength+this.Fr.n8):new Uint8Array(this.coef.byteLength+this.Fr.n8);t.set(this.Fr.zero,0),t.set(this.coef,this.Fr.n8),this.coef=t}static async expX(t,n,a=!1){const i=t.Fr;if(n<1)throw new Error("Compute a new polynomial to a zero or negative number is not allowed");if(n===1)return await yt.fromEvaluations(t.coef,curve,t.logger);const e=a?t.degree():t.length()-1,l=e*n+1>32768?new ft((e*n+1)*i.n8):new Uint8Array((e*n+1)*i.n8);l.set(t.getCoef(0),0);for(let s=1;s<=e;s++){const h=s*i.n8,d=t.getCoef(s);l.set(d,h*n)}return new yt(l,t.curve,t.logger)}split(t,n,a){if(t<1)throw new Error(`Polynomials can't be split in ${t} parts`);if(t===1)return[this];if(a.length!==0&&a.length<t-1)throw new Error(`Blinding factors length must be ${t-1}`);const i=(n+1)*this.Fr.n8;let e=[];const l=Math.ceil((this.degree()+1)*this.Fr.n8/i);if(l<t)for(let s=l;s<t;s++)e[s]=new yt(new Uint8Array(this.Fr.n8),this.curve,this.logger);t=Math.min(t,l);for(let s=0;s<t;s++){const h=t-1===s,d=h?this.coef.byteLength-(t-1)*i:i+this.Fr.n8;let c=d/this.Fr.n8>32768?new ft(d):new Uint8Array(d);e[s]=new yt(c,this.curve,this.logger);const f=s*i,y=h?this.coef.byteLength:(s+1)*i;if(e[s].coef.set(this.coef.slice(f,y),0),h||e[s].coef.set(a[s],i),s!==0){const L=this.Fr.sub(e[s].coef.slice(0,this.Fr.n8),a[s-1]);e[s].coef.set(L,0)}h&&e[s].truncate()}return e}truncate(){const t=this.degree();if(t+1<this.coef.byteLength/this.Fr.n8){const n=t+1>32768?new ft((t+1)*this.Fr.n8):new Uint8Array((t+1)*this.Fr.n8);n.set(this.coef.slice(0,(t+1)*this.Fr.n8),0),this.coef=n}}static lagrangePolynomialInterpolation(t,n,a){const i=a.Fr;let e=l(0);for(let s=1;s<t.length;s++)e.add(l(s));return e;function l(s){let h;for(let f=0;f<t.length;f++)if(f!==s)if(h===void 0){let y=t.length>32768?new ft(t.length*i.n8):new Uint8Array(t.length*i.n8);h=new yt(y,a),h.setCoef(0,i.neg(t[f])),h.setCoef(1,i.one)}else h.byXSubValue(t[f]);let d=h.evaluate(t[s]);d=i.inv(d);const c=i.mul(n[s],d);return h.mulScalar(c),h}}static zerofierPolynomial(t,n){const a=n.Fr;let i=t.length+1>32768?new ft((t.length+1)*a.n8):new Uint8Array((t.length+1)*a.n8),e=new yt(i,n);e.setCoef(0,a.neg(t[0])),e.setCoef(1,a.one);for(let l=1;l<t.length;l++)e.byXSubValue(t[l]);return e}print(){const t=this.Fr;let n="";for(let a=this.degree();a>=0;a--){const i=this.getCoef(a);t.eq(t.zero,i)||(t.isNegative(i)?n+=" - ":a!==this.degree()&&(n+=" + "),n+=t.toString(i),a>0&&(n+=a>1?"x^"+a:"x"))}console.log(n)}async multiExponentiation(t,n){const a=this.coef.byteLength/this.Fr.n8,i=t.slice(0,a*this.G1.F.n8*2),e=await this.Fr.batchFromMontgomery(this.coef);let l=await this.G1.multiExpAffine(i,e,this.logger,n);return l=this.G1.toAffine(l),l}}class Xt{constructor(t,n,a){this.eval=t,this.curve=n,this.Fr=n.Fr,this.logger=a}static async fromPolynomial(t,n,a,i){const e=new ft(t.length()*n*a.Fr.n8);e.set(t.coef,0);const l=await a.Fr.fft(e);return new Xt(l,a,i)}getEvaluation(t){const n=t*this.Fr.n8;if(n+this.Fr.n8>this.eval.byteLength)throw new Error("Evaluations.getEvaluation() out of bounds");return this.eval.slice(n,n+this.Fr.n8)}length(){let t=this.eval.byteLength/this.Fr.n8;if(t!==Math.floor(this.eval.byteLength/this.Fr.n8))throw new Error("Polynomial evaluations buffer has incorrect size");return t===0&&this.logger.warn("Polynomial has length zero"),t}}const{stringifyBigInts:po}=cn;async function Ps(o,t,n,a){const{fd:i,sections:e}=await Kt(t,"wtns",2);n&&n.debug("> Reading witness file");const l=await Ra(i,e);n&&n.debug("> Reading zkey file");const{fd:s,sections:h}=await Kt(o,"zkey",2),d=await yn(s,h,void 0,a);if(d.protocol!="plonk")throw new Error("zkey file is not plonk");if(!Ft.eq(d.r,l.q))throw new Error("Curve of the witness does not match the curve of the proving key");if(l.nWitness!=d.nVars-d.nAdditions)throw new Error(`Invalid witness length. Circuit: ${d.nVars}, witness: ${l.nWitness}, ${d.nAdditions}`);const c=d.curve,f=c.Fr,y=c.Fr.n8,L=d.domainSize*y;n&&(n.debug("----------------------------"),n.debug("  PLONK PROVE SETTINGS"),n.debug(`  Curve:         ${c.name}`),n.debug(`  Circuit power: ${d.power}`),n.debug(`  Domain size:   ${d.domainSize}`),n.debug(`  Vars:          ${d.nVars}`),n.debug(`  Public vars:   ${d.nPublic}`),n.debug(`  Constraints:   ${d.nConstraints}`),n.debug(`  Additions:     ${d.nAdditions}`),n.debug("----------------------------")),n&&n.debug("> Reading witness file data");const v=await Vt(i,e,2);v.set(f.zero,0);const T=new ft(y*d.nAdditions);let B={},E={},A={},G={},P=new Ce(c,n);const U=new Yn(c);n&&n.debug(`> Reading Section ${_o}. Additions`),await $(),n&&n.debug(`> Reading Section ${Kn}. Sigma1, Sigma2 & Sigma 3`),n&&n.debug(" Reading Sigma polynomials "),E.Sigma1=new yt(new ft(L),c,n),E.Sigma2=new yt(new ft(L),c,n),E.Sigma3=new yt(new ft(L),c,n),await s.readToBuffer(E.Sigma1.coef,0,L,h[Kn][0].p),await s.readToBuffer(E.Sigma2.coef,0,L,h[Kn][0].p+5*L),await s.readToBuffer(E.Sigma3.coef,0,L,h[Kn][0].p+10*L),n&&n.debug(" Reading Sigma evaluations"),A.Sigma1=new Xt(new ft(L*4),c,n),A.Sigma2=new Xt(new ft(L*4),c,n),A.Sigma3=new Xt(new ft(L*4),c,n),await s.readToBuffer(A.Sigma1.eval,0,L*4,h[Kn][0].p+L),await s.readToBuffer(A.Sigma2.eval,0,L*4,h[Kn][0].p+6*L),await s.readToBuffer(A.Sigma3.eval,0,L*4,h[Kn][0].p+11*L),n&&n.debug(`> Reading Section ${go}. Powers of Tau`);const I=await Vt(s,h,go);let _=[];for(let k=1;k<=d.nPublic;k++){const J=v.slice(k*f.n8,k*f.n8+f.n8);_.push(Ft.fromRprLE(J))}n&&n.debug(""),n&&n.debug("> ROUND 1"),await M(),n&&n.debug("> ROUND 2"),await z(),n&&n.debug("> ROUND 3"),await Z(),n&&n.debug("> ROUND 4"),await V(),n&&n.debug("> ROUND 5"),await nt(),await s.close(),await i.close();let b=P.toObjectProof(!1);return b.protocol="plonk",b.curve=c.name,n&&n.debug("PLONK PROVER FINISHED"),{proof:po(b),publicSignals:po(_)};async function $(){n&&n.debug(" Computing additions");const k=await Vt(s,h,_o),J=8+y*2;for(let m=0;m<d.nAdditions;m++){n&&m!==0&&m%1e5===0&&n.debug(`    addition ${m}/${d.nAdditions}`);let r=m*J;const C=K(k,r);r+=4;const u=K(k,r);r+=4;const x=k.slice(r,r+y);r+=y;const F=k.slice(r,r+y),p=j(C),O=j(u),R=f.add(f.mul(x,p),f.mul(F,O));T.set(R,y*m)}}function K(k,J){const m=k.slice(J,J+4);return new DataView(m.buffer,m.byteOffset,m.byteLength).getUint32(0,!0)}function j(k){return k<d.nVars-d.nAdditions?v.slice(k*y,k*y+y):k<d.nVars?T.slice((k-(d.nVars-d.nAdditions))*y,(k-(d.nVars-d.nAdditions))*y+y):c.Fr.zero}async function M(){G.b=[];for(let r=1;r<=11;r++)G.b[r]=c.Fr.random();n&&n.debug("> Computing A, B, C wire polynomials"),await S(),n&&n.debug("> Computing A, B, C MSM");let k=await E.A.multiExponentiation(I,"A"),J=await E.B.multiExponentiation(I,"B"),m=await E.C.multiExponentiation(I,"C");return P.addPolynomial("A",k),P.addPolynomial("B",J),P.addPolynomial("C",m),0}async function S(){n&&n.debug(" Reading data from zkey file"),B.A=new ft(L),B.B=new ft(L),B.C=new ft(L);const k=await Vt(s,h,Cd),J=await Vt(s,h,Id),m=await Vt(s,h,Ed);for(let r=0;r<d.nConstraints;r++){const C=r*y,u=r*4,x=K(k,u);B.A.set(j(x),C);const F=K(J,u);B.B.set(j(F),C);const p=K(m,u);B.C.set(j(p),C)}if(B.A=await f.batchToMontgomery(B.A),B.B=await f.batchToMontgomery(B.B),B.C=await f.batchToMontgomery(B.C),n&&n.debug(" Computing A ifft"),E.A=await yt.fromEvaluations(B.A,c,n),n&&n.debug(" Computing B ifft"),E.B=await yt.fromEvaluations(B.B,c,n),n&&n.debug(" Computing C ifft"),E.C=await yt.fromEvaluations(B.C,c,n),n&&n.debug(" Computing A fft"),A.A=await Xt.fromPolynomial(E.A,4,c,n),n&&n.debug(" Computing B fft"),A.B=await Xt.fromPolynomial(E.B,4,c,n),n&&n.debug(" Computing C fft"),A.C=await Xt.fromPolynomial(E.C,4,c,n),E.A.blindCoefficients([G.b[2],G.b[1]]),E.B.blindCoefficients([G.b[4],G.b[3]]),E.C.blindCoefficients([G.b[6],G.b[5]]),E.A.degree()>=d.domainSize+2)throw new Error("A Polynomial is not well calculated");if(E.B.degree()>=d.domainSize+2)throw new Error("B Polynomial is not well calculated");if(E.C.degree()>=d.domainSize+2)throw new Error("C Polynomial is not well calculated")}async function z(){n&&n.debug("> Computing challenges beta and gamma"),U.reset(),U.addPolCommitment(d.Qm),U.addPolCommitment(d.Ql),U.addPolCommitment(d.Qr),U.addPolCommitment(d.Qo),U.addPolCommitment(d.Qc),U.addPolCommitment(d.S1),U.addPolCommitment(d.S2),U.addPolCommitment(d.S3);for(let J=0;J<d.nPublic;J++)U.addScalar(B.A.slice(J*y,J*y+y));U.addPolCommitment(P.getPolynomial("A")),U.addPolCommitment(P.getPolynomial("B")),U.addPolCommitment(P.getPolynomial("C")),G.beta=U.getChallenge(),n&&n.debug(" challenges.beta: "+f.toString(G.beta,16)),U.reset(),U.addScalar(G.beta),G.gamma=U.getChallenge(),n&&n.debug(" challenges.gamma: "+f.toString(G.gamma,16)),n&&n.debug("> Computing Z polynomial"),await q(),n&&n.debug("> Computing Z MSM");let k=await E.Z.multiExponentiation(I,"Z");P.addPolynomial("Z",k)}async function q(){n&&n.debug(" Computing Z evaluations");let k=new ft(L),J=new ft(L);k.set(f.one,0),J.set(f.one,0);let m=f.one;for(let r=0;r<d.domainSize;r++){const C=r*y,u=B.A.slice(C,C+y),x=B.B.slice(C,C+y),F=B.C.slice(C,C+y),p=f.mul(G.beta,m);let O=f.add(u,p);O=f.add(O,G.gamma);let R=f.add(x,f.mul(d.k1,p));R=f.add(R,G.gamma);let N=f.add(F,f.mul(d.k2,p));N=f.add(N,G.gamma);let H=f.mul(O,f.mul(R,N)),lt=f.add(u,f.mul(A.Sigma1.getEvaluation(r*4),G.beta));lt=f.add(lt,G.gamma);let ht=f.add(x,f.mul(A.Sigma2.getEvaluation(r*4),G.beta));ht=f.add(ht,G.gamma);let pt=f.add(F,f.mul(A.Sigma3.getEvaluation(r*4),G.beta));pt=f.add(pt,G.gamma);let ut=f.mul(lt,f.mul(ht,pt));H=f.mul(k.slice(C,C+y),H),k.set(H,(r+1)%d.domainSize*y),ut=f.mul(J.slice(C,C+y),ut),J.set(ut,(r+1)%d.domainSize*y),m=f.mul(m,f.w[d.power])}J=await f.batchInverse(J);for(let r=0;r<d.domainSize;r++){const C=r*y,u=f.mul(k.slice(C,C+y),J.slice(C,C+y));k.set(u,C)}if(B.Z=k,!f.eq(k.slice(0,y),f.one))throw new Error("Copy constraints does not match");if(n&&n.debug(" Computing Z ifft"),E.Z=await yt.fromEvaluations(B.Z,c,n),n&&n.debug(" Computing Z fft"),A.Z=await Xt.fromPolynomial(E.Z,4,c,n),E.Z.blindCoefficients([G.b[9],G.b[8],G.b[7]]),E.Z.degree()>=d.domainSize+3)throw new Error("Z Polynomial is not well calculated");delete B.Z}async function Z(){n&&n.debug("> Computing challenge alpha"),U.reset(),U.addScalar(G.beta),U.addScalar(G.gamma),U.addPolCommitment(P.getPolynomial("Z")),G.alpha=U.getChallenge(),G.alpha2=f.square(G.alpha),n&&n.debug(" challenges.alpha: "+f.toString(G.alpha,16)),n&&n.debug("> Computing T polynomial"),await Y(),n&&n.debug("> Computing T MSM");let k=await E.T1.multiExponentiation(I,"T1"),J=await E.T2.multiExponentiation(I,"T2"),m=await E.T3.multiExponentiation(I,"T3");P.addPolynomial("T1",k),P.addPolynomial("T2",J),P.addPolynomial("T3",m)}async function Y(){n&&n.debug(` Reading sections ${Si}, ${xi}, ${Bi}, ${vi}, ${Gi}. Q selectors`),A.QL=new Xt(new ft(L*4),c,n),A.QR=new Xt(new ft(L*4),c,n),A.QM=new Xt(new ft(L*4),c,n),A.QO=new Xt(new ft(L*4),c,n),A.QC=new Xt(new ft(L*4),c,n),await s.readToBuffer(A.QL.eval,0,L*4,h[Si][0].p+L),await s.readToBuffer(A.QR.eval,0,L*4,h[xi][0].p+L),await s.readToBuffer(A.QM.eval,0,L*4,h[Bi][0].p+L),await s.readToBuffer(A.QO.eval,0,L*4,h[vi][0].p+L),await s.readToBuffer(A.QC.eval,0,L*4,h[Gi][0].p+L),A.Lagrange=new Xt(new ft(L*4*d.nPublic),c,n);for(let r=0;r<d.nPublic;r++)await s.readToBuffer(A.Lagrange.eval,r*L*4,L*4,h[Fd][0].p+r*5*L+L);B.T=new ft(L*4),B.Tz=new ft(L*4),n&&n.debug(" Computing T evaluations");let k=f.one;for(let r=0;r<d.domainSize*4;r++){n&&r!==0&&r%1e5===0&&n.debug(`      T evaluation ${r}/${d.domainSize*4}`);const C=A.A.getEvaluation(r),u=A.B.getEvaluation(r),x=A.C.getEvaluation(r),F=A.Z.getEvaluation(r),p=A.Z.getEvaluation((d.domainSize*4+4+r)%(d.domainSize*4)),O=A.QM.getEvaluation(r),R=A.QL.getEvaluation(r),N=A.QR.getEvaluation(r),H=A.QO.getEvaluation(r),lt=A.QC.getEvaluation(r),ht=A.Sigma1.getEvaluation(r),pt=A.Sigma2.getEvaluation(r),ut=A.Sigma3.getEvaluation(r),st=f.add(G.b[2],f.mul(G.b[1],k)),ct=f.add(G.b[4],f.mul(G.b[3],k)),Lt=f.add(G.b[6],f.mul(G.b[5],k)),At=f.square(k),Bt=f.add(f.add(f.mul(G.b[7],At),f.mul(G.b[8],k)),G.b[9]),Mt=f.mul(k,f.w[d.power]),$t=f.square(Mt),Dt=f.add(f.add(f.mul(G.b[7],$t),f.mul(G.b[8],Mt)),G.b[9]);let vt=f.zero;for(let mt=0;mt<d.nPublic;mt++){const St=mt*4*d.domainSize+r,xt=A.Lagrange.getEvaluation(St),Qt=B.A.slice(mt*y,(mt+1)*y);vt=f.sub(vt,f.mul(xt,Qt))}let[bt,qt]=Fi.mul2(C,u,st,ct,r%4,f);bt=f.mul(bt,O),qt=f.mul(qt,O),bt=f.add(bt,f.mul(C,R)),qt=f.add(qt,f.mul(st,R)),bt=f.add(bt,f.mul(u,N)),qt=f.add(qt,f.mul(ct,N)),bt=f.add(bt,f.mul(x,H)),qt=f.add(qt,f.mul(Lt,H)),bt=f.add(bt,vt),bt=f.add(bt,lt);const Yt=f.mul(G.beta,k);let Ht=C;Ht=f.add(Ht,Yt),Ht=f.add(Ht,G.gamma);let ot=u;ot=f.add(ot,f.mul(Yt,d.k1)),ot=f.add(ot,G.gamma);let g=x;g=f.add(g,f.mul(Yt,d.k2)),g=f.add(g,G.gamma);let w=F,[W,at]=Fi.mul4(Ht,ot,g,w,st,ct,Lt,Bt,r%4,f);W=f.mul(W,G.alpha),at=f.mul(at,G.alpha);let D=C;D=f.add(D,f.mul(G.beta,ht)),D=f.add(D,G.gamma);let et=u;et=f.add(et,f.mul(G.beta,pt)),et=f.add(et,G.gamma);let tt=x;tt=f.add(tt,f.mul(G.beta,ut)),tt=f.add(tt,G.gamma);let rt=p,[_t,gt]=Fi.mul4(D,et,tt,rt,st,ct,Lt,Dt,r%4,f);_t=f.mul(_t,G.alpha),gt=f.mul(gt,G.alpha);let dt=f.sub(F,f.one);dt=f.mul(dt,A.Lagrange.getEvaluation(r)),dt=f.mul(dt,G.alpha2);let wt=f.mul(Bt,A.Lagrange.getEvaluation(r));wt=f.mul(wt,G.alpha2);let It=f.add(f.sub(f.add(bt,W),_t),dt),Ct=f.add(f.sub(f.add(qt,at),gt),wt);B.T.set(It,r*y),B.Tz.set(Ct,r*y),k=f.mul(k,f.w[d.power+2])}if(n&&n.debug(" Computing T ifft"),E.T=await yt.fromEvaluations(B.T,c,n),n&&n.debug(" Computing T / ZH"),E.T.divZh(d.domainSize,4),n&&n.debug(" Computing Tz ifft"),E.Tz=await yt.fromEvaluations(B.Tz,c,n),E.T.add(E.Tz),E.T.degree()>=d.domainSize*3+6)throw new Error("T Polynomial is not well calculated");n&&n.debug(" Computing T1, T2, T3 polynomials"),E.T1=new yt(new ft((d.domainSize+1)*y),c,n),E.T2=new yt(new ft((d.domainSize+1)*y),c,n),E.T3=new yt(new ft((d.domainSize+6)*y),c,n),E.T1.coef.set(E.T.coef.slice(0,L),0),E.T2.coef.set(E.T.coef.slice(L,L*2),0),E.T3.coef.set(E.T.coef.slice(L*2,L*3+6*y),0),E.T1.setCoef(d.domainSize,G.b[10]);const J=f.sub(E.T2.getCoef(0),G.b[10]);E.T2.setCoef(0,J),E.T2.setCoef(d.domainSize,G.b[11]);const m=f.sub(E.T3.getCoef(0),G.b[11]);E.T3.setCoef(0,m)}async function V(){n&&n.debug("> Computing challenge xi"),U.reset(),U.addScalar(G.alpha),U.addPolCommitment(P.getPolynomial("T1")),U.addPolCommitment(P.getPolynomial("T2")),U.addPolCommitment(P.getPolynomial("T3")),G.xi=U.getChallenge(),G.xiw=f.mul(G.xi,f.w[d.power]),n&&n.debug(" challenges.xi: "+f.toString(G.xi,16)),P.addEvaluation("eval_a",E.A.evaluate(G.xi)),P.addEvaluation("eval_b",E.B.evaluate(G.xi)),P.addEvaluation("eval_c",E.C.evaluate(G.xi)),P.addEvaluation("eval_s1",E.Sigma1.evaluate(G.xi)),P.addEvaluation("eval_s2",E.Sigma2.evaluate(G.xi)),P.addEvaluation("eval_zw",E.Z.evaluate(G.xiw))}async function nt(){n&&n.debug("> Computing challenge v"),U.reset(),U.addScalar(G.xi),U.addScalar(P.getEvaluation("eval_a")),U.addScalar(P.getEvaluation("eval_b")),U.addScalar(P.getEvaluation("eval_c")),U.addScalar(P.getEvaluation("eval_s1")),U.addScalar(P.getEvaluation("eval_s2")),U.addScalar(P.getEvaluation("eval_zw")),G.v=[],G.v[1]=U.getChallenge(),n&&n.debug(" challenges.v: "+f.toString(G.v[1],16));for(let m=2;m<6;m++)G.v[m]=f.mul(G.v[m-1],G.v[1]);n&&n.debug("> Computing linearisation polynomial R(X)"),await Q(),n&&n.debug("> Computing opening proof polynomial Wxi(X) polynomial"),it(),n&&n.debug("> Computing opening proof polynomial Wxiw(X) polynomial"),X(),n&&n.debug("> Computing Wxi, Wxiw MSM");let k=await E.Wxi.multiExponentiation(I,"Wxi"),J=await E.Wxiw.multiExponentiation(I,"Wxiw");P.addPolynomial("Wxi",k),P.addPolynomial("Wxiw",J)}async function Q(){const k=c.Fr;E.QL=new yt(new ft(L),c,n),E.QR=new yt(new ft(L),c,n),E.QM=new yt(new ft(L),c,n),E.QO=new yt(new ft(L),c,n),E.QC=new yt(new ft(L),c,n),await s.readToBuffer(E.QL.coef,0,L,h[Si][0].p),await s.readToBuffer(E.QR.coef,0,L,h[xi][0].p),await s.readToBuffer(E.QM.coef,0,L,h[Bi][0].p),await s.readToBuffer(E.QO.coef,0,L,h[vi][0].p),await s.readToBuffer(E.QC.coef,0,L,h[Gi][0].p),G.xin=G.xi;for(let ct=0;ct<d.power;ct++)G.xin=k.square(G.xin);G.zh=k.sub(G.xin,k.one);const J=[],m=k.e(d.domainSize);let r=k.one;for(let ct=1;ct<=Math.max(1,d.nPublic);ct++)J[ct]=k.div(k.mul(r,G.zh),k.mul(m,k.sub(G.xi,r))),r=k.mul(r,k.w[d.power]);const C=k.div(k.sub(G.xin,k.one),k.mul(m,k.sub(G.xi,k.one)));if(n){n.debug("Lagrange Evaluations: ");for(let ct=1;ct<J.length;ct++)n.debug(`L${ct}(xi)=`+k.toString(J[ct],16))}let u=k.zero;for(let ct=0;ct<_.length;ct++){const Lt=k.e(_[ct]);u=k.sub(u,k.mul(Lt,J[ct+1]))}n&&n.debug("PI: "+k.toString(u,16));const x=k.mul(P.evaluations.eval_a,P.evaluations.eval_b);let F=P.evaluations.eval_a;const p=k.mul(G.beta,G.xi);F=k.add(F,p),F=k.add(F,G.gamma);let O=P.evaluations.eval_b;O=k.add(O,k.mul(p,d.k1)),O=k.add(O,G.gamma);let R=P.evaluations.eval_c;R=k.add(R,k.mul(p,d.k2)),R=k.add(R,G.gamma);const N=k.mul(k.mul(k.mul(F,O),R),G.alpha);let H=P.evaluations.eval_a;H=k.add(H,k.mul(G.beta,P.evaluations.eval_s1)),H=k.add(H,G.gamma);let lt=P.evaluations.eval_b;lt=k.add(lt,k.mul(G.beta,P.evaluations.eval_s2)),lt=k.add(lt,G.gamma);let ht=k.mul(H,lt);ht=k.mul(ht,P.evaluations.eval_zw),ht=k.mul(ht,G.alpha);const pt=k.mul(C,G.alpha2);E.R=new yt(new ft((d.domainSize+6)*y),c,n),E.R.add(E.QM,x),E.R.add(E.QL,P.evaluations.eval_a),E.R.add(E.QR,P.evaluations.eval_b),E.R.add(E.QO,P.evaluations.eval_c),E.R.add(E.QC),E.R.add(E.Z,N),E.R.sub(E.Sigma3,k.mul(ht,G.beta)),E.R.add(E.Z,pt);let ut=yt.fromPolynomial(E.T3,c,n);ut.mulScalar(k.square(G.xin)),ut.add(E.T2,G.xin),ut.add(E.T1),ut.mulScalar(G.zh),E.R.sub(ut);let st=k.sub(u,k.mul(ht,k.add(P.evaluations.eval_c,G.gamma)));st=k.sub(st,pt),n&&n.debug("r0: "+k.toString(st,16)),E.R.addScalar(st)}function it(){E.Wxi=new yt(new ft(L+6*y),c,n),E.Wxi.add(E.R),E.Wxi.add(E.A,G.v[1]),E.Wxi.add(E.B,G.v[2]),E.Wxi.add(E.C,G.v[3]),E.Wxi.add(E.Sigma1,G.v[4]),E.Wxi.add(E.Sigma2,G.v[5]),E.Wxi.subScalar(f.mul(G.v[1],P.evaluations.eval_a)),E.Wxi.subScalar(f.mul(G.v[2],P.evaluations.eval_b)),E.Wxi.subScalar(f.mul(G.v[3],P.evaluations.eval_c)),E.Wxi.subScalar(f.mul(G.v[4],P.evaluations.eval_s1)),E.Wxi.subScalar(f.mul(G.v[5],P.evaluations.eval_s2)),E.Wxi.divByZerofier(1,G.xi)}async function X(){E.Wxiw=yt.fromPolynomial(E.Z,c,n),E.Wxiw.subScalar(P.evaluations.eval_zw),E.Wxiw.divByZerofier(1,G.xiw)}}const{unstringifyBigInts:Bd}=cn;async function Sd(o,t,n,a,i,e){const l=Bd(o),s={type:"mem"};return await li(l,t,s,i),await Ps(n,s,a,e)}const{unstringifyBigInts:Pi}=cn;async function xd(o,t,n,a){let i=Pi(o);n=Pi(n);let e=Pi(t);const l=await ta(i.curve),s=l.Fr,h=l.G1;a&&a.info("PLONK VERIFIER STARTED");let d=vd(l,n);if(i=Gd(l,i),!Pd(l,d))return a.error("Proof is not well constructed"),!1;if(e.length!=i.nPublic)return a.error("Invalid number of public inputs"),!1;const c=Td(l,d,e,i);if(a){a.debug("beta: "+s.toString(c.beta,16)),a.debug("gamma: "+s.toString(c.gamma,16)),a.debug("alpha: "+s.toString(c.alpha,16)),a.debug("xi: "+s.toString(c.xi,16));for(let A=1;A<6;A++)a&&a.debug("v: "+s.toString(c.v[A],16));a.debug("u: "+s.toString(c.u,16))}const f=Od(l,c,i);if(a)for(let A=1;A<f.length;A++)a.debug(`L${A}(xi)=`+s.toString(f[A],16));if(e.length!=i.nPublic)return a.error("Number of public signals does not match with vk"),!1;const y=Ud(l,e,f);a&&a.debug("PI(xi): "+s.toString(y,16));const L=Md(l,d,c,y,f[1]);a&&a.debug("r0: "+s.toString(L,16));const v=zd(l,d,c,i,f[1]);a&&a.debug("D: "+h.toString(h.toAffine(v),16));const T=qd(l,d,c,i,v);a&&a.debug("F: "+h.toString(h.toAffine(T),16));const B=Qd(l,d,c,L);a&&a.debug("E: "+h.toString(h.toAffine(B),16));const E=await Rd(l,d,c,i,B,T);return a&&(E?a.info("OK!"):a.warn("Invalid Proof")),E}function vd(o,t){const n=o.G1,a=o.Fr,i={};return i.A=n.fromObject(t.A),i.B=n.fromObject(t.B),i.C=n.fromObject(t.C),i.Z=n.fromObject(t.Z),i.T1=n.fromObject(t.T1),i.T2=n.fromObject(t.T2),i.T3=n.fromObject(t.T3),i.eval_a=a.fromObject(t.eval_a),i.eval_b=a.fromObject(t.eval_b),i.eval_c=a.fromObject(t.eval_c),i.eval_zw=a.fromObject(t.eval_zw),i.eval_s1=a.fromObject(t.eval_s1),i.eval_s2=a.fromObject(t.eval_s2),i.Wxi=n.fromObject(t.Wxi),i.Wxiw=n.fromObject(t.Wxiw),i}function Gd(o,t){const n=o.G1,a=o.G2,i=o.Fr,e=t;return e.Qm=n.fromObject(t.Qm),e.Ql=n.fromObject(t.Ql),e.Qr=n.fromObject(t.Qr),e.Qo=n.fromObject(t.Qo),e.Qc=n.fromObject(t.Qc),e.S1=n.fromObject(t.S1),e.S2=n.fromObject(t.S2),e.S3=n.fromObject(t.S3),e.k1=i.fromObject(t.k1),e.k2=i.fromObject(t.k2),e.X_2=a.fromObject(t.X_2),e}function Pd(o,t){const n=o.G1;return!(!n.isValid(t.A)||!n.isValid(t.B)||!n.isValid(t.C)||!n.isValid(t.Z)||!n.isValid(t.T1)||!n.isValid(t.T2)||!n.isValid(t.T3)||!n.isValid(t.Wxi)||!n.isValid(t.Wxiw))}function Td(o,t,n,a){const i=o.Fr,e={},l=new Yn(o);l.addPolCommitment(a.Qm),l.addPolCommitment(a.Ql),l.addPolCommitment(a.Qr),l.addPolCommitment(a.Qo),l.addPolCommitment(a.Qc),l.addPolCommitment(a.S1),l.addPolCommitment(a.S2),l.addPolCommitment(a.S3);for(let s=0;s<n.length;s++)l.addScalar(i.e(n[s]));l.addPolCommitment(t.A),l.addPolCommitment(t.B),l.addPolCommitment(t.C),e.beta=l.getChallenge(),l.reset(),l.addScalar(e.beta),e.gamma=l.getChallenge(),l.reset(),l.addScalar(e.beta),l.addScalar(e.gamma),l.addPolCommitment(t.Z),e.alpha=l.getChallenge(),l.reset(),l.addScalar(e.alpha),l.addPolCommitment(t.T1),l.addPolCommitment(t.T2),l.addPolCommitment(t.T3),e.xi=l.getChallenge(),l.reset(),l.addScalar(e.xi),l.addScalar(t.eval_a),l.addScalar(t.eval_b),l.addScalar(t.eval_c),l.addScalar(t.eval_s1),l.addScalar(t.eval_s2),l.addScalar(t.eval_zw),e.v=[],e.v[1]=l.getChallenge();for(let s=2;s<6;s++)e.v[s]=i.mul(e.v[s-1],e.v[1]);return l.reset(),l.addPolCommitment(t.Wxi),l.addPolCommitment(t.Wxiw),e.u=l.getChallenge(),e}function Od(o,t,n){const a=o.Fr;let i=t.xi,e=1;for(let d=0;d<n.power;d++)i=a.square(i),e*=2;t.xin=i,t.zh=a.sub(i,a.one);const l=[],s=a.e(e);let h=a.one;for(let d=1;d<=Math.max(1,n.nPublic);d++)l[d]=a.div(a.mul(h,t.zh),a.mul(s,a.sub(t.xi,h))),h=a.mul(h,a.w[n.power]);return l}function Ud(o,t,n){const a=o.Fr;let i=a.zero;for(let e=0;e<t.length;e++){const l=a.e(t[e]);i=a.sub(i,a.mul(l,n[e+1]))}return i}function Md(o,t,n,a,i){const e=o.Fr,l=a,s=e.mul(i,e.square(n.alpha));let h=e.add(t.eval_a,e.mul(n.beta,t.eval_s1));h=e.add(h,n.gamma);let d=e.add(t.eval_b,e.mul(n.beta,t.eval_s2));d=e.add(d,n.gamma);let c=e.add(t.eval_c,n.gamma),f=e.mul(e.mul(h,d),c);return f=e.mul(f,t.eval_zw),f=e.mul(f,n.alpha),e.sub(e.sub(l,s),f)}function zd(o,t,n,a,i){const e=o.G1,l=o.Fr;let s=e.timesFr(a.Qm,l.mul(t.eval_a,t.eval_b));s=e.add(s,e.timesFr(a.Ql,t.eval_a)),s=e.add(s,e.timesFr(a.Qr,t.eval_b)),s=e.add(s,e.timesFr(a.Qo,t.eval_c)),s=e.add(s,a.Qc);const h=l.mul(n.beta,n.xi),d=l.add(l.add(t.eval_a,h),n.gamma),c=l.add(l.add(t.eval_b,l.mul(h,a.k1)),n.gamma),f=l.add(l.add(t.eval_c,l.mul(h,a.k2)),n.gamma),y=l.mul(l.mul(l.mul(d,c),f),n.alpha),L=l.mul(i,l.square(n.alpha)),v=e.timesFr(t.Z,l.add(l.add(y,L),n.u)),T=l.add(l.add(t.eval_a,l.mul(n.beta,t.eval_s1)),n.gamma),B=l.add(l.add(t.eval_b,l.mul(n.beta,t.eval_s2)),n.gamma),E=l.mul(l.mul(n.alpha,n.beta),t.eval_zw),A=e.timesFr(a.S3,l.mul(l.mul(T,B),E)),G=t.T1,P=e.timesFr(t.T2,n.xin),U=e.timesFr(t.T3,l.square(n.xin));let I=e.add(G,e.add(P,U));return I=e.timesFr(I,n.zh),e.sub(e.sub(e.add(s,v),A),I)}function qd(o,t,n,a,i){const e=o.G1;let l=e.add(i,e.timesFr(t.A,n.v[1]));return l=e.add(l,e.timesFr(t.B,n.v[2])),l=e.add(l,e.timesFr(t.C,n.v[3])),l=e.add(l,e.timesFr(a.S1,n.v[4])),l=e.add(l,e.timesFr(a.S2,n.v[5])),l}function Qd(o,t,n,a){const i=o.G1,e=o.Fr;let l=e.add(e.neg(a),e.mul(n.v[1],t.eval_a));return l=e.add(l,e.mul(n.v[2],t.eval_b)),l=e.add(l,e.mul(n.v[3],t.eval_c)),l=e.add(l,e.mul(n.v[4],t.eval_s1)),l=e.add(l,e.mul(n.v[5],t.eval_s2)),l=e.add(l,e.mul(n.u,t.eval_zw)),i.timesFr(i.one,l)}async function Rd(o,t,n,a,i,e){const l=o.G1,s=o.Fr;let h=t.Wxi;h=l.add(h,l.timesFr(t.Wxiw,n.u));let d=l.timesFr(t.Wxi,n.xi);const c=s.mul(s.mul(n.u,n.xi),s.w[a.power]);return d=l.add(d,l.timesFr(t.Wxiw,c)),d=l.add(d,e),d=l.sub(d,i),await o.pairingEq(l.neg(h),a.X_2,d,o.G2.one)}const{unstringifyBigInts:wo}=cn;function Jt(o){let t=o.toString(16);for(;t.length<64;)t="0"+t;return t=`"0x${t}"`,t}async function kd(o,t){const n=wo(o),a=wo(t);await ta(n.curve);let i="";for(let e=0;e<a.length;e++)i!=""&&(i=i+","),i=i+Jt(a[e]);return`[${Jt(n.A[0])}, ${Jt(n.A[1])},${Jt(n.B[0])},${Jt(n.B[1])},${Jt(n.C[0])},${Jt(n.C[1])},${Jt(n.Z[0])},${Jt(n.Z[1])},${Jt(n.T1[0])},${Jt(n.T1[1])},${Jt(n.T2[0])},${Jt(n.T2[1])},${Jt(n.T3[0])},${Jt(n.T3[1])},${Jt(n.Wxi[0])},${Jt(n.Wxi[1])},${Jt(n.Wxiw[0])},${Jt(n.Wxiw[1])},${Jt(n.eval_a)},${Jt(n.eval_b)},${Jt(n.eval_c)},${Jt(n.eval_s1)},${Jt(n.eval_s2)},${Jt(n.eval_zw)}][${i}]`}var mu=Object.freeze({__proto__:null,setup:md,fullProve:Sd,prove:Ps,verify:xd,exportSolidityCallData:kd});function Lo(o,t){return[o,0,0,t.one,t.zero,t.zero,t.zero,t.zero]}function $d(o,t,n,a,i,e,l,s){return[o,t,n,a,i,e,l,s]}function Nd(o,t,n,a,i,e,l,s,h){return[o,t,n,a,i,e,l,s]}const Ti=0,Oi=1,Dd=2;class Vd{constructor(t,n,a,i,e){this.Fr=t,this.logger=e,this.fnGetAdditionConstraint=a,this.fnGetMultiplicationConstraint=i}processR1csConstraint(t,n,a,i){this.normalizeLinearCombination(n),this.normalizeLinearCombination(a),this.normalizeLinearCombination(i);const e=this.getLinearCombinationType(n),l=this.getLinearCombinationType(a);if(e===Ti||l===Ti)return this.processR1csAdditionConstraint(t,i);if(e===Oi){const s=this.joinLinearCombinations(a,i,n[0]);return this.processR1csAdditionConstraint(t,s)}else if(l===Oi){const s=this.joinLinearCombinations(n,i,a[0]);return this.processR1csAdditionConstraint(t,s)}else return this.processR1csMultiplicationConstraint(t,n,a,i)}getLinearCombinationType(t){let n=this.Fr.zero,a=0;const i=Object.keys(t);for(let e=0;e<i.length;e++)t[i[e]]==0n?delete t[i[e]]:i[e]==0?n=this.Fr.add(n,t[i[e]]):a++;return a>0?Dd:this.Fr.isZero(n)?Ti:Oi}normalizeLinearCombination(t){const n=Object.keys(t);for(let a=0;a<n.length;a++)this.Fr.isZero(t[n[a]])&&delete t[n[a]];return t}joinLinearCombinations(t,n,a){const i={};for(let e in t)typeof i[e]>"u"?i[e]=this.Fr.mul(a,t[e]):i[e]=this.Fr.add(i[e],this.Fr.mul(a,t[e]));for(let e in n)typeof i[e]>"u"?i[e]=n[e]:i[e]=this.Fr.add(i[e],n[e]);return this.normalizeLinearCombination(i)}reduceCoefs(t,n,a,i,e){const l={k:this.Fr.zero,signals:[],coefs:[]},s=[];for(let h in i)h==0?l.k=this.Fr.add(l.k,i[h]):i[h]!=0n&&s.push([Number(h),i[h]]);for(;s.length>e;){const h=s.shift(),d=s.shift(),c=t.nVars++,f=this.fnGetAdditionConstraint(h[0],d[0],c,this.Fr.neg(h[1]),this.Fr.neg(d[1]),this.Fr.zero,this.Fr.one,this.Fr.zero);n.push(f),a.push([h[0],d[0],h[1],d[1]]),s.push([c,this.Fr.one])}for(let h=0;h<s.length;h++)l.signals[h]=s[h][0],l.coefs[h]=s[h][1];for(;l.coefs.length<e;)l.signals.push(0),l.coefs.push(this.Fr.zero);return l}processR1csAdditionConstraint(t,n){const a=[],i=[],e=this.reduceCoefs(t,a,i,n,3),l=this.fnGetAdditionConstraint(e.signals[0],e.signals[1],e.signals[2],e.coefs[0],e.coefs[1],this.Fr.zero,e.coefs[2],e.k);return a.push(l),[a,i]}processR1csMultiplicationConstraint(t,n,a,i){const e=[],l=[],s=this.reduceCoefs(t,e,l,n,1),h=this.reduceCoefs(t,e,l,a,1),d=this.reduceCoefs(t,e,l,i,1),c=this.fnGetMultiplicationConstraint(s.signals[0],h.signals[0],d.signals[0],this.Fr.mul(s.coefs[0],h.k),this.Fr.mul(s.k,h.coefs[0]),this.Fr.mul(s.coefs[0],h.coefs[0]),this.Fr.neg(d.coefs[0]),this.Fr.sub(this.Fr.mul(s.k,h.k),d.k));return e.push(c),[e,l]}}class ie{constructor(t,n,a){this.n=t,this.polynomials=Array(t).fill(void 0),this.curve=n,this.Fr=n.Fr,this.G1=n.G1,this.logger=a}addPolynomial(t,n){if(t>this.n-1)throw new Error("CPolynomial:addPolynomial, cannot add a polynomial to a position greater than n-1");this.polynomials[t]=n}degree(){let t=this.polynomials.map((n,a)=>n===void 0?0:n.degree()*this.n+a);return Math.max(...t)}getPolynomial(){let t=this.polynomials.map(l=>l===void 0?0:l.degree());const n=this.degree(),a=2**(Vn(n-1)+1),i=this.Fr.n8;let e=new yt(new ft(a*i),this.curve,this.logger);for(let l=0;l<n;l++){const s=l*i,h=s*this.n;for(let d=0;d<this.n;d++)this.polynomials[d]!==void 0&&l<=t[d]&&e.coef.set(this.polynomials[d].coef.slice(s,s+i),h+d*i)}return e}async multiExponentiation(t,n){let a=this.getPolynomial();const i=a.coef.byteLength/this.Fr.n8,e=t.slice(0,i*this.G1.F.n8*2),l=await this.Fr.batchFromMontgomery(a.coef);let s=await this.G1.multiExpAffine(e,l,this.logger,n);return s=this.G1.toAffine(s),s}}async function Hd(o,t,n,a){a&&a.info("FFLONK SETUP STARTED"),globalThis.gc&&globalThis.gc(),a&&a.info("> Reading PTau file");const{fd:i,sections:e}=await Kt(t,"ptau",1);if(!e[12])throw new Error("Powers of Tau is not well prepared. Section 12 missing.");a&&a.info("> Getting curve from PTau settings");const{curve:l}=await mn(i,e);a&&a.info("> Reading r1cs file");const{fd:s,sections:h}=await Kt(o,"r1cs",1),d=await ri(s,h,{loadConstraints:!1,loadCustomGates:!0});if(d.prime!==l.r)throw new Error("r1cs curve does not match powers of tau ceremony curve");const c=l.Fr,f=l.Fr.n8,y=l.G1.F.n8*2,L=l.G2.F.n8*2;let v={},T={},B,E={nVars:d.nVars,nPublic:d.nOutputs+d.nPubInputs};const A=new wn;let G=new wn;if(a&&a.info("> Processing FFlonk constraints"),await K(l.Fr,d,a),globalThis.gc&&globalThis.gc(),E.cirPower=Math.max(ir,Vn(A.length+2-1)+1),E.domainSize=2**E.cirPower,e[2][0].size<(E.domainSize*9+18)*y)throw new Error("Powers of Tau is not big enough for this circuit size. Section 2 too small.");if(e[3][0].size<L)throw new Error("Powers of Tau is not well prepared. Section 3 too small.");a&&(a.info("----------------------------"),a.info("  FFLONK SETUP SETTINGS"),a.info(`  Curve:         ${l.name}`),a.info(`  Circuit power: ${E.cirPower}`),a.info(`  Domain size:   ${E.domainSize}`),a.info(`  Vars:          ${E.nVars}`),a.info(`  Public vars:   ${E.nPublic}`),a.info(`  Constraints:   ${A.length}`),a.info(`  Additions:     ${G.length}`),a.info("----------------------------")),a&&a.info("> computing k1 and k2");const[P,U]=X();a&&a.info("> computing w3");const I=k();a&&a.info("> computing w4");const _=J();a&&a.info("> computing w8");const b=m();a&&a.info("> computing wr");const $=r(E.cirPower,l.Fr);return await j(),await s.close(),await i.close(),a&&a.info("FFLONK SETUP FINISHED"),0;async function K(C,u,x){for(let H=0;H<E.nPublic;H++)A.push(Lo(H+1,C));const F=new Vd(C,Lo,$d,Nd,x),p=await Vt(s,h,2);let O=0;for(let H=0;H<u.nConstraints;H++){x&&H!==0&&H%5e5===0&&x.info(`    processing r1cs constraints ${H}/${u.nConstraints}`);const[lt,ht]=F.processR1csConstraint(E,...R());A.push(...lt),G.push(...ht)}function R(){const H=[];return H[0]=N(),H[1]=N(),H[2]=N(),H}function N(){const H={},lt=p.slice(O,O+4);O+=4;const pt=new DataView(lt.buffer).getUint32(0,!0),ut=p.slice(O,O+(4+u.n8)*pt);O+=(4+u.n8)*pt;const st=new DataView(ut.buffer);for(let ct=0;ct<pt;ct++){const Lt=st.getUint32(ct*(4+u.n8),!0),At=u.F.fromRprLE(ut,ct*(4+u.n8)+4);H[Lt]=At}return H}return 0}async function j(){a&&a.info("> Writing the zkey file");const C=await fn(n,"zkey",1,er,1<<22,1<<24);a&&a.info(` Writing Section ${ro}. Zkey Header`),await M(C),a&&a.info(` Writing Section ${ti}. Additions`),await S(C),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Wi}. A Map`),await z(C,Wi,0,"A map"),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Yi}. B Map`),await z(C,Yi,1,"B map"),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Xi}. C Map`),await z(C,Xi,2,"C map"),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Fa}. QL`),await q(C,Fa,3,"QL"),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Ba}. QR`),await q(C,Ba,4,"QR"),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Sa}. QM`),await q(C,Sa,5,"QM"),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${xa}. QO`),await q(C,xa,6,"QO"),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${va}. QC`),await q(C,va,7,"QC"),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Sections ${Ga},${Pa},${Ta}. Sigma1, Sigma2 & Sigma 3`),await Z(C),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Ji}. Lagrange Polynomials`),await Y(C),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${ni}. Powers of Tau`),await V(C),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${te}. C0`),await nt(C),globalThis.gc&&globalThis.gc(),a&&a.info(` Writing Section ${Zi}. FFlonk Header`),await Q(C),globalThis.gc&&globalThis.gc(),a&&a.info("> Writing the zkey file finished"),await C.close()}async function M(C){await Rt(C,ro),await C.writeULE32(Qa),await kt(C)}async function S(C){await Rt(C,ti);const u=new Uint8Array(8+2*f),x=new DataView(u.buffer);for(let F=0;F<G.length;F++){a&&F!==0&&F%5e5===0&&a.info(`      writing Additions: ${F}/${G.length}`);const p=G[F];x.setUint32(0,p[0],!0),x.setUint32(4,p[1],!0),u.set(p[2],8),u.set(p[3],8+f),await C.write(u)}await kt(C)}async function z(C,u,x,F){await Rt(C,u);for(let p=0;p<A.length;p++)a&&p!==0&&p%5e5===0&&a.info(`      writing witness ${F}: ${p}/${A.length}`),await C.writeULE32(A[p][x]);await kt(C)}async function q(C,u,x,F){let p=new ft(E.domainSize*f);for(let O=0;O<A.length;O++)p.set(A[O][x],O*f),a&&O!==0&&O%5e5===0&&a.info(`      writing ${F}: ${O}/${A.length}`);v[F]=await yt.fromEvaluations(p,l,a),T[F]=await Xt.fromPolynomial(v[F],4,l,a),await Rt(C,u),await C.write(v[F].coef),await C.write(T[F].eval),await kt(C)}async function Z(C){const u=new ft(f*E.domainSize*3),x=new wn(E.nVars),F=new wn(E.nVars);let p=c.one;for(let R=0;R<E.domainSize;R++)R<A.length?(O(A[R][0],R),O(A[R][1],E.domainSize+R),O(A[R][2],E.domainSize*2+R)):R<E.domainSize-2?(O(0,R),O(0,E.domainSize+R),O(0,E.domainSize*2+R)):(u.set(p,R*f),u.set(c.mul(p,P),(E.domainSize+R)*f),u.set(c.mul(p,U),(E.domainSize*2+R)*f)),p=c.mul(p,c.w[E.cirPower]),a&&R!==0&&R%5e5===0&&a.info(`      writing sigma phase1: ${R}/${A.length}`);for(let R=0;R<E.nVars;R++)typeof F[R]<"u"?u.set(x[R],F[R]*f):console.log("Variable not used"),a&&R!==0&&R%5e5===0&&a.info(`      writing sigma phase2: ${R}/${E.nVars}`);globalThis.gc&&globalThis.gc();for(let R=0;R<3;R++){const N=R===0?Ga:R===1?Pa:Ta;let H="S"+(R+1);v[H]=await yt.fromEvaluations(u.slice(E.domainSize*f*R,E.domainSize*f*(R+1)),l,a),T[H]=await Xt.fromPolynomial(v[H],4,l,a),await Rt(C,N),await C.write(v[H].coef),await C.write(T[H].eval),await kt(C),globalThis.gc&&globalThis.gc()}return 0;function O(R,N){typeof x[R]>"u"?F[R]=N:u.set(x[R],N*f);let H;N<E.domainSize?H=p:N<2*E.domainSize?H=c.mul(p,P):H=c.mul(p,U),x[R]=H}}async function Y(C){await Rt(C,Ji);const u=Math.max(E.nPublic,1);for(let x=0;x<u;x++){let F=new ft(E.domainSize*f);F.set(c.one,x*f),await it(C,F)}await kt(C)}async function V(C){await Rt(C,ni),B=new ft((E.domainSize*9+18)*y),await i.readToBuffer(B,0,(E.domainSize*9+18)*y,e[2][0].p),await C.write(B),await kt(C)}async function nt(C){let u=new ie(8,l,a);if(u.addPolynomial(0,v.QL),u.addPolynomial(1,v.QR),u.addPolynomial(2,v.QO),u.addPolynomial(3,v.QM),u.addPolynomial(4,v.QC),u.addPolynomial(5,v.S1),u.addPolynomial(6,v.S2),u.addPolynomial(7,v.S3),v.C0=u.getPolynomial(),v.C0.degree()>=8*E.domainSize)throw new Error("C0 Polynomial is not well calculated");await Rt(C,te),await C.write(v.C0.coef),await kt(C)}async function Q(C){await Rt(C,Zi);const u=l.q,x=(Math.floor((Ft.bitLength(u)-1)/64)+1)*8;await C.writeULE32(x),await An(C,u,x);const F=l.r,p=(Math.floor((Ft.bitLength(F)-1)/64)+1)*8;await C.writeULE32(p),await An(C,F,p),await C.writeULE32(E.nVars),await C.writeULE32(E.nPublic),await C.writeULE32(E.domainSize),await C.writeULE32(G.length),await C.writeULE32(A.length),await C.write(P),await C.write(U),await C.write(I),await C.write(_),await C.write(b),await C.write($);let O;O=await i.read(L,e[3][0].p+L),await C.write(O);let R=await v.C0.multiExponentiation(B,"C0");await C.write(R),await kt(C)}async function it(C,u){const[x,F]=await yt.to4T(u,E.domainSize,[],c);return await C.write(x),await C.write(F),[x,F]}function X(){let C=c.two;for(;x(C,[],E.cirPower);)c.add(C,c.one);let u=c.add(C,c.one);for(;x(u,[C],E.cirPower);)c.add(u,c.one);return[C,u];function x(F,p,O){const R=2**O;let N=c.one;for(let H=0;H<R;H++){if(c.eq(F,N))return!0;for(let lt=0;lt<p.length;lt++)if(c.eq(F,c.mul(p[lt],N)))return!0;N=c.mul(N,c.w[O])}return!1}}function k(){let C=c.e(31624),x=Ft.div(3648040478639879203707734290876212514758060733402672390616367364429301415936n,Ft.e(3));return c.exp(C,x)}function J(){return c.w[2]}function m(){return c.w[3]}function r(C,u){const x=u.e(467799165886069610036046866799264026481344299079011762026774533774345988080n);return u.exp(x,2**(28-C))}}const{stringifyBigInts:mo}=cn;async function Ts(o,t,n,a){n&&n.info("FFLONK PROVER STARTED"),n&&n.info("> Reading witness file");const{fd:i,sections:e}=await Kt(t,"wtns",2),l=await Ra(i,e);n&&n.info("> Reading zkey file");const{fd:s,sections:h}=await Kt(o,"zkey",2),d=await yn(s,h,void 0,a);if(d.protocolId!==Qa)throw new Error("zkey file is not fflonk");if(!Ft.eq(d.r,l.q))throw new Error("Curve of the witness does not match the curve of the proving key");if(l.nWitness!==d.nVars-d.nAdditions)throw new Error(`Invalid witness length. Circuit: ${d.nVars}, witness: ${l.nWitness}, ${d.nAdditions}`);const c=d.curve,f=c.Fr,y=c.Fr.n8,L=c.G1.F.n8*2,v=d.domainSize*y;n&&(n.info("----------------------------"),n.info("  FFLONK PROVE SETTINGS"),n.info(`  Curve:         ${c.name}`),n.info(`  Circuit power: ${d.power}`),n.info(`  Domain size:   ${d.domainSize}`),n.info(`  Vars:          ${d.nVars}`),n.info(`  Public vars:   ${d.nPublic}`),n.info(`  Constraints:   ${d.nConstraints}`),n.info(`  Additions:     ${d.nAdditions}`),n.info("----------------------------")),n&&n.info("> Reading witness file data");const T=await Vt(i,e,2);await i.close(),T.set(f.zero,0);const B=new ft(d.nAdditions*y);let E={},A={},G={},P={},U={},I={},_=new Ce(c,n);n&&n.info(`> Reading Section ${ti}. Additions`),await j(),n&&n.info(`> Reading Sections ${Ga},${Pa},${Ta}. Sigma1, Sigma2 & Sigma 3`),n&&n.info(" Reading Sigma polynomials "),A.Sigma1=new yt(new ft(v),c,n),A.Sigma2=new yt(new ft(v),c,n),A.Sigma3=new yt(new ft(v),c,n),await s.readToBuffer(A.Sigma1.coef,0,v,h[Ga][0].p),await s.readToBuffer(A.Sigma2.coef,0,v,h[Pa][0].p),await s.readToBuffer(A.Sigma3.coef,0,v,h[Ta][0].p),n&&n.info(" Reading Sigma evaluations"),G.Sigma1=new Xt(new ft(v*4),c,n),G.Sigma2=new Xt(new ft(v*4),c,n),G.Sigma3=new Xt(new ft(v*4),c,n),await s.readToBuffer(G.Sigma1.eval,0,v*4,h[Ga][0].p+v),await s.readToBuffer(G.Sigma2.eval,0,v*4,h[Pa][0].p+v),await s.readToBuffer(G.Sigma3.eval,0,v*4,h[Ta][0].p+v),n&&n.info(`> Reading Section ${ni}. Powers of Tau`);const b=new ft(d.domainSize*16*L);await s.readToBuffer(b,0,(d.domainSize*9+18)*L,h[ni][0].p),globalThis.gc&&globalThis.gc(),n&&n.info(""),n&&n.info("> ROUND 1"),await z(),delete A.T0,delete G.QL,delete G.QR,delete G.QM,delete G.QO,delete G.QC,globalThis.gc&&globalThis.gc(),n&&n.info("> ROUND 2"),await q(),delete E.A,delete E.B,delete E.C,delete G.A,delete G.B,delete G.C,delete G.Sigma1,delete G.Sigma2,delete G.Sigma3,delete G.lagrange1,delete G.Z,globalThis.gc&&globalThis.gc(),n&&n.info("> ROUND 3"),await Z(),delete A.A,delete A.B,delete A.C,delete A.Z,delete A.T1,delete A.T2,delete A.Sigma1,delete A.Sigma2,delete A.Sigma3,delete A.QL,delete A.QR,delete A.QM,delete A.QC,delete A.QO,globalThis.gc&&globalThis.gc(),n&&n.info("> ROUND 4"),await Y(),globalThis.gc&&globalThis.gc(),n&&n.info("> ROUND 5"),await V(),delete A.C0,delete A.C1,delete A.C2,delete A.R1,delete A.R2,delete A.F,delete A.L,delete A.ZT,delete A.ZTS2,await s.close(),globalThis.gc&&globalThis.gc(),_.addEvaluation("inv",nt());let $=_.toObjectProof();$.protocol="fflonk",$.curve=c.name;let K=[];for(let Q=1;Q<=d.nPublic;Q++){const it=Q*y,X=T.slice(it,it+y);K.push(Ft.fromRprLE(X))}return n&&n.info("FFLONK PROVER FINISHED"),{proof:mo($),publicSignals:mo(K)};async function j(){n&&n.info(" Computing additions");const Q=await Vt(s,h,ti),it=8+y*2;for(let X=0;X<d.nAdditions;X++){n&&X!==0&&X%1e5===0&&n.info(`    addition ${X}/${d.nAdditions}`);let k=X*it;const J=M(Q,k);k+=4;const m=M(Q,k);k+=4;const r=Q.slice(k,k+y);k+=y;const C=Q.slice(k,k+y),u=S(J),x=S(m),F=f.add(f.mul(r,u),f.mul(C,x));B.set(F,y*X)}}function M(Q,it){const X=Q.slice(it,it+4);return new DataView(X.buffer,X.byteOffset,X.byteLength).getUint32(0,!0)}function S(Q){let it=d.nVars-d.nAdditions;if(Q<it)return T.slice(Q*y,Q*y+y);if(Q<d.nVars){const X=(Q-it)*y;return B.slice(X,X+y)}return f.zero}async function z(){U.b=[];for(let J=1;J<=9;J++)U.b[J]=f.random();n&&n.info("> Computing A, B, C wire polynomials"),await it(),n&&n.info("> Computing T0 polynomial"),await X(),n&&n.info("> Computing C1 polynomial"),await k(),n&&n.info("> Computing C1 multi exponentiation");let Q=await A.C1.multiExponentiation(b,"C1");return _.addPolynomial("C1",Q),0;async function it(){n&&n.info(" Reading data from zkey file"),E.A=new ft(v),E.B=new ft(v),E.C=new ft(v);const J=await Vt(s,h,Wi),m=await Vt(s,h,Yi),r=await Vt(s,h,Xi);for(let C=0;C<d.nConstraints;C++){const u=C*y,x=C*4,F=M(J,x);E.A.set(S(F),u);const p=M(m,x);E.B.set(S(p),u);const O=M(r,x);E.C.set(S(O),u)}if(E.A.set(U.b[1],v-64),E.A.set(U.b[2],v-32),E.B.set(U.b[3],v-64),E.B.set(U.b[4],v-32),E.C.set(U.b[5],v-64),E.C.set(U.b[6],v-32),E.A=await f.batchToMontgomery(E.A),E.B=await f.batchToMontgomery(E.B),E.C=await f.batchToMontgomery(E.C),n&&n.info(" Computing A ifft"),A.A=await yt.fromEvaluations(E.A,c,n),n&&n.info(" Computing B ifft"),A.B=await yt.fromEvaluations(E.B,c,n),n&&n.info(" Computing C ifft"),A.C=await yt.fromEvaluations(E.C,c,n),n&&n.info(" Computing A fft"),G.A=await Xt.fromPolynomial(A.A,4,c,n),n&&n.info(" Computing B fft"),G.B=await Xt.fromPolynomial(A.B,4,c,n),n&&n.info(" Computing C fft"),G.C=await Xt.fromPolynomial(A.C,4,c,n),A.A.degree()>=d.domainSize)throw new Error("A Polynomial is not well calculated");if(A.B.degree()>=d.domainSize)throw new Error("B Polynomial is not well calculated");if(A.C.degree()>=d.domainSize)throw new Error("C Polynomial is not well calculated")}async function X(){n&&n.info(` Reading sections ${Fa}, ${Ba}, ${Sa}, ${xa}, ${va}. Q selectors`),G.QL=new Xt(new ft(v*4),c,n),G.QR=new Xt(new ft(v*4),c,n),G.QM=new Xt(new ft(v*4),c,n),G.QO=new Xt(new ft(v*4),c,n),G.QC=new Xt(new ft(v*4),c,n),await s.readToBuffer(G.QL.eval,0,v*4,h[Fa][0].p+v),await s.readToBuffer(G.QR.eval,0,v*4,h[Ba][0].p+v),await s.readToBuffer(G.QM.eval,0,v*4,h[Sa][0].p+v),await s.readToBuffer(G.QO.eval,0,v*4,h[xa][0].p+v),await s.readToBuffer(G.QC.eval,0,v*4,h[va][0].p+v);const J=await Vt(s,h,Ji);G.lagrange1=new Xt(J,c,n),E.T0=new ft(v*4),n&&n.info(" Computing T0 evaluations");for(let m=0;m<d.domainSize*4;m++){n&&m!==0&&m%1e5===0&&n.info(`      T0 evaluation ${m}/${d.domainSize*4}`);const r=G.A.getEvaluation(m),C=G.B.getEvaluation(m),u=G.C.getEvaluation(m),x=G.QL.getEvaluation(m),F=G.QR.getEvaluation(m),p=G.QM.getEvaluation(m),O=G.QO.getEvaluation(m),R=G.QC.getEvaluation(m);let N=f.zero;for(let st=0;st<d.nPublic;st++){const ct=st*5*d.domainSize+d.domainSize+m,Lt=G.lagrange1.getEvaluation(ct),At=E.A.slice(st*y,(st+1)*y);N=f.sub(N,f.mul(Lt,At))}const H=f.mul(r,x),lt=f.mul(C,F),ht=f.mul(f.mul(r,C),p),pt=f.mul(u,O),ut=f.add(H,f.add(lt,f.add(ht,f.add(pt,f.add(R,N)))));E.T0.set(ut,m*y)}if(n&&n.info("buffer T0: "+E.T0.byteLength/y),n&&n.info(" Computing T0 ifft"),A.T0=await yt.fromEvaluations(E.T0,c,n),n&&n.info("T0 length: "+A.T0.length()),n&&n.info("T0 degree: "+A.T0.degree()),n&&n.info(" Computing T0 / ZH"),A.T0.divByZerofier(d.domainSize,f.one),A.T0.degree()>=2*d.domainSize-2)throw new Error(`T0 Polynomial is not well calculated (degree is ${A.T0.degree()} and must be less than ${2*d.domainSize+2}`);delete E.T0}async function k(){let J=new ie(4,c,n);if(J.addPolynomial(0,A.A),J.addPolynomial(1,A.B),J.addPolynomial(2,A.C),J.addPolynomial(3,A.T0),A.C1=J.getPolynomial(),A.C1.degree()>=8*d.domainSize-8)throw new Error("C1 Polynomial is not well calculated")}}async function q(){n&&n.info("> Computing challenges beta and gamma");const Q=new Yn(c);Q.addPolCommitment(d.C0);for(let r=0;r<d.nPublic;r++)Q.addScalar(E.A.slice(r*y,r*y+y));Q.addPolCommitment(_.getPolynomial("C1")),U.beta=Q.getChallenge(),n&&n.info(" challenges.beta: "+f.toString(U.beta)),Q.reset(),Q.addScalar(U.beta),U.gamma=Q.getChallenge(),n&&n.info(" challenges.gamma: "+f.toString(U.gamma)),n&&n.info("> Computing Z polynomial"),await X(),n&&n.info("> Computing T1 polynomial"),await k(),n&&n.info("> Computing T2 polynomial"),await J(),n&&n.info("> Computing C2 polynomial"),await m(),n&&n.info("> Computing C2 multi exponentiation");let it=await A.C2.multiExponentiation(b,"C2");return _.addPolynomial("C2",it),0;async function X(){n&&n.info(" Computing Z evaluations");let r=new ft(v),C=new ft(v);r.set(f.one,0),C.set(f.one,0);let u=f.one;for(let x=0;x<d.domainSize;x++){n&&x!==0&&x%1e5===0&&n.info(`    Z evaluation ${x}/${d.domainSize}`);const F=x*y,p=f.mul(U.beta,u);let O=E.A.slice(F,F+y);O=f.add(O,p),O=f.add(O,U.gamma);let R=E.B.slice(F,F+y);R=f.add(R,f.mul(d.k1,p)),R=f.add(R,U.gamma);let N=E.C.slice(F,F+y);N=f.add(N,f.mul(d.k2,p)),N=f.add(N,U.gamma);let H=f.mul(O,f.mul(R,N)),lt=E.A.slice(F,F+y);lt=f.add(lt,f.mul(U.beta,G.Sigma1.getEvaluation(x*4))),lt=f.add(lt,U.gamma);let ht=E.B.slice(F,F+y);ht=f.add(ht,f.mul(U.beta,G.Sigma2.getEvaluation(x*4))),ht=f.add(ht,U.gamma);let pt=E.C.slice(F,F+y);pt=f.add(pt,f.mul(U.beta,G.Sigma3.getEvaluation(x*4))),pt=f.add(pt,U.gamma);let ut=f.mul(lt,f.mul(ht,pt));H=f.mul(r.slice(F,F+y),H),r.set(H,(x+1)%d.domainSize*y),ut=f.mul(C.slice(F,F+y),ut),C.set(ut,(x+1)%d.domainSize*y),u=f.mul(u,f.w[d.power])}C=await f.batchInverse(C);for(let x=0;x<d.domainSize;x++){const F=x*y,p=f.mul(r.slice(F,F+y),C.slice(F,F+y));r.set(p,F)}if(E.Z=r,!f.eq(r.slice(0,y),f.one))throw new Error("Copy constraints does not match");if(n&&n.info(" Computing Z ifft"),A.Z=await yt.fromEvaluations(E.Z,c,n),n&&n.info(" Computing Z fft"),G.Z=await Xt.fromPolynomial(A.Z,4,c,n),A.Z.blindCoefficients([U.b[9],U.b[8],U.b[7]]),A.Z.degree()>=d.domainSize+3)throw new Error("Z Polynomial is not well calculated");delete E.Z}async function k(){n&&n.info(" Computing T1 evaluations"),E.T1=new ft(v*2),E.T1z=new ft(v*2);let r=f.one;for(let C=0;C<d.domainSize*2;C++){n&&C!==0&&C%1e5===0&&n.info(`    T1 evaluation ${C}/${d.domainSize*4}`);const u=f.square(r),x=G.Z.getEvaluation(C*2),F=f.add(f.add(f.mul(U.b[7],u),f.mul(U.b[8],r)),U.b[9]),p=G.lagrange1.getEvaluation(d.domainSize+C*2);let O=f.mul(f.sub(x,f.one),p),R=f.mul(F,p);E.T1.set(O,C*y),E.T1z.set(R,C*y),r=f.mul(r,f.w[d.power+1])}if(n&&n.info(" Computing T1 ifft"),A.T1=await yt.fromEvaluations(E.T1,c,n),A.T1.divByZerofier(d.domainSize,f.one),n&&n.info(" Computing T1z ifft"),A.T1z=await yt.fromEvaluations(E.T1z,c,n),A.T1.add(A.T1z),A.T1.degree()>=d.domainSize+2)throw new Error("T1 Polynomial is not well calculated");delete E.T1,delete E.T1z,delete A.T1z}async function J(){n&&n.info(" Computing T2 evaluations"),E.T2=new ft(v*4),E.T2z=new ft(v*4);let r=f.one;for(let C=0;C<d.domainSize*4;C++){n&&C!==0&&C%1e5===0&&n.info(`    T2 evaluation ${C}/${d.domainSize*4}`);const u=f.square(r),x=f.mul(r,f.w[d.power]),F=f.square(x),p=G.A.getEvaluation(C),O=G.B.getEvaluation(C),R=G.C.getEvaluation(C),N=G.Z.getEvaluation(C),H=G.Z.getEvaluation((d.domainSize*4+4+C)%(d.domainSize*4)),lt=f.add(f.add(f.mul(U.b[7],u),f.mul(U.b[8],r)),U.b[9]),ht=f.add(f.add(f.mul(U.b[7],F),f.mul(U.b[8],x)),U.b[9]),pt=G.Sigma1.getEvaluation(C),ut=G.Sigma2.getEvaluation(C),st=G.Sigma3.getEvaluation(C),ct=f.mul(U.beta,r);let Lt=f.add(p,ct);Lt=f.add(Lt,U.gamma);let At=f.add(O,f.mul(ct,d.k1));At=f.add(At,U.gamma);let Bt=f.add(R,f.mul(ct,d.k2));Bt=f.add(Bt,U.gamma);let Mt=f.mul(f.mul(f.mul(Lt,At),Bt),N),$t=f.mul(f.mul(f.mul(Lt,At),Bt),lt),Dt=f.add(p,f.mul(U.beta,pt));Dt=f.add(Dt,U.gamma);let vt=f.add(O,f.mul(U.beta,ut));vt=f.add(vt,U.gamma);let bt=f.add(R,f.mul(U.beta,st));bt=f.add(bt,U.gamma);let qt=f.mul(f.mul(f.mul(Dt,vt),bt),H),Yt=f.mul(f.mul(f.mul(Dt,vt),bt),ht),Ht=f.sub(Mt,qt),ot=f.sub($t,Yt);E.T2.set(Ht,C*y),E.T2z.set(ot,C*y),r=f.mul(r,f.w[d.power+2])}if(n&&n.info(" Computing T2 ifft"),A.T2=await yt.fromEvaluations(E.T2,c,n),n&&n.info(" Computing T2 / ZH"),A.T2.divByZerofier(d.domainSize,f.one),n&&n.info(" Computing T2z ifft"),A.T2z=await yt.fromEvaluations(E.T2z,c,n),A.T2.add(A.T2z),A.T2.degree()>=3*d.domainSize)throw new Error("T2 Polynomial is not well calculated");delete E.T2,delete E.T2z,delete A.T2z}async function m(){let r=new ie(3,c,n);if(r.addPolynomial(0,A.Z),r.addPolynomial(1,A.T1),r.addPolynomial(2,A.T2),A.C2=r.getPolynomial(),A.C2.degree()>=9*d.domainSize)throw new Error("C2 Polynomial is not well calculated")}}async function Z(){n&&n.info("> Computing challenge xi");const Q=new Yn(c);Q.addScalar(U.gamma),Q.addPolCommitment(_.getPolynomial("C2")),U.xiSeed=Q.getChallenge();const it=f.square(U.xiSeed);I.w8=[],I.w8[0]=f.one;for(let X=1;X<8;X++)I.w8[X]=f.mul(I.w8[X-1],d.w8);I.w4=[],I.w4[0]=f.one;for(let X=1;X<4;X++)I.w4[X]=f.mul(I.w4[X-1],d.w4);I.w3=[],I.w3[0]=f.one,I.w3[1]=d.w3,I.w3[2]=f.square(d.w3),I.S0={},I.S0.h0w8=[],I.S0.h0w8[0]=f.mul(it,U.xiSeed);for(let X=1;X<8;X++)I.S0.h0w8[X]=f.mul(I.S0.h0w8[0],I.w8[X]);I.S1={},I.S1.h1w4=[],I.S1.h1w4[0]=f.square(I.S0.h0w8[0]);for(let X=1;X<4;X++)I.S1.h1w4[X]=f.mul(I.S1.h1w4[0],I.w4[X]);I.S2={},I.S2.h2w3=[],I.S2.h2w3[0]=f.mul(I.S1.h1w4[0],it),I.S2.h2w3[1]=f.mul(I.S2.h2w3[0],I.w3[1]),I.S2.h2w3[2]=f.mul(I.S2.h2w3[0],I.w3[2]),I.S2.h3w3=[],I.S2.h3w3[0]=f.mul(I.S2.h2w3[0],d.wr),I.S2.h3w3[1]=f.mul(I.S2.h3w3[0],I.w3[1]),I.S2.h3w3[2]=f.mul(I.S2.h3w3[0],I.w3[2]),U.xi=f.mul(f.square(I.S2.h2w3[0]),I.S2.h2w3[0]),n&&n.info(" challenges.xi: "+f.toString(U.xi)),A.QL=new yt(new ft(v),c,n),A.QR=new yt(new ft(v),c,n),A.QM=new yt(new ft(v),c,n),A.QO=new yt(new ft(v),c,n),A.QC=new yt(new ft(v),c,n),await s.readToBuffer(A.QL.coef,0,v,h[Fa][0].p),await s.readToBuffer(A.QR.coef,0,v,h[Ba][0].p),await s.readToBuffer(A.QM.coef,0,v,h[Sa][0].p),await s.readToBuffer(A.QO.coef,0,v,h[xa][0].p),await s.readToBuffer(A.QC.coef,0,v,h[va][0].p),n&&n.info(" Computing evaluations"),_.addEvaluation("ql",A.QL.evaluate(U.xi)),_.addEvaluation("qr",A.QR.evaluate(U.xi)),_.addEvaluation("qm",A.QM.evaluate(U.xi)),_.addEvaluation("qo",A.QO.evaluate(U.xi)),_.addEvaluation("qc",A.QC.evaluate(U.xi)),_.addEvaluation("s1",A.Sigma1.evaluate(U.xi)),_.addEvaluation("s2",A.Sigma2.evaluate(U.xi)),_.addEvaluation("s3",A.Sigma3.evaluate(U.xi)),_.addEvaluation("a",A.A.evaluate(U.xi)),_.addEvaluation("b",A.B.evaluate(U.xi)),_.addEvaluation("c",A.C.evaluate(U.xi)),_.addEvaluation("z",A.Z.evaluate(U.xi)),U.xiw=f.mul(U.xi,f.w[d.power]),_.addEvaluation("zw",A.Z.evaluate(U.xiw)),_.addEvaluation("t1w",A.T1.evaluate(U.xiw)),_.addEvaluation("t2w",A.T2.evaluate(U.xiw))}async function Y(){n&&n.info("> Computing challenge alpha");const Q=new Yn(c);Q.addScalar(U.xiSeed),Q.addScalar(_.getEvaluation("ql")),Q.addScalar(_.getEvaluation("qr")),Q.addScalar(_.getEvaluation("qm")),Q.addScalar(_.getEvaluation("qo")),Q.addScalar(_.getEvaluation("qc")),Q.addScalar(_.getEvaluation("s1")),Q.addScalar(_.getEvaluation("s2")),Q.addScalar(_.getEvaluation("s3")),Q.addScalar(_.getEvaluation("a")),Q.addScalar(_.getEvaluation("b")),Q.addScalar(_.getEvaluation("c")),Q.addScalar(_.getEvaluation("z")),Q.addScalar(_.getEvaluation("zw")),Q.addScalar(_.getEvaluation("t1w")),Q.addScalar(_.getEvaluation("t2w")),U.alpha=Q.getChallenge(),n&&n.info(" challenges.alpha: "+f.toString(U.alpha)),n&&n.info("> Reading C0 polynomial"),A.C0=new yt(new ft(v*8),c,n),await s.readToBuffer(A.C0.coef,0,v*8,h[te][0].p),n&&n.info("> Computing R0 polynomial"),X(),n&&n.info("> Computing R1 polynomial"),k(),n&&n.info("> Computing R2 polynomial"),J(),n&&n.info("> Computing F polynomial"),await m(),n&&n.info("> Computing W1 multi exponentiation");let it=await A.F.multiExponentiation(b,"W1");return _.addPolynomial("W1",it),0;function X(){if(A.R0=yt.lagrangePolynomialInterpolation([I.S0.h0w8[0],I.S0.h0w8[1],I.S0.h0w8[2],I.S0.h0w8[3],I.S0.h0w8[4],I.S0.h0w8[5],I.S0.h0w8[6],I.S0.h0w8[7]],[A.C0.evaluate(I.S0.h0w8[0]),A.C0.evaluate(I.S0.h0w8[1]),A.C0.evaluate(I.S0.h0w8[2]),A.C0.evaluate(I.S0.h0w8[3]),A.C0.evaluate(I.S0.h0w8[4]),A.C0.evaluate(I.S0.h0w8[5]),A.C0.evaluate(I.S0.h0w8[6]),A.C0.evaluate(I.S0.h0w8[7])],c),A.R0.degree()>7)throw new Error("R0 Polynomial is not well calculated")}function k(){if(A.R1=yt.lagrangePolynomialInterpolation([I.S1.h1w4[0],I.S1.h1w4[1],I.S1.h1w4[2],I.S1.h1w4[3]],[A.C1.evaluate(I.S1.h1w4[0]),A.C1.evaluate(I.S1.h1w4[1]),A.C1.evaluate(I.S1.h1w4[2]),A.C1.evaluate(I.S1.h1w4[3])],c),A.R1.degree()>3)throw new Error("R1 Polynomial is not well calculated")}function J(){if(A.R2=yt.lagrangePolynomialInterpolation([I.S2.h2w3[0],I.S2.h2w3[1],I.S2.h2w3[2],I.S2.h3w3[0],I.S2.h3w3[1],I.S2.h3w3[2]],[A.C2.evaluate(I.S2.h2w3[0]),A.C2.evaluate(I.S2.h2w3[1]),A.C2.evaluate(I.S2.h2w3[2]),A.C2.evaluate(I.S2.h3w3[0]),A.C2.evaluate(I.S2.h3w3[1]),A.C2.evaluate(I.S2.h3w3[2])],c),A.R2.degree()>5)throw new Error("R2 Polynomial is not well calculated")}async function m(){n&&n.info(" Computing F polynomial"),A.F=yt.fromPolynomial(A.C0,c,n),A.F.sub(A.R0),A.F.divByZerofier(8,U.xi);let r=yt.fromPolynomial(A.C1,c,n);r.sub(A.R1),r.mulScalar(U.alpha),r.divByZerofier(4,U.xi);let C=yt.fromPolynomial(A.C2,c,n);if(C.sub(A.R2),C.mulScalar(f.square(U.alpha)),C.divByZerofier(3,U.xi),C.divByZerofier(3,U.xiw),A.F.add(r),A.F.add(C),A.F.degree()>=9*d.domainSize-6)throw new Error("F Polynomial is not well calculated")}}async function V(){n&&n.info("> Computing challenge y");const Q=new Yn(c);Q.addScalar(U.alpha),Q.addPolCommitment(_.getPolynomial("W1")),U.y=Q.getChallenge(),n&&n.info(" challenges.y: "+f.toString(U.y)),n&&n.info("> Computing L polynomial"),await m(),n&&n.info("> Computing ZTS2 polynomial"),await C();let it=A.ZTS2.evaluate(U.y);it=f.inv(it),A.L.mulScalar(it);const X=yt.fromCoefficientsArray([f.neg(U.y),f.one],c);n&&n.info("> Computing W' = L / ZTS2 polynomial");const k=A.L.divBy(X);if(k.degree()>0)throw new Error(`Degree of L(X)/(ZTS2(y)(X-y)) remainder is ${k.degree()} and should be 0`);if(A.L.degree()>=9*d.domainSize-1)throw new Error("Degree of L(X)/(ZTS2(y)(X-y)) is not correct");n&&n.info("> Computing W' multi exponentiation");let J=await A.L.multiExponentiation(b,"W2");return _.addPolynomial("W2",J),0;async function m(){n&&n.info(" Computing L polynomial");const u=A.R0.evaluate(U.y),x=A.R1.evaluate(U.y),F=A.R2.evaluate(U.y);let p=f.sub(U.y,I.S0.h0w8[0]);for(let st=1;st<8;st++)p=f.mul(p,f.sub(U.y,I.S0.h0w8[st]));let O=f.sub(U.y,I.S1.h1w4[0]);for(let st=1;st<4;st++)O=f.mul(O,f.sub(U.y,I.S1.h1w4[st]));let R=f.sub(U.y,I.S2.h2w3[0]);for(let st=1;st<3;st++)R=f.mul(R,f.sub(U.y,I.S2.h2w3[st]));for(let st=0;st<3;st++)R=f.mul(R,f.sub(U.y,I.S2.h3w3[st]));let N=f.mul(O,R),H=f.mul(U.alpha,f.mul(p,R)),lt=f.mul(f.square(U.alpha),f.mul(p,O));P.denH1=O,P.denH2=R,A.L=yt.fromPolynomial(A.C0,c,n),A.L.subScalar(u),A.L.mulScalar(N);let ht=yt.fromPolynomial(A.C1,c,n);ht.subScalar(x),ht.mulScalar(H);let pt=yt.fromPolynomial(A.C2,c,n);pt.subScalar(F),pt.mulScalar(lt),A.L.add(ht),A.L.add(pt),n&&n.info("> Computing ZT polynomial"),await r();const ut=A.ZT.evaluate(U.y);if(A.F.mulScalar(ut),A.L.sub(A.F),A.L.degree()>=9*d.domainSize)throw new Error("L Polynomial is not well calculated");delete E.L}async function r(){A.ZT=yt.zerofierPolynomial([I.S0.h0w8[0],I.S0.h0w8[1],I.S0.h0w8[2],I.S0.h0w8[3],I.S0.h0w8[4],I.S0.h0w8[5],I.S0.h0w8[6],I.S0.h0w8[7],I.S1.h1w4[0],I.S1.h1w4[1],I.S1.h1w4[2],I.S1.h1w4[3],I.S2.h2w3[0],I.S2.h2w3[1],I.S2.h2w3[2],I.S2.h3w3[0],I.S2.h3w3[1],I.S2.h3w3[2]],c)}async function C(){A.ZTS2=yt.zerofierPolynomial([I.S1.h1w4[0],I.S1.h1w4[1],I.S1.h1w4[2],I.S1.h1w4[3],I.S2.h2w3[0],I.S2.h2w3[1],I.S2.h2w3[2],I.S2.h3w3[0],I.S2.h3w3[1],I.S2.h3w3[2]],c)}}function nt(){let Q=U.xi;for(let C=0;C<d.power;C++)Q=f.square(Q);P.zh=f.sub(Q,f.one),J(P,I.S0.h0w8,U.y,c),m(P,I.S1.h1w4,U.y,c),r(P,I.S2.h2w3,I.S2.h3w3,U.y,U.xi,U.xiw,c);const it=Math.max(1,d.nPublic);let X=f.one;for(let C=0;C<it;C++)P["Li_"+(C+1)]=f.mul(f.e(d.domainSize),f.sub(U.xi,X)),X=f.mul(X,f.w[d.power]);let k=f.one;for(const C of Object.values(P))if(Array.isArray(C))for(const u of C)k=f.mul(k,u);else k=f.mul(k,C);return f.inv(k);function J(C,u,x,F){const p=F.Fr,O=u.length,R=p.mul(p.e(O),p.exp(u[0],O-2)),N=[];for(let H=0;H<O;H++){const lt=u[(O-1)*H%O],ht=p.sub(x,u[H]);C[["LiS0_"+(H+1)]]=p.mul(p.mul(R,lt),ht)}return N}function m(C,u,x,F){const p=F.Fr,O=u.length,R=p.mul(p.e(O),p.exp(u[0],O-2)),N=[];for(let H=0;H<O;H++){const lt=u[(O-1)*H%O],ht=p.sub(x,u[H]);C[["LiS1_"+(H+1)]]=p.mul(p.mul(R,lt),ht)}return N}function r(C,u,x,F,p,O,R){const N=R.Fr,H=[],lt=N.mul(N.e(3),u[0]),ht=N.sub(p,O);let pt=N.mul(lt,ht);for(let ct=0;ct<3;ct++){const Lt=u[2*ct%3],At=N.sub(F,u[ct]);C[["LiS2_"+(ct+1)]]=N.mul(pt,N.mul(Lt,At))}const ut=N.mul(N.e(3),x[0]),st=N.sub(O,p);pt=N.mul(ut,st);for(let ct=0;ct<3;ct++){const Lt=x[2*ct%3],At=N.sub(F,x[ct]);C[["LiS2_"+(ct+1+3)]]=N.mul(pt,N.mul(Lt,At))}return H}}}const{unstringifyBigInts:Kd}=cn;async function jd(o,t,n,a,i,e){const l=Kd(o),s={type:"mem"};return await li(l,t,s,i),await Ts(n,s,a,e)}const{unstringifyBigInts:Ui}=cn;async function Zd(o,t,n,a){a&&a.info("FFLONK VERIFIER STARTED"),o=Ui(o),n=Ui(n);const i=await ta(o.curve),e=Wd(i,o),l=new Ce(i,a);l.fromObjectProof(n);const s=Ui(t);if(s.length!==e.nPublic)return a.error("Number of public signals does not match with vk"),!1;const h=i.Fr;if(a&&(a.info("----------------------------"),a.info("  FFLONK VERIFY SETTINGS"),a.info(`  Curve:         ${i.name}`),a.info(`  Circuit power: ${e.power}`),a.info(`  Domain size:   ${2**e.power}`),a.info(`  Public vars:   ${e.nPublic}`),a.info("----------------------------")),a&&a.info("> Checking commitments belong to G1"),!Yd(i,l,e))return a&&a.error("Proof commitments are not valid"),!1;if(a&&a.info("> Checking evaluations belong to F"),!Xd(i,l))return a&&a.error("Proof evaluations are not valid."),!1;if(a&&a.info("> Checking public inputs belong to F"),!Jd(i,s))return a&&a.error("Public inputs are not valid."),!1;a&&a.info("> Computing challenges");const{challenges:d,roots:c}=tu(i,l,e,s,a);a&&a.info("> Computing Zero polynomial evaluation Z_H(xi)"),d.zh=h.sub(d.xiN,h.one),d.invzh=h.inv(d.zh),a&&a.info("> Computing Lagrange evaluations");const f=await nu(i,d,e);a&&a.info("> Computing polynomial identities PI(X)");const y=au(i,s,f);a&&a.info("> Computing r0(y)");const L=iu(l,d,c,i,a);a&&a.info("> Computing r1(y)");const v=eu(l,d,c,y,i,a);a&&a.info("> Computing r2(y)");const T=ou(l,d,c,f[1],e,i,a);a&&a.info("> Computing F");const B=su(i,l,e,d,c);a&&a.info("> Computing E");const E=cu(i,l,d,e,L,v,T);a&&a.info("> Computing J");const A=lu(i,l,d);a&&a.info("> Validate all evaluations with a pairing");const G=await ru(i,l,d,e,B,E,A);return a&&(G?a.info("PROOF VERIFIED SUCCESSFULLY"):a.warn("Invalid Proof")),a&&a.info("FFLONK VERIFIER FINISHED"),G}function Wd(o,t){const n=t;return n.k1=o.Fr.fromObject(t.k1),n.k2=o.Fr.fromObject(t.k2),n.w=o.Fr.fromObject(t.w),n.w3=o.Fr.fromObject(t.w3),n.w4=o.Fr.fromObject(t.w4),n.w8=o.Fr.fromObject(t.w8),n.wr=o.Fr.fromObject(t.wr),n.X_2=o.G2.fromObject(t.X_2),n.C0=o.G1.fromObject(t.C0),n}function Yd(o,t,n){const a=o.G1;return a.isValid(t.polynomials.C1)&&a.isValid(t.polynomials.C2)&&a.isValid(t.polynomials.W1)&&a.isValid(t.polynomials.W2)&&a.isValid(n.C0)}function Os(o,t){return Ft.lt(t,o.r)}function rn(o,t){return Os(o,Ft.fromRprLE(t))}function Xd(o,t){return rn(o,t.evaluations.ql)&&rn(o,t.evaluations.qr)&&rn(o,t.evaluations.qm)&&rn(o,t.evaluations.qo)&&rn(o,t.evaluations.qc)&&rn(o,t.evaluations.s1)&&rn(o,t.evaluations.s2)&&rn(o,t.evaluations.s3)&&rn(o,t.evaluations.a)&&rn(o,t.evaluations.b)&&rn(o,t.evaluations.c)&&rn(o,t.evaluations.z)&&rn(o,t.evaluations.zw)&&rn(o,t.evaluations.t1w)&&rn(o,t.evaluations.t2w)}function Jd(o,t){for(let n=0;n<t.length;n++)if(!Os(o,t[n]))return!1;return!0}function tu(o,t,n,a,i){const e=o.Fr,l={},s={},h=new Yn(o);h.addPolCommitment(n.C0);for(let v=0;v<a.length;v++)h.addScalar(e.e(a[v]));h.addPolCommitment(t.polynomials.C1),l.beta=h.getChallenge(),h.reset(),h.addScalar(l.beta),l.gamma=h.getChallenge(),h.reset(),h.addScalar(l.gamma),h.addPolCommitment(t.polynomials.C2);const d=h.getChallenge(),c=e.square(d);let f=[];f[1]=n.w8,f[2]=e.square(n.w8),f[3]=e.mul(f[2],n.w8),f[4]=e.mul(f[3],n.w8),f[5]=e.mul(f[4],n.w8),f[6]=e.mul(f[5],n.w8),f[7]=e.mul(f[6],n.w8);let y=[];y[1]=n.w4,y[2]=e.square(n.w4),y[3]=e.mul(y[2],n.w4);let L=[];L[1]=n.w3,L[2]=e.square(n.w3),s.S0={},s.S0.h0w8=[],s.S0.h0w8[0]=e.mul(c,d);for(let v=1;v<8;v++)s.S0.h0w8[v]=e.mul(s.S0.h0w8[0],f[v]);s.S1={},s.S1.h1w4=[],s.S1.h1w4[0]=e.square(s.S0.h0w8[0]);for(let v=1;v<4;v++)s.S1.h1w4[v]=e.mul(s.S1.h1w4[0],y[v]);s.S2={},s.S2.h2w3=[],s.S2.h2w3[0]=e.mul(s.S1.h1w4[0],c),s.S2.h2w3[1]=e.mul(s.S2.h2w3[0],L[1]),s.S2.h2w3[2]=e.mul(s.S2.h2w3[0],L[2]),s.S2.h3w3=[],s.S2.h3w3[0]=e.mul(s.S2.h2w3[0],n.wr),s.S2.h3w3[1]=e.mul(s.S2.h3w3[0],L[1]),s.S2.h3w3[2]=e.mul(s.S2.h3w3[0],L[2]),l.xi=e.mul(e.square(s.S2.h2w3[0]),s.S2.h2w3[0]),l.xiw=e.mul(l.xi,e.w[n.power]),l.xiN=l.xi,n.domainSize=1;for(let v=0;v<n.power;v++)l.xiN=e.square(l.xiN),n.domainSize*=2;return h.reset(),h.addScalar(d),h.addScalar(t.evaluations.ql),h.addScalar(t.evaluations.qr),h.addScalar(t.evaluations.qm),h.addScalar(t.evaluations.qo),h.addScalar(t.evaluations.qc),h.addScalar(t.evaluations.s1),h.addScalar(t.evaluations.s2),h.addScalar(t.evaluations.s3),h.addScalar(t.evaluations.a),h.addScalar(t.evaluations.b),h.addScalar(t.evaluations.c),h.addScalar(t.evaluations.z),h.addScalar(t.evaluations.zw),h.addScalar(t.evaluations.t1w),h.addScalar(t.evaluations.t2w),l.alpha=h.getChallenge(),h.reset(),h.addScalar(l.alpha),h.addPolCommitment(t.polynomials.W1),l.y=h.getChallenge(),i&&(i.info(" challenges.beta:  "+e.toString(l.beta)),i.info(" challenges.gamma: "+e.toString(l.gamma)),i.info(" challenges.xi:    "+e.toString(l.xi)),i.info(" challenges.alpha: "+e.toString(l.alpha)),i.info(" challenges.y:     "+e.toString(l.y))),{challenges:l,roots:s}}async function nu(o,t,n){const a=o.Fr,i=Math.max(1,n.nPublic),e=new ft(i*a.n8);let l=new ft(i*a.n8),s=a.one;for(let d=0;d<i;d++){const c=d*a.n8;e.set(a.mul(s,t.zh),c),l.set(a.mul(a.e(n.domainSize),a.sub(t.xi,s)),c),s=a.mul(s,n.w)}l=await a.batchInverse(l);let h=[];for(let d=0;d<i;d++){const c=d*a.n8;h[d+1]=a.mul(e.slice(c,c+a.n8),l.slice(c,c+a.n8))}return h}function au(o,t,n){const a=o.Fr;let i=a.zero;for(let e=0;e<t.length;e++){const l=a.e(t[e]);i=a.sub(i,a.mul(l,n[e+1]))}return i}function iu(o,t,n,a,i){const e=a.Fr,l=Us(n.S0.h0w8,t.y,t.xi,a);i&&i.info(" Computing r0(y)");let s=e.zero;for(let h=0;h<8;h++){let d=[];d[1]=n.S0.h0w8[h];for(let f=2;f<8;f++)d[f]=e.mul(d[f-1],n.S0.h0w8[h]);let c=e.add(o.evaluations.ql,e.mul(o.evaluations.qr,d[1]));c=e.add(c,e.mul(o.evaluations.qo,d[2])),c=e.add(c,e.mul(o.evaluations.qm,d[3])),c=e.add(c,e.mul(o.evaluations.qc,d[4])),c=e.add(c,e.mul(o.evaluations.s1,d[5])),c=e.add(c,e.mul(o.evaluations.s2,d[6])),c=e.add(c,e.mul(o.evaluations.s3,d[7])),s=e.add(s,e.mul(c,l[h]))}return s}function eu(o,t,n,a,i,e){const l=i.Fr,s=Us(n.S1.h1w4,t.y,t.xi,i);e&&e.info(" Computing T0(xi)");let h=l.mul(o.evaluations.ql,o.evaluations.a);h=l.add(h,l.mul(o.evaluations.qr,o.evaluations.b)),h=l.add(h,l.mul(o.evaluations.qm,l.mul(o.evaluations.a,o.evaluations.b))),h=l.add(h,l.mul(o.evaluations.qo,o.evaluations.c)),h=l.add(h,o.evaluations.qc),h=l.add(h,a),h=l.mul(h,t.invzh),e&&e.info(" Computing C1(h_1_4^i) values");let d=l.zero;for(let c=0;c<4;c++){let f=o.evaluations.a;f=l.add(f,l.mul(n.S1.h1w4[c],o.evaluations.b));const y=l.square(n.S1.h1w4[c]);f=l.add(f,l.mul(y,o.evaluations.c)),f=l.add(f,l.mul(l.mul(y,n.S1.h1w4[c]),h)),d=l.add(d,l.mul(f,s[c]))}return d}function ou(o,t,n,a,i,e,l){const s=e.Fr,h=du([n.S2.h2w3,n.S2.h3w3],t.y,t.xi,t.xiw,e);l&&l.info(" Computing T1(xi)");let d=s.sub(o.evaluations.z,s.one);d=s.mul(d,a),d=s.mul(d,t.invzh),l&&l.info(" Computing T2(xi)");const c=s.mul(t.beta,t.xi),f=s.add(o.evaluations.a,s.add(c,t.gamma)),y=s.add(o.evaluations.b,s.add(s.mul(c,i.k1),t.gamma)),L=s.add(o.evaluations.c,s.add(s.mul(c,i.k2),t.gamma)),v=s.mul(f,s.mul(y,s.mul(L,o.evaluations.z))),T=s.add(o.evaluations.a,s.add(s.mul(t.beta,o.evaluations.s1),t.gamma)),B=s.add(o.evaluations.b,s.add(s.mul(t.beta,o.evaluations.s2),t.gamma)),E=s.add(o.evaluations.c,s.add(s.mul(t.beta,o.evaluations.s3),t.gamma)),A=s.mul(T,s.mul(B,s.mul(E,o.evaluations.zw)));let G=s.sub(v,A);G=s.mul(G,t.invzh),l&&l.info(" Computing C2(h_2_3^i) values");let P=s.zero;for(let U=0;U<3;U++){let I=s.add(o.evaluations.z,s.mul(n.S2.h2w3[U],d));I=s.add(I,s.mul(s.square(n.S2.h2w3[U]),G)),P=s.add(P,s.mul(I,h[U]))}l&&l.info(" Computing C2(h_3_3^i) values");for(let U=0;U<3;U++){let I=s.add(o.evaluations.zw,s.mul(n.S2.h3w3[U],o.evaluations.t1w));I=s.add(I,s.mul(s.square(n.S2.h3w3[U]),o.evaluations.t2w)),P=s.add(P,s.mul(I,h[U+3]))}return P}function su(o,t,n,a,i){const e=o.G1,l=o.Fr;let s=l.sub(a.y,i.S0.h0w8[0]);for(let y=1;y<8;y++)s=l.mul(s,l.sub(a.y,i.S0.h0w8[y]));a.temp=s;let h=l.sub(a.y,i.S1.h1w4[0]);for(let y=1;y<4;y++)h=l.mul(h,l.sub(a.y,i.S1.h1w4[y]));let d=l.sub(a.y,i.S2.h2w3[0]);for(let y=1;y<3;y++)d=l.mul(d,l.sub(a.y,i.S2.h2w3[y]));for(let y=0;y<3;y++)d=l.mul(d,l.sub(a.y,i.S2.h3w3[y]));a.quotient1=l.mul(a.alpha,l.div(s,h)),a.quotient2=l.mul(l.square(a.alpha),l.div(s,d));let c=e.timesFr(t.polynomials.C1,a.quotient1),f=e.timesFr(t.polynomials.C2,a.quotient2);return e.add(n.C0,e.add(c,f))}function cu(o,t,n,a,i,e,l){const s=o.G1,h=o.Fr;let d=h.mul(e,n.quotient1),c=h.mul(l,n.quotient2);return s.timesFr(s.one,h.add(i,h.add(d,c)))}function lu(o,t,n){return o.G1.timesFr(t.polynomials.W1,n.temp)}async function ru(o,t,n,a,i,e,l){const s=o.G1;let h=s.timesFr(t.polynomials.W2,n.y);h=s.add(s.sub(s.sub(i,e),l),h);const d=o.G2.one,c=t.polynomials.W2,f=a.X_2;return await o.pairingEq(s.neg(h),d,c,f)}function Us(o,t,n,a){const i=a.Fr,e=o.length,l=i.sub(i.exp(t,e),n),s=i.mul(i.e(e),i.exp(o[0],e-2)),h=[];for(let d=0;d<e;d++){const c=o[(e-1)*d%e],f=i.sub(t,o[d]);h[d]=i.div(l,i.mul(i.mul(s,c),f))}return h}function du(o,t,n,a,i){const e=i.Fr,l=[],s=o[0].length,h=s*o.length,d=e.exp(t,h),c=e.mul(e.add(n,a),e.exp(t,s)),f=e.mul(n,a),y=e.add(e.sub(d,c),f);let L=e.mul(e.mul(e.e(s),o[0][0]),e.sub(n,a));for(let v=0;v<s;v++){const T=o[0][(s-1)*v%s],B=e.sub(t,o[0][v]),E=e.mul(L,e.mul(T,B));l[v]=e.div(y,E)}L=e.mul(e.mul(e.e(s),o[1][0]),e.sub(a,n));for(let v=0;v<s;v++){const T=o[1][(s-1)*v%s],B=e.sub(t,o[1][v]),E=e.mul(L,e.mul(T,B));l[v+s]=e.div(y,E)}return l}const{unstringifyBigInts:bo}=cn;function tn(o){let t=o.toString(16);for(;t.length<64;)t="0"+t;return t=`0x${t}`,t}async function uu(o,t){const n=bo(t),a=bo(o);await ta(n.curve);let i="";for(let e=0;e<a.length;e++)i!==""&&(i=i+","),i=i+tn(a[e]);return`[${tn(n.polynomials.C1[0])}, ${tn(n.polynomials.C1[1])},${tn(n.polynomials.C2[0])},${tn(n.polynomials.C2[1])},${tn(n.polynomials.W1[0])},${tn(n.polynomials.W1[1])},${tn(n.polynomials.W2[0])},${tn(n.polynomials.W2[1])},${tn(n.evaluations.ql)},${tn(n.evaluations.qr)},${tn(n.evaluations.qm)},${tn(n.evaluations.qo)},${tn(n.evaluations.qc)},${tn(n.evaluations.s1)},${tn(n.evaluations.s2)},${tn(n.evaluations.s3)},${tn(n.evaluations.a)},${tn(n.evaluations.b)},${tn(n.evaluations.c)},${tn(n.evaluations.z)},${tn(n.evaluations.zw)},${tn(n.evaluations.t1w)},${tn(n.evaluations.t2w)},${tn(n.evaluations.inv)}],[${i}]`}var bu=Object.freeze({__proto__:null,setup:Hd,prove:Ts,fullProve:jd,verify:Zd,exportSolidityVerifier:vs,exportSolidityCallData:uu});export{hu as curves,bu as fflonk,_u as groth16,mu as plonk,gu as powersOfTau,pu as r1cs,wu as wtns,Lu as zKey};
